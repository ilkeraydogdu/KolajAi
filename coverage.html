
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dbinfo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kolajAi/cmd/db-tools/dbinfo/main.go (0.0%)</option>
				
				<option value="file1">kolajAi/cmd/db-tools/dbquery/main.go (0.0%)</option>
				
				<option value="file2">kolajAi/cmd/db-tools/main.go (0.0%)</option>
				
				<option value="file3">kolajAi/cmd/seed/main.go (0.0%)</option>
				
				<option value="file4">kolajAi/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">kolajAi/internal/config/config.go (0.0%)</option>
				
				<option value="file6">kolajAi/internal/config/database.go (0.0%)</option>
				
				<option value="file7">kolajAi/internal/config/notification.go (0.0%)</option>
				
				<option value="file8">kolajAi/internal/config/routes.go (0.0%)</option>
				
				<option value="file9">kolajAi/internal/config/tables.go (0.0%)</option>
				
				<option value="file10">kolajAi/internal/core/errors.go (0.0%)</option>
				
				<option value="file11">kolajAi/internal/database/audit.go (0.0%)</option>
				
				<option value="file12">kolajAi/internal/database/cache.go (0.0%)</option>
				
				<option value="file13">kolajAi/internal/database/connection.go (12.7%)</option>
				
				<option value="file14">kolajAi/internal/database/db.go (0.0%)</option>
				
				<option value="file15">kolajAi/internal/database/dynamic_repository.go (0.0%)</option>
				
				<option value="file16">kolajAi/internal/database/migration.go (0.0%)</option>
				
				<option value="file17">kolajAi/internal/database/migrations/migrations.go (0.0%)</option>
				
				<option value="file18">kolajAi/internal/database/query_builder.go (0.0%)</option>
				
				<option value="file19">kolajAi/internal/database/repository_wrapper.go (0.0%)</option>
				
				<option value="file20">kolajAi/internal/database/seed.go (0.0%)</option>
				
				<option value="file21">kolajAi/internal/email/config.go (0.0%)</option>
				
				<option value="file22">kolajAi/internal/email/service.go (0.0%)</option>
				
				<option value="file23">kolajAi/internal/email/types.go (0.0%)</option>
				
				<option value="file24">kolajAi/internal/handlers/admin_handlers.go (0.0%)</option>
				
				<option value="file25">kolajAi/internal/handlers/ai_analytics_handlers.go (0.0%)</option>
				
				<option value="file26">kolajAi/internal/handlers/ai_handlers.go (0.0%)</option>
				
				<option value="file27">kolajAi/internal/handlers/auth.go (0.0%)</option>
				
				<option value="file28">kolajAi/internal/handlers/components.go (0.0%)</option>
				
				<option value="file29">kolajAi/internal/handlers/dashboard.go (0.0%)</option>
				
				<option value="file30">kolajAi/internal/handlers/ecommerce_handlers.go (0.0%)</option>
				
				<option value="file31">kolajAi/internal/handlers/handler.go (0.0%)</option>
				
				<option value="file32">kolajAi/internal/middleware/form.go (0.0%)</option>
				
				<option value="file33">kolajAi/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file34">kolajAi/internal/models/product.go (83.3%)</option>
				
				<option value="file35">kolajAi/internal/models/user.go (100.0%)</option>
				
				<option value="file36">kolajAi/internal/repository/base_repository.go (0.0%)</option>
				
				<option value="file37">kolajAi/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file38">kolajAi/internal/router/router.go (0.0%)</option>
				
				<option value="file39">kolajAi/internal/services/ai_analytics_service.go (0.0%)</option>
				
				<option value="file40">kolajAi/internal/services/ai_service.go (0.0%)</option>
				
				<option value="file41">kolajAi/internal/services/auction_service.go (0.0%)</option>
				
				<option value="file42">kolajAi/internal/services/auth_service.go (0.0%)</option>
				
				<option value="file43">kolajAi/internal/services/inventory_service.go (0.0%)</option>
				
				<option value="file44">kolajAi/internal/services/order_service.go (0.0%)</option>
				
				<option value="file45">kolajAi/internal/services/product_service.go (0.6%)</option>
				
				<option value="file46">kolajAi/internal/services/vendor_service.go (0.0%)</option>
				
				<option value="file47">kolajAi/internal/ui/components/notification.go (0.0%)</option>
				
				<option value="file48">kolajAi/internal/ui/rendering/component_renderer.go (0.0%)</option>
				
				<option value="file49">kolajAi/internal/validation/rules.go (0.0%)</option>
				
				<option value="file50">kolajAi/internal/validation/schemas.go (0.0%)</option>
				
				<option value="file51">kolajAi/internal/validation/validation.go (0.0%)</option>
				
				<option value="file52">kolajAi/internal/validation/validators.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "database/sql"
        "fmt"
        "log"

        "kolajAi/internal/database"
)

func main() <span class="cov0" title="0">{
        fmt.Println("KolajAI Veritabanı Bilgi Aracı")
        fmt.Println("==============================")

        // Veritabanı yapılandırması
        dbConfig := database.DefaultConfig()
        fmt.Printf("Veritabanı: %s@%s:%d/%s\n\n",
                dbConfig.User, dbConfig.Host, dbConfig.Port, dbConfig.DatabaseName)

        // Veritabanı bağlantısı
        db, err := database.InitDB(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Veritabanı bağlantısı yapılamadı: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        fmt.Println("Veritabanı bağlantısı başarılı!")

        // Tabloları listele
        tables, err := getTables(db)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Tablolar listelenirken hata oluştu: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nVeritabanı Tabloları:")
        fmt.Println("====================")
        for _, table := range tables </span><span class="cov0" title="0">{
                fmt.Println(table)
        }</span>

        // Önce users tablosunu göster
        <span class="cov0" title="0">fmt.Println("\n*** USERS TABLOSU ***")
        fmt.Println("====================")
        usersColumns, err := getTableStructure(db, "users")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Hata: users tablosu yapısı alınamadı: %v", err)
        }</span> else<span class="cov0" title="0"> {
                for _, col := range usersColumns </span><span class="cov0" title="0">{
                        fmt.Printf("%-20s %-20s %-10s %-10s %s\n",
                                col.Field, col.Type, col.Null, col.Key, col.Extra)
                }</span>
        }

        // Diğer tabloların yapısını göster
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                if table == "users" </span><span class="cov0" title="0">{
                        continue</span> // Users tablosunu atla, zaten gösterdik
                }

                <span class="cov0" title="0">fmt.Printf("\nTablo Yapısı: %s\n", table)
                fmt.Println("====================")
                columns, err := getTableStructure(db, table)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Hata: %s tablosu yapısı alınamadı: %v", table, err)
                        continue</span>
                }

                <span class="cov0" title="0">for _, col := range columns </span><span class="cov0" title="0">{
                        fmt.Printf("%-20s %-20s %s\n", col.Field, col.Type, col.Extra)
                }</span>
        }

        // İstatistikler
        <span class="cov0" title="0">fmt.Println("\nTablo İstatistikleri:")
        fmt.Println("====================")
        for _, table := range tables </span><span class="cov0" title="0">{
                count, err := getRowCount(db, table)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Hata: %s tablosu satır sayısı alınamadı: %v", table, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("%-20s: %d kayıt\n", table, count)</span>
        }
}

// getTables veritabanındaki tüm tabloları listeler
func getTables(db *sql.DB) ([]string, error) <span class="cov0" title="0">{
        rows, err := db.Query("SHOW TABLES")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var table string
                if err := rows.Scan(&amp;table); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tables = append(tables, table)</span>
        }

        <span class="cov0" title="0">return tables, nil</span>
}

// ColumnInfo tablo sütun bilgilerini temsil eder
type ColumnInfo struct {
        Field   string
        Type    string
        Null    string
        Key     string
        Default sql.NullString
        Extra   string
}

// getTableStructure tablo yapısını döndürür
func getTableStructure(db *sql.DB, table string) ([]ColumnInfo, error) <span class="cov0" title="0">{
        rows, err := db.Query(fmt.Sprintf("DESCRIBE %s", table))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var columns []ColumnInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var col ColumnInfo
                if err := rows.Scan(&amp;col.Field, &amp;col.Type, &amp;col.Null, &amp;col.Key, &amp;col.Default, &amp;col.Extra); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">columns = append(columns, col)</span>
        }

        <span class="cov0" title="0">return columns, nil</span>
}

// getRowCount tablodaki satır sayısını döndürür
func getRowCount(db *sql.DB, table string) (int, error) <span class="cov0" title="0">{
        var count int
        err := db.QueryRow(fmt.Sprintf("SELECT COUNT(*) FROM %s", table)).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "strings"

        "kolajAi/internal/database"
)

func dbQuery() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Kullanım: go run cmd/tools/dbquery/main.go \"SQL SORGUSU\"")
                os.Exit(1)
        }</span>

        // Sorguyu al
        <span class="cov0" title="0">query := strings.Join(os.Args[1:], " ")
        fmt.Printf("Çalıştırılacak sorgu: %s\n\n", query)

        // Veritabanı yapılandırması
        dbConfig := database.DefaultConfig()

        // Veritabanı bağlantısı
        db, err := database.InitDB(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Veritabanı bağlantısı yapılamadı: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Sorgu türünü belirle (SELECT, INSERT, UPDATE, DELETE)
        queryType := strings.ToUpper(strings.Split(strings.TrimSpace(query), " ")[0])

        // Sorguyu çalıştır
        switch queryType </span>{
        case "SELECT":<span class="cov0" title="0">
                executeSelectQuery(db, query)</span>
        case "INSERT", "UPDATE", "DELETE":<span class="cov0" title="0">
                executeUpdateQuery(db, query)</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Desteklenmeyen sorgu türü: %s\n", queryType)</span>
        }
}

func main() <span class="cov0" title="0">{
        dbQuery()
}</span>

// executeSelectQuery SELECT sorgusunu çalıştırır ve sonuçları gösterir
func executeSelectQuery(db *sql.DB, query string) <span class="cov0" title="0">{
        rows, err := db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Sorgu çalıştırılırken hata oluştu: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Sütun bilgilerini al
        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Sütun bilgileri alınamadı: %v", err)
        }</span>

        // Sonuçları depolamak için değişkenler
        <span class="cov0" title="0">values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values </span><span class="cov0" title="0">{
                valuePtrs[i] = &amp;values[i]
        }</span>

        // Sonuçları JSON formatında göstermek için
        <span class="cov0" title="0">var results []map[string]interface{}

        // Satırları oku
        for rows.Next() </span><span class="cov0" title="0">{
                // Satırı oku
                err := rows.Scan(valuePtrs...)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Satır okunurken hata oluştu: %v", err)
                }</span>

                // Satırı map'e dönüştür
                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, col := range columns </span><span class="cov0" title="0">{
                        val := values[i]

                        // byte array'i string'e dönüştür
                        b, ok := val.([]byte)
                        if ok </span><span class="cov0" title="0">{
                                row[col] = string(b)
                        }</span> else<span class="cov0" title="0"> {
                                row[col] = val
                        }</span>
                }

                <span class="cov0" title="0">results = append(results, row)</span>
        }

        // Sonuçları göster
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Sonuç bulunamadı.")
                return
        }</span>

        // JSON formatında göster
        <span class="cov0" title="0">jsonData, err := json.MarshalIndent(results, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("JSON formatına dönüştürülürken hata oluştu: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonData))</span>
}

// executeUpdateQuery INSERT, UPDATE veya DELETE sorgusunu çalıştırır
func executeUpdateQuery(db *sql.DB, query string) <span class="cov0" title="0">{
        result, err := db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Sorgu çalıştırılırken hata oluştu: %v", err)
        }</span>

        // Etkilenen satır sayısını göster
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Etkilenen satır sayısı alınamadı: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Etkilenen satır sayısı: %d\n", rowsAffected)

        // Eğer INSERT ise son eklenen ID'yi göster
        if strings.HasPrefix(strings.ToUpper(strings.TrimSpace(query)), "INSERT") </span><span class="cov0" title="0">{
                lastInsertID, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Son eklenen ID alınamadı: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Son eklenen ID: %d\n", lastInsertID)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        switch command </span>{
        case "info":<span class="cov0" title="0">
                runDBInfo()</span>
        case "query":<span class="cov0" title="0">
                runDBQuery()</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Bilinmeyen komut: %s\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("Kullanım: go run cmd/tools/db_tools.go KOMUT [PARAMETRELER]")
        fmt.Println("\nKomutlar:")
        fmt.Println("  info    Veritabanı yapısı hakkında bilgi gösterir")
        fmt.Println("  query   SQL sorgusu çalıştırır (örn: \"SELECT * FROM users\")")
}</span>

func runDBInfo() <span class="cov0" title="0">{
        cmd := exec.Command("go", "run", filepath.Join("cmd", "db-tools", "dbinfo", "main.go"))
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Hata: %v\n", err)
                os.Exit(1)
        }</span>
}

func runDBQuery() <span class="cov0" title="0">{
        if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Println("Hata: Sorgu belirtilmedi")
                fmt.Println("Kullanım: go run cmd/tools/db_tools.go query \"SQL SORGUSU\"")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">args := []string{"run", filepath.Join("cmd", "db-tools", "dbquery", "main.go")}
        args = append(args, os.Args[2:]...)

        cmd := exec.Command("go", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Hata: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "log"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "golang.org/x/crypto/bcrypt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "kolajAi/internal/repository"
)

func main() <span class="cov0" title="0">{
        fmt.Println("KolajAI Data Seeder başlatılıyor...")

        // Veritabanı bağlantısı
        db, err := database.NewSQLiteConnection("kolajAi.db")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Veritabanı bağlantısı kurulamadı: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Repository ve servisler
        mysqlRepo := database.NewMySQLRepository(db)
        repo := repository.NewBaseRepository(mysqlRepo)

        // Kategoriler ekle
        fmt.Println("Kategoriler ekleniyor...")
        categories := []models.Category{
                {Name: "Elektronik", Description: "Elektronik ürünler", Image: "/static/images/categories/electronics.jpg", IsActive: true, SortOrder: 1},
                {Name: "Giyim", Description: "Giyim ve aksesuar", Image: "/static/images/categories/clothing.jpg", IsActive: true, SortOrder: 2},
                {Name: "Ev &amp; Yaşam", Description: "Ev dekorasyonu ve yaşam ürünleri", Image: "/static/images/categories/home.jpg", IsActive: true, SortOrder: 3},
                {Name: "Spor", Description: "Spor malzemeleri", Image: "/static/images/categories/sports.jpg", IsActive: true, SortOrder: 4},
                {Name: "Kitap", Description: "Kitaplar ve eğitim materyalleri", Image: "/static/images/categories/books.jpg", IsActive: true, SortOrder: 5},
                {Name: "Sağlık", Description: "Sağlık ve kişisel bakım", Image: "/static/images/categories/health.jpg", IsActive: true, SortOrder: 6},
        }

        for i, category := range categories </span><span class="cov0" title="0">{
                id, err := repo.CreateStruct("categories", &amp;category)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Kategori eklenirken hata: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        categories[i].ID = int(id)
                        fmt.Printf("Kategori eklendi: %s\n", category.Name)
                }</span>
        }

        // Kullanıcılar ekle
        <span class="cov0" title="0">fmt.Println("Kullanıcılar ekleniyor...")

        // Admin kullanıcı
        adminPassword, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        adminUser := models.User{
                Name:      "Admin User",
                Email:     "admin@kolajAi.com",
                Password:  string(adminPassword),
                Phone:     "0532 000 0000",
                IsActive:  true,
                IsAdmin:   true,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        adminID, err := repo.CreateStruct("users", &amp;adminUser)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Admin kullanıcı eklenirken hata: %v", err)
        }</span> else<span class="cov0" title="0"> {
                adminUser.ID = adminID
                fmt.Println("Admin kullanıcı eklendi: admin@kolajAi.com")
        }</span>

        // Satıcı kullanıcıları
        <span class="cov0" title="0">vendors := []struct {
                User   models.User
                Vendor models.Vendor
        }{
                {
                        User: models.User{
                                Name: "Ahmet Yılmaz", Email: "vendor1@kolajAi.com", Password: string(adminPassword), Phone: "0532 123 4567",
                                IsActive: true, IsAdmin: false, CreatedAt: time.Now(), UpdatedAt: time.Now(),
                        },
                        Vendor: models.Vendor{
                                CompanyName: "Yılmaz Elektronik", BusinessID: "1234567890", Phone: "0532 123 4567",
                                Address: "İstanbul, Türkiye", City: "İstanbul", Country: "Türkiye", Status: "approved",
                                CreatedAt: time.Now(), UpdatedAt: time.Now(),
                        },
                },
                {
                        User: models.User{
                                Name: "Fatma Kaya", Email: "vendor2@kolajAi.com", Password: string(adminPassword), Phone: "0533 987 6543",
                                IsActive: true, IsAdmin: false, CreatedAt: time.Now(), UpdatedAt: time.Now(),
                        },
                        Vendor: models.Vendor{
                                CompanyName: "Kaya Giyim", BusinessID: "0987654321", Phone: "0533 987 6543",
                                Address: "Ankara, Türkiye", City: "Ankara", Country: "Türkiye", Status: "approved",
                                CreatedAt: time.Now(), UpdatedAt: time.Now(),
                        },
                },
        }

        for _, v := range vendors </span><span class="cov0" title="0">{
                userID, err := repo.CreateStruct("users", &amp;v.User)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Satıcı kullanıcı eklenirken hata: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">v.Vendor.UserID = int(userID)
                vendorID, err := repo.CreateStruct("vendors", &amp;v.Vendor)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Satıcı bilgisi eklenirken hata: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        v.Vendor.ID = int(vendorID)
                        fmt.Printf("Satıcı eklendi: %s (%s)\n", v.Vendor.CompanyName, v.User.Email)
                }</span>
        }

        // Normal kullanıcılar
        <span class="cov0" title="0">normalUsers := []models.User{
                {Name: "Mehmet Demir", Email: "user1@kolajAi.com", Password: string(adminPassword), Phone: "0534 111 1111", IsActive: true, IsAdmin: false, CreatedAt: time.Now(), UpdatedAt: time.Now()},
                {Name: "Ayşe Çelik", Email: "user2@kolajAi.com", Password: string(adminPassword), Phone: "0535 222 2222", IsActive: true, IsAdmin: false, CreatedAt: time.Now(), UpdatedAt: time.Now()},
                {Name: "Ali Öz", Email: "user3@kolajAi.com", Password: string(adminPassword), Phone: "0536 333 3333", IsActive: true, IsAdmin: false, CreatedAt: time.Now(), UpdatedAt: time.Now()},
        }

        for _, user := range normalUsers </span><span class="cov0" title="0">{
                userID, err := repo.CreateStruct("users", &amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Kullanıcı eklenirken hata: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        user.ID = userID
                        fmt.Printf("Kullanıcı eklendi: %s (%s)\n", user.Name, user.Email)
                }</span>
        }

        // Ürünler ekle
        <span class="cov0" title="0">fmt.Println("Ürünler ekleniyor...")
        products := []models.Product{
                {
                        VendorID: 1, CategoryID: 1, Name: "iPhone 15 Pro", Description: "Apple iPhone 15 Pro 128GB",
                        ShortDesc: "En yeni iPhone modeli", SKU: "IPH15PRO128", Price: 45000.00, ComparePrice: 50000.00,
                        Stock: 50, Status: "active", IsFeatured: true, AllowReviews: true,
                        Tags: "iphone,apple,telefon,akıllı telefon", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
                {
                        VendorID: 1, CategoryID: 1, Name: "Samsung Galaxy S24", Description: "Samsung Galaxy S24 256GB",
                        ShortDesc: "Samsung'un flagShip modeli", SKU: "SAMS24256", Price: 35000.00, ComparePrice: 40000.00,
                        Stock: 30, Status: "active", IsFeatured: true, AllowReviews: true,
                        Tags: "samsung,galaxy,telefon,android", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
                {
                        VendorID: 2, CategoryID: 2, Name: "Erkek Kot Pantolon", Description: "Slim fit erkek kot pantolon",
                        ShortDesc: "Rahat ve şık kot pantolon", SKU: "ERKEK-KOT-001", Price: 299.99, ComparePrice: 399.99,
                        Stock: 100, Status: "active", IsFeatured: false, AllowReviews: true,
                        Tags: "kot,pantolon,erkek,giyim", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
                {
                        VendorID: 2, CategoryID: 2, Name: "Kadın Elbise", Description: "Şık kadın elbisesi",
                        ShortDesc: "Özel günler için ideal", SKU: "KADIN-ELBISE-001", Price: 599.99, ComparePrice: 799.99,
                        Stock: 25, Status: "active", IsFeatured: true, AllowReviews: true,
                        Tags: "elbise,kadın,giyim,şık", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
                {
                        VendorID: 1, CategoryID: 3, Name: "Akıllı TV 55\"", Description: "4K UHD Smart TV",
                        ShortDesc: "Büyük ekran deneyimi", SKU: "SMART-TV-55", Price: 12000.00, ComparePrice: 15000.00,
                        Stock: 15, Status: "active", IsFeatured: true, AllowReviews: true,
                        Tags: "tv,televizyon,smart,4k", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
                {
                        VendorID: 1, CategoryID: 4, Name: "Fitness Bisikleti", Description: "Ev tipi fitness bisikleti",
                        ShortDesc: "Evde spor yapın", SKU: "FITNESS-BIKE-001", Price: 2500.00, ComparePrice: 3000.00,
                        Stock: 10, Status: "active", IsFeatured: false, AllowReviews: true,
                        Tags: "bisiklet,fitness,spor,egzersiz", CreatedAt: time.Now(), UpdatedAt: time.Now(),
                },
        }

        for _, product := range products </span><span class="cov0" title="0">{
                productID, err := repo.CreateStruct("products", &amp;product)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Ürün eklenirken hata: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        product.ID = int(productID)
                        fmt.Printf("Ürün eklendi: %s (₺%.2f)\n", product.Name, product.Price)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Data seeding tamamlandı!")
        fmt.Println("\nGiriş bilgileri:")
        fmt.Println("Admin: admin@kolajAi.com / admin123")
        fmt.Println("Satıcı 1: vendor1@kolajAi.com / admin123")
        fmt.Println("Satıcı 2: vendor2@kolajAi.com / admin123")
        fmt.Println("Kullanıcı 1: user1@kolajAi.com / admin123")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "html/template"
        "log"
        "net/http"
        "os"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "kolajAi/internal/database"
        "kolajAi/internal/database/migrations"
        "kolajAi/internal/handlers"
        "kolajAi/internal/repository"
        "kolajAi/internal/services"
)

var (
        MainLogger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Ana uygulama için log dosyası oluştur
        logFile, err := os.OpenFile("main_app_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Ana uygulama log dosyası oluşturulamadı:", err)
                MainLogger = log.New(os.Stdout, "[MAIN-APP-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                MainLogger = log.New(logFile, "[MAIN-APP-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

func main() <span class="cov0" title="0">{
        MainLogger.Println("KolajAI uygulaması başlatılıyor...")

        // Veritabanı bağlantısı (SQLite)
        MainLogger.Println("Veritabanı bağlantısı kuruluyor...")
        db, err := database.NewSQLiteConnection("kolajAi.db")
        if err != nil </span><span class="cov0" title="0">{
                MainLogger.Fatalf("Veritabanı bağlantısı kurulamadı: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Migration'ları çalıştır
        MainLogger.Println("Veritabanı migration'ları çalıştırılıyor...")
        migrationService := migrations.NewMigrationService(db, "kolajAi")
        if err := migrationService.RunMigrations(); err != nil </span><span class="cov0" title="0">{
                MainLogger.Fatalf("Migration'lar çalıştırılamadı: %v", err)
        }</span>
        <span class="cov0" title="0">MainLogger.Println("Migration'lar başarıyla tamamlandı!")

        // Repository oluştur
        mysqlRepo := database.NewMySQLRepository(db)
        repo := repository.NewBaseRepository(mysqlRepo)

        // Servisleri oluştur
        MainLogger.Println("Servisler oluşturuluyor...")
        vendorService := services.NewVendorService(repo)
        productService := services.NewProductService(repo)
        orderService := services.NewOrderService(repo)
        auctionService := services.NewAuctionService(repo)
        aiService := services.NewAIService(repo, productService, orderService)
        aiAnalyticsService := services.NewAIAnalyticsService(repo, productService, orderService)

        // Şablonları yükle
        MainLogger.Println("Şablonlar yükleniyor...")

        // Template fonksiyonlarını tanımla
        funcMap := template.FuncMap{
                "dict": func(values ...interface{}) (map[string]interface{}, error) </span><span class="cov0" title="0">{
                        if len(values)%2 != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("dict fonksiyonu için çift sayıda parametre gerekli")
                        }</span>
                        <span class="cov0" title="0">dict := make(map[string]interface{}, len(values)/2)
                        for i := 0; i &lt; len(values); i += 2 </span><span class="cov0" title="0">{
                                key, ok := values[i].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("dict fonksiyonu için anahtarlar string olmalı")
                                }</span>
                                <span class="cov0" title="0">dict[key] = values[i+1]</span>
                        }
                        <span class="cov0" title="0">return dict, nil</span>
                },
                "rand": func() int <span class="cov0" title="0">{
                        return time.Now().Nanosecond() % 1000
                }</span>,
                "safeHTML": func(s string) template.HTML <span class="cov0" title="0">{
                        return template.HTML(s)
                }</span>,
                "formatPrice": func(price float64) string <span class="cov0" title="0">{
                        return fmt.Sprintf("%.2f TL", price)
                }</span>,
                "formatDate": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("02.01.2006 15:04")
                }</span>,
                "seq": func(n int) []int <span class="cov0" title="0">{
                        result := make([]int, n)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                result[i] = i
                        }</span>
                        <span class="cov0" title="0">return result</span>
                },
                "mul": func(a, b interface{}) float64 <span class="cov0" title="0">{
                        var numA, numB float64
                        switch v := a.(type) </span>{
                        case int:<span class="cov0" title="0">
                                numA = float64(v)</span>
                        case float64:<span class="cov0" title="0">
                                numA = v</span>
                        case float32:<span class="cov0" title="0">
                                numA = float64(v)</span>
                        default:<span class="cov0" title="0">
                                return 0</span>
                        }
                        <span class="cov0" title="0">switch v := b.(type) </span>{
                        case int:<span class="cov0" title="0">
                                numB = float64(v)</span>
                        case float64:<span class="cov0" title="0">
                                numB = v</span>
                        case float32:<span class="cov0" title="0">
                                numB = float64(v)</span>
                        default:<span class="cov0" title="0">
                                return 0</span>
                        }
                        <span class="cov0" title="0">return numA * numB</span>
                },
                "add": func(a, b interface{}) float64 <span class="cov0" title="0">{
                        var numA, numB float64
                        switch v := a.(type) </span>{
                        case int:<span class="cov0" title="0">
                                numA = float64(v)</span>
                        case float64:<span class="cov0" title="0">
                                numA = v</span>
                        case float32:<span class="cov0" title="0">
                                numA = float64(v)</span>
                        default:<span class="cov0" title="0">
                                return 0</span>
                        }
                        <span class="cov0" title="0">switch v := b.(type) </span>{
                        case int:<span class="cov0" title="0">
                                numB = float64(v)</span>
                        case float64:<span class="cov0" title="0">
                                numB = v</span>
                        case float32:<span class="cov0" title="0">
                                numB = float64(v)</span>
                        default:<span class="cov0" title="0">
                                return 0</span>
                        }
                        <span class="cov0" title="0">return numA + numB</span>
                },
        }

        <span class="cov0" title="0">tmpl, err := template.New("").Funcs(funcMap).ParseGlob("web/templates/**/*.gohtml")
        if err != nil </span><span class="cov0" title="0">{
                MainLogger.Fatalf("Şablonlar yüklenemedi: %v", err)
        }</span>
        <span class="cov0" title="0">MainLogger.Printf("Şablonlar başarıyla yüklendi!")

        // Handler'ları oluştur
        MainLogger.Println("Handler'lar oluşturuluyor...")

        // Session manager oluştur - güvenli bir anahtar kullan
        sessionManager := handlers.NewSessionManager("supersecretkey123")

        h := &amp;handlers.Handler{
                Templates:      tmpl,
                SessionManager: sessionManager,
                TemplateContext: map[string]interface{}{
                        "AppName": "KolajAI Marketplace",
                        "Year":    time.Now().Year(),
                },
        }

        // E-ticaret handler'ı oluştur
        ecommerceHandler := handlers.NewEcommerceHandler(h, vendorService, productService, orderService, auctionService)

        // Admin handler'ı oluştur
        adminHandler := handlers.NewAdminHandler(h, productService, vendorService, orderService, auctionService)

        // AI handler'ı oluştur
        aiHandler := handlers.NewAIHandler(h, aiService)

        // AI Analytics handler'ı oluştur
        aiAnalyticsHandler := handlers.NewAIAnalyticsHandler(h, aiAnalyticsService)

        // Router oluştur ve handler'ları ekle
        router := http.NewServeMux()

        // Statik dosyalar
        router.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("web/static"))))

        // Ana sayfa - Marketplace
        router.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path != "/" </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>
                <span class="cov0" title="0">ecommerceHandler.Marketplace(w, r)</span>
        })

        // Auth işlemleri
        <span class="cov0" title="0">router.HandleFunc("/login", h.Login)
        router.HandleFunc("/register", h.Register)
        router.HandleFunc("/forgot-password", h.ForgotPassword)
        router.HandleFunc("/reset-password", h.ResetPassword)

        // Auth gerektiren sayfalar
        router.HandleFunc("/dashboard", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                        h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                        return
                }</span>
                <span class="cov0" title="0">h.Dashboard(w, r)</span>
        })

        <span class="cov0" title="0">router.HandleFunc("/logout", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                        h.RedirectWithFlash(w, r, "/login", "Zaten çıkış yapılmış")
                        return
                }</span>
                <span class="cov0" title="0">h.Logout(w, r)</span>
        })

        // E-ticaret rotaları
        <span class="cov0" title="0">router.HandleFunc("/products", ecommerceHandler.Products)
        router.HandleFunc("/product/", ecommerceHandler.ProductDetail)
        router.HandleFunc("/cart", ecommerceHandler.Cart)
        router.HandleFunc("/add-to-cart", ecommerceHandler.AddToCart)

        // Açık artırma rotaları
        router.HandleFunc("/auctions", ecommerceHandler.Auctions)
        router.HandleFunc("/auction/", ecommerceHandler.AuctionDetail)
        router.HandleFunc("/place-bid", ecommerceHandler.PlaceBid)

        // Satıcı rotaları
        router.HandleFunc("/vendor/dashboard", ecommerceHandler.VendorDashboard)

        // API rotaları
        router.HandleFunc("/api/search", ecommerceHandler.APISearchProducts)
        router.HandleFunc("/api/cart/update", ecommerceHandler.APIUpdateCart)

        // AI rotaları
        router.HandleFunc("/ai/dashboard", aiHandler.GetAIDashboard)
        router.HandleFunc("/ai/recommendations", aiHandler.GetRecommendationsPage)
        router.HandleFunc("/ai/smart-search", aiHandler.GetSmartSearchPage)
        router.HandleFunc("/ai/price-optimization", aiHandler.GetPriceOptimizationPage)

        // AI API rotaları
        router.HandleFunc("/api/ai/recommendations", aiHandler.GetRecommendations)
        router.HandleFunc("/api/ai/price-optimize/", aiHandler.OptimizePrice)
        router.HandleFunc("/api/ai/predict-category", aiHandler.PredictCategory)
        router.HandleFunc("/api/ai/smart-search", aiHandler.SmartSearch)

        // AI Analytics API rotaları
        router.HandleFunc("/api/ai/market-trends", aiAnalyticsHandler.GetMarketTrends)
        router.HandleFunc("/api/ai/product-insights/", aiAnalyticsHandler.GetProductInsights)
        router.HandleFunc("/api/ai/customer-segments", aiAnalyticsHandler.GetCustomerSegments)
        router.HandleFunc("/api/ai/pricing-strategy/", aiAnalyticsHandler.GetPricingStrategy)

        // AI Analytics sayfa rotaları
        router.HandleFunc("/ai/analytics", aiAnalyticsHandler.GetAnalyticsDashboard)
        router.HandleFunc("/ai/analytics/dashboard", aiAnalyticsHandler.GetAnalyticsDashboard)
        router.HandleFunc("/ai/analytics/market-trends", aiAnalyticsHandler.GetMarketTrendsPage)
        router.HandleFunc("/ai/analytics/product-insights", aiAnalyticsHandler.GetProductInsightsPage)
        router.HandleFunc("/ai/analytics/customer-segments", aiAnalyticsHandler.GetCustomerSegmentsPage)
        router.HandleFunc("/ai/analytics/pricing-strategy", aiAnalyticsHandler.GetPricingStrategyPage)

        // Admin rotaları
        router.HandleFunc("/admin/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/admin/" || r.URL.Path == "/admin" </span><span class="cov0" title="0">{
                        adminHandler.AdminDashboard(w, r)
                        return
                }</span>
                <span class="cov0" title="0">http.NotFound(w, r)</span>
        })
        <span class="cov0" title="0">router.HandleFunc("/admin/dashboard", adminHandler.AdminDashboard)
        router.HandleFunc("/admin/products", adminHandler.AdminProducts)
        router.HandleFunc("/admin/products/edit/", adminHandler.AdminProductEdit)
        router.HandleFunc("/admin/vendors", adminHandler.AdminVendors)
        router.HandleFunc("/admin/vendors/approve", adminHandler.AdminVendorApprove)
        router.HandleFunc("/admin/settings", adminHandler.AdminSettings)

        // Favicon
        router.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, "web/static/assets/images/favicon-32x32.png")
        }</span>)

        // Sunucuyu başlat
        <span class="cov0" title="0">addr := ":8081"
        MainLogger.Printf("Sunucu başlatılıyor: %s", addr)

        server := &amp;http.Server{
                Addr:         addr,
                Handler:      router,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        MainLogger.Printf("KolajAI uygulaması başlatıldı. %s adresinde dinleniyor...", addr)
        MainLogger.Fatal(server.ListenAndServe())</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "time"
)

// Config represents the application configuration
type Config struct {
        AppName      string             `json:"app_name"`
        Environment  string             `json:"environment"`
        Server       ServerConfig       `json:"server"`
        Database     DatabaseConfig     `json:"database"`
        Template     TemplateConfig     `json:"template"`
        Email        EmailConfig        `json:"email"`
        Notification NotificationConfig `json:"notification"`
        Routes       RoutesConfig       `json:"routes"`
        Auth         AuthConfig         `json:"auth"`
        Logger       LoggerConfig       `json:"logger"`
}

// ServerConfig represents server configuration
type ServerConfig struct {
        Host         string `json:"host"`
        Port         int    `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        IdleTimeout  int    `json:"idle_timeout"`
        Debug        bool   `json:"debug"`
        Prefork      bool   `json:"prefork"`
        BaseURL      string `json:"base_url"`
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        JWTSecret            string        `json:"jwt_secret"`
        JWTExpiration        time.Duration `json:"jwt_expiration"`
        RefreshTokenDuration time.Duration `json:"refresh_token_duration"`
        PasswordMinLength    int           `json:"password_min_length"`
        RequireUppercase     bool          `json:"require_uppercase"`
        RequireSpecialChar   bool          `json:"require_special_char"`
        RequireNumber        bool          `json:"require_number"`
        MaxLoginAttempts     int           `json:"max_login_attempts"`
        LockoutDuration      time.Duration `json:"lockout_duration"`
}

// EmailConfig holds email configuration
type EmailConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        From     string `json:"from"`
        FromName string `json:"from_name"`
        TLS      bool   `json:"tls"`
}

// TemplateConfig holds template configuration
type TemplateConfig struct {
        Dir           string `json:"dir"`
        PartialsDir   string `json:"partials_dir"`
        ComponentsDir string `json:"components_dir"`
        Extension     string `json:"extension"`
        BaseLayout    string `json:"base_layout"`
        Cache         bool   `json:"cache"`
}

// NotificationConfig holds notification configuration
type NotificationConfig struct {
        DefaultType string                      `json:"default_type"`
        DefaultTTL  time.Duration               `json:"default_ttl"`
        Timeout     int                         `json:"timeout"`
        Position    string                      `json:"position"`
        ShowClose   bool                        `json:"show_close"`
        AutoClose   bool                        `json:"auto_close"`
        Types       map[string]NotificationType `json:"types"`
}

// LoggerConfig holds logger configuration
type LoggerConfig struct {
        Level      string `json:"level"`
        File       string `json:"file"`
        MaxSize    int    `json:"max_size"`
        MaxBackups int    `json:"max_backups"`
        MaxAge     int    `json:"max_age"`
        Compress   bool   `json:"compress"`
}

// RoutesConfig holds route configuration
type RoutesConfig struct {
        API struct {
                Prefix     string   `json:"prefix"`
                Version    string   `json:"version"`
                Middleware []string `json:"middleware"`
        } `json:"api"`
        Web struct {
                Middleware []string `json:"middleware"`
        } `json:"web"`
        Assets struct {
                Path   string `json:"path"`
                Prefix string `json:"prefix"`
        } `json:"assets"`
}

// TableConfig represents a database table configuration
type TableConfig struct {
        Name    string `json:"name"`
        Columns []struct {
                Name       string `json:"name"`
                Type       string `json:"type"`
                PrimaryKey bool   `json:"primary_key,omitempty"`
                Nullable   bool   `json:"nullable,omitempty"`
                Default    string `json:"default,omitempty"`
        } `json:"columns"`
        Indexes []struct {
                Name    string   `json:"name"`
                Columns []string `json:"columns"`
                Unique  bool     `json:"unique,omitempty"`
        } `json:"indexes,omitempty"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Driver          string        `json:"driver"`
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        Username        string        `json:"username"`
        Password        string        `json:"password"`
        Database        string        `json:"database"`
        MaxOpenConns    int           `json:"max_open_conns"`
        MaxIdleConns    int           `json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
        Charset         string        `json:"charset"`
        ParseTime       bool          `json:"parse_time"`
}

// GetConfig returns the application configuration
func GetConfig() (*Config, error) <span class="cov0" title="0">{
        // First, try to load from environment variable
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                // If not set, use default path
                configPath = "config.json"
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create default config if it doesn't exist
                config := createDefaultConfig()
                return config, nil
        }</span>

        // Read config file
        <span class="cov0" title="0">data, err := ioutil.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Parse config
        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// createDefaultConfig creates a default configuration
func createDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                AppName:     "KolajAI",
                Environment: "development",
                Server: ServerConfig{
                        Host:         "localhost",
                        Port:         8080,
                        ReadTimeout:  60,
                        WriteTimeout: 60,
                        IdleTimeout:  120,
                        Debug:        true,
                        Prefork:      false,
                        BaseURL:      "http://localhost:8080",
                },
                Database: DatabaseConfig{
                        Driver:          "mysql",
                        Host:            "localhost",
                        Port:            3306,
                        Username:        "root",
                        Password:        "",
                        Database:        "kolajai",
                        MaxOpenConns:    25,
                        MaxIdleConns:    25,
                        ConnMaxLifetime: 5 * time.Minute,
                        Charset:         "utf8mb4",
                        ParseTime:       true,
                },
                Template: TemplateConfig{
                        Dir:           "web/templates",
                        PartialsDir:   "web/templates/partials",
                        ComponentsDir: "web/templates/components",
                        Extension:     ".gohtml",
                        BaseLayout:    "layout",
                        Cache:         true,
                },
                Email: EmailConfig{
                        Host:     "smtp.example.com",
                        Port:     587,
                        Username: "user@example.com",
                        Password: "password",
                        From:     "noreply@example.com",
                        FromName: "KolajAI",
                        TLS:      true,
                },
                Notification: NotificationConfig{
                        DefaultType: "info",
                        DefaultTTL:  5 * time.Second,
                        Timeout:     5000,
                        Position:    "top-right",
                        ShowClose:   true,
                        AutoClose:   true,
                        Types:       GetDefaultNotificationTypes(),
                },
                Routes: RoutesConfig{
                        API: struct {
                                Prefix     string   `json:"prefix"`
                                Version    string   `json:"version"`
                                Middleware []string `json:"middleware"`
                        }{
                                Prefix:  "/api",
                                Version: "v1",
                                Middleware: []string{
                                        "cors",
                                        "auth",
                                        "logger",
                                },
                        },
                        Web: struct {
                                Middleware []string `json:"middleware"`
                        }{
                                Middleware: []string{
                                        "session",
                                        "csrf",
                                        "logger",
                                },
                        },
                        Assets: struct {
                                Path   string `json:"path"`
                                Prefix string `json:"prefix"`
                        }{
                                Path:   "web/static",
                                Prefix: "/static",
                        },
                },
                Auth: AuthConfig{
                        JWTSecret:            "secret",
                        JWTExpiration:        24 * time.Hour,
                        RefreshTokenDuration: 7 * 24 * time.Hour,
                        PasswordMinLength:    8,
                        RequireUppercase:     true,
                        RequireSpecialChar:   true,
                        RequireNumber:        true,
                        MaxLoginAttempts:     5,
                        LockoutDuration:      15 * time.Minute,
                },
                Logger: LoggerConfig{
                        Level:      "debug",
                        File:       "logs/app.log",
                        MaxSize:    10,
                        MaxBackups: 5,
                        MaxAge:     30,
                        Compress:   true,
                },
        }
}</span>

// LoadConfig loads the application configuration from a file
func LoadConfig(path string) (*Config, error) <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file not found: %s", path)
        }</span>

        // Read config file
        <span class="cov0" title="0">data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Parse config
        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// SaveConfig saves the configuration to a file
func SaveConfig(config *Config, path string) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Marshal config to JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write to file
        <span class="cov0" title="0">if err := ioutil.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetServerConfig returns the server configuration
func GetServerConfig() (ServerConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return ServerConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Server, true</span>
}

// GetDatabaseConfig returns the database configuration
func GetDatabaseConfig() (DatabaseConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return DatabaseConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Database, true</span>
}

// GetTemplateConfig returns the template configuration
func GetTemplateConfig() (TemplateConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return TemplateConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Template, true</span>
}

// GetEmailConfig returns the email configuration
func GetEmailConfig() (EmailConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return EmailConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Email, true</span>
}

// GetNotificationConfig returns the notification configuration
func GetNotificationConfig() (NotificationConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return NotificationConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Notification, true</span>
}

// GetRoutesConfig returns the routes configuration
func GetRoutesConfig() (RoutesConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return RoutesConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Routes, true</span>
}

// GetAuthConfig returns the authentication configuration
func GetAuthConfig() (AuthConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return AuthConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Auth, true</span>
}

// GetLoggerConfig returns the logger configuration
func GetLoggerConfig() (LoggerConfig, bool) <span class="cov0" title="0">{
        config, err := GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get config: %v", err)
                return LoggerConfig{}, false
        }</span>
        <span class="cov0" title="0">return config.Logger, true</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "strings"
        "time"
)

// LegacyColumnConfig holds column configuration (for backward compatibility)
type LegacyColumnConfig struct {
        Name       string
        Type       string
        IsPrimary  bool
        IsAutoIncr bool
        IsUnique   bool
        NotNull    bool
        Default    interface{}
}

// LegacyRelationshipConfig holds relationship configuration (for backward compatibility)
type LegacyRelationshipConfig struct {
        Type         string
        TargetTable  string
        ForeignField string
        ThroughTable string
}

// LegacyIndexConfig holds index configuration (for backward compatibility)
type LegacyIndexConfig struct {
        Name    string
        Columns []string
        Type    string
}

// LegacyTableConfig holds table configuration (for backward compatibility)
type LegacyTableConfig struct {
        Name          string
        PrimaryKey    string
        Columns       map[string]*LegacyColumnConfig
        Relationships map[string]*LegacyRelationshipConfig
        Indexes       []*LegacyIndexConfig
}

// LegacyDatabaseConfig holds database configuration (for backward compatibility)
type LegacyDatabaseConfig struct {
        Host            string
        Port            int
        Username        string
        Password        string
        Database        string
        Charset         string
        ParseTime       bool
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        Tables          map[string]*LegacyTableConfig
}

// NewLegacyDatabaseConfig creates a new database configuration
func NewLegacyDatabaseConfig() *LegacyDatabaseConfig <span class="cov0" title="0">{
        return &amp;LegacyDatabaseConfig{
                Host:            "localhost",
                Port:            3306,
                Username:        "root",
                Password:        "",
                Database:        "kolajai",
                Charset:         "utf8mb4",
                ParseTime:       true,
                MaxOpenConns:    25,
                MaxIdleConns:    25,
                ConnMaxLifetime: 5 * time.Minute,
                Tables:          make(map[string]*LegacyTableConfig),
        }
}</span>

// GetDSN returns the database connection string
func (c *LegacyDatabaseConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=%s&amp;parseTime=%v",
                c.Username,
                c.Password,
                c.Host,
                c.Port,
                c.Database,
                c.Charset,
                c.ParseTime,
        )
}</span>

// AddTable adds a table configuration
func (c *LegacyDatabaseConfig) AddTable(name string, config LegacyTableConfig) <span class="cov0" title="0">{
        c.Tables[name] = &amp;config
}</span>

// GetTable returns a table configuration
func (c *LegacyDatabaseConfig) GetTable(name string) (LegacyTableConfig, bool) <span class="cov0" title="0">{
        config, exists := c.Tables[name]
        return *config, exists
}</span>

// GetColumnList returns a list of column names for a table
func (c *LegacyDatabaseConfig) GetColumnList(tableName string) []string <span class="cov0" title="0">{
        if table, exists := c.Tables[tableName]; exists </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(table.Columns))
                for colName := range table.Columns </span><span class="cov0" title="0">{
                        columns = append(columns, colName)
                }</span>
                <span class="cov0" title="0">return columns</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRelationConfig returns the relationship configuration for a table and relation
func (c *LegacyDatabaseConfig) GetRelationConfig(tableName, relationName string) (*LegacyRelationshipConfig, bool) <span class="cov0" title="0">{
        if table, exists := c.Tables[tableName]; exists </span><span class="cov0" title="0">{
                if relation, exists := table.Relationships[relationName]; exists </span><span class="cov0" title="0">{
                        return relation, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// InitializeTables initializes table configurations
func (c *LegacyDatabaseConfig) InitializeTables() <span class="cov0" title="0">{
        // Users table
        c.Tables["users"] = &amp;LegacyTableConfig{
                Name:       "users",
                PrimaryKey: "id",
                Columns: map[string]*LegacyColumnConfig{
                        "id": {
                                Name:       "id",
                                Type:       "INT",
                                IsPrimary:  true,
                                IsAutoIncr: true,
                        },
                        "username": {
                                Name:     "username",
                                Type:     "VARCHAR(255)",
                                IsUnique: true,
                        },
                        "email": {
                                Name:     "email",
                                Type:     "VARCHAR(255)",
                                IsUnique: true,
                        },
                        "password": {
                                Name: "password",
                                Type: "VARCHAR(255)",
                        },
                        "active": {
                                Name:    "active",
                                Type:    "BOOLEAN",
                                Default: true,
                        },
                        "role": {
                                Name:    "role",
                                Type:    "VARCHAR(50)",
                                Default: "user",
                        },
                        "created_at": {
                                Name:    "created_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP",
                        },
                        "updated_at": {
                                Name:    "updated_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
                        },
                },
                Relationships: map[string]*LegacyRelationshipConfig{
                        "posts": {
                                Type:         "has_many",
                                TargetTable:  "posts",
                                ForeignField: "user_id",
                        },
                        "profile": {
                                Type:         "has_one",
                                TargetTable:  "profiles",
                                ForeignField: "user_id",
                        },
                },
                Indexes: []*LegacyIndexConfig{
                        {
                                Name:    "idx_users_username",
                                Columns: []string{"username"},
                                Type:    "UNIQUE",
                        },
                        {
                                Name:    "idx_users_email",
                                Columns: []string{"email"},
                                Type:    "UNIQUE",
                        },
                },
        }

        // Posts table
        c.Tables["posts"] = &amp;LegacyTableConfig{
                Name:       "posts",
                PrimaryKey: "id",
                Columns: map[string]*LegacyColumnConfig{
                        "id": {
                                Name:       "id",
                                Type:       "INT",
                                IsPrimary:  true,
                                IsAutoIncr: true,
                        },
                        "user_id": {
                                Name: "user_id",
                                Type: "INT",
                        },
                        "title": {
                                Name: "title",
                                Type: "VARCHAR(255)",
                        },
                        "content": {
                                Name: "content",
                                Type: "TEXT",
                        },
                        "status": {
                                Name:    "status",
                                Type:    "VARCHAR(50)",
                                Default: "draft",
                        },
                        "created_at": {
                                Name:    "created_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP",
                        },
                        "updated_at": {
                                Name:    "updated_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
                        },
                },
                Relationships: map[string]*LegacyRelationshipConfig{
                        "user": {
                                Type:         "belongs_to",
                                TargetTable:  "users",
                                ForeignField: "user_id",
                        },
                        "comments": {
                                Type:         "has_many",
                                TargetTable:  "comments",
                                ForeignField: "post_id",
                        },
                        "categories": {
                                Type:         "belongs_to_many",
                                TargetTable:  "categories",
                                ThroughTable: "post_categories",
                                ForeignField: "post_id",
                        },
                },
                Indexes: []*LegacyIndexConfig{
                        {
                                Name:    "idx_posts_user_id",
                                Columns: []string{"user_id"},
                                Type:    "INDEX",
                        },
                        {
                                Name:    "idx_posts_status",
                                Columns: []string{"status"},
                                Type:    "INDEX",
                        },
                },
        }

        // Comments table
        c.Tables["comments"] = &amp;LegacyTableConfig{
                Name:       "comments",
                PrimaryKey: "id",
                Columns: map[string]*LegacyColumnConfig{
                        "id": {
                                Name:       "id",
                                Type:       "INT",
                                IsPrimary:  true,
                                IsAutoIncr: true,
                        },
                        "post_id": {
                                Name: "post_id",
                                Type: "INT",
                        },
                        "user_id": {
                                Name: "user_id",
                                Type: "INT",
                        },
                        "content": {
                                Name: "content",
                                Type: "TEXT",
                        },
                        "status": {
                                Name:    "status",
                                Type:    "VARCHAR(50)",
                                Default: "pending",
                        },
                        "created_at": {
                                Name:    "created_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP",
                        },
                        "updated_at": {
                                Name:    "updated_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
                        },
                },
                Relationships: map[string]*LegacyRelationshipConfig{
                        "post": {
                                Type:         "belongs_to",
                                TargetTable:  "posts",
                                ForeignField: "post_id",
                        },
                        "user": {
                                Type:         "belongs_to",
                                TargetTable:  "users",
                                ForeignField: "user_id",
                        },
                },
                Indexes: []*LegacyIndexConfig{
                        {
                                Name:    "idx_comments_post_id",
                                Columns: []string{"post_id"},
                                Type:    "INDEX",
                        },
                        {
                                Name:    "idx_comments_user_id",
                                Columns: []string{"user_id"},
                                Type:    "INDEX",
                        },
                },
        }

        // Categories table
        c.Tables["categories"] = &amp;LegacyTableConfig{
                Name:       "categories",
                PrimaryKey: "id",
                Columns: map[string]*LegacyColumnConfig{
                        "id": {
                                Name:       "id",
                                Type:       "INT",
                                IsPrimary:  true,
                                IsAutoIncr: true,
                        },
                        "name": {
                                Name: "name",
                                Type: "VARCHAR(255)",
                        },
                        "slug": {
                                Name: "slug",
                                Type: "VARCHAR(255)",
                        },
                        "description": {
                                Name: "description",
                                Type: "TEXT",
                        },
                        "parent_id": {
                                Name: "parent_id",
                                Type: "INT",
                        },
                        "created_at": {
                                Name:    "created_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP",
                        },
                        "updated_at": {
                                Name:    "updated_at",
                                Type:    "TIMESTAMP",
                                Default: "CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP",
                        },
                },
                Relationships: map[string]*LegacyRelationshipConfig{
                        "parent": {
                                Type:         "belongs_to",
                                TargetTable:  "categories",
                                ForeignField: "parent_id",
                        },
                        "children": {
                                Type:         "has_many",
                                TargetTable:  "categories",
                                ForeignField: "parent_id",
                        },
                        "posts": {
                                Type:         "belongs_to_many",
                                TargetTable:  "posts",
                                ThroughTable: "post_categories",
                                ForeignField: "category_id",
                        },
                },
                Indexes: []*LegacyIndexConfig{
                        {
                                Name:    "idx_categories_slug",
                                Columns: []string{"slug"},
                                Type:    "UNIQUE",
                        },
                        {
                                Name:    "idx_categories_parent_id",
                                Columns: []string{"parent_id"},
                                Type:    "INDEX",
                        },
                },
        }
}</span>

// GetExtendedDatabaseConfig extends the base DatabaseConfig with default values
func GetExtendedDatabaseConfig() (DatabaseConfigExtended, bool) <span class="cov0" title="0">{
        baseConfig, ok := GetDatabaseConfig()
        if !ok </span><span class="cov0" title="0">{
                return DatabaseConfigExtended{}, false
        }</span>

        // Extend with additional fields
        <span class="cov0" title="0">extended := DatabaseConfigExtended{
                Driver:          baseConfig.Driver,
                Host:            baseConfig.Host,
                Port:            baseConfig.Port,
                Username:        baseConfig.Username,
                Password:        baseConfig.Password,
                Database:        baseConfig.Database,
                MaxOpenConns:    baseConfig.MaxOpenConns,
                MaxIdleConns:    baseConfig.MaxIdleConns,
                ConnMaxLifetime: baseConfig.ConnMaxLifetime,
                Charset:         "utf8mb4",
                ParseTime:       true,
                Tables:          getDefaultTables(),
        }

        return extended, true</span>
}

// BuildConnectionString builds a MySQL connection string
func (c *DatabaseConfigExtended) BuildConnectionString() string <span class="cov0" title="0">{
        // Base DSN
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s", c.Username, c.Password, c.Host, c.Port, c.Database)

        // Add query parameters
        params := []string{}
        if c.Charset != "" </span><span class="cov0" title="0">{
                params = append(params, "charset="+c.Charset)
        }</span>
        <span class="cov0" title="0">if c.ParseTime </span><span class="cov0" title="0">{
                params = append(params, "parseTime=true")
        }</span>

        // Add more params as needed
        <span class="cov0" title="0">params = append(params, "loc=Local")

        // Join parameters
        if len(params) &gt; 0 </span><span class="cov0" title="0">{
                dsn += "?" + strings.Join(params, "&amp;")
        }</span>

        <span class="cov0" title="0">return dsn</span>
}

// BuildRootConnectionString builds a connection string without database name
func (c *DatabaseConfigExtended) BuildRootConnectionString() string <span class="cov0" title="0">{
        // Base DSN without database
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/", c.Username, c.Password, c.Host, c.Port)

        // Add query parameters
        params := []string{}
        if c.Charset != "" </span><span class="cov0" title="0">{
                params = append(params, "charset="+c.Charset)
        }</span>
        <span class="cov0" title="0">if c.ParseTime </span><span class="cov0" title="0">{
                params = append(params, "parseTime=true")
        }</span>

        // Add more params as needed
        <span class="cov0" title="0">params = append(params, "loc=Local")

        // Join parameters
        if len(params) &gt; 0 </span><span class="cov0" title="0">{
                dsn += "?" + strings.Join(params, "&amp;")
        }</span>

        <span class="cov0" title="0">return dsn</span>
}

// getDefaultTables returns the default tables configuration for new schema
func getDefaultTables() []TableConfig <span class="cov0" title="0">{
        return []TableConfig{
                {
                        Name: "users",
                        Columns: []struct {
                                Name       string `json:"name"`
                                Type       string `json:"type"`
                                PrimaryKey bool   `json:"primary_key,omitempty"`
                                Nullable   bool   `json:"nullable,omitempty"`
                                Default    string `json:"default,omitempty"`
                        }{
                                {Name: "id", Type: "int", PrimaryKey: true},
                                {Name: "name", Type: "varchar(100)"},
                                {Name: "email", Type: "varchar(100)"},
                                {Name: "password", Type: "varchar(255)"},
                                {Name: "is_admin", Type: "tinyint(1)", Default: "0"},
                                {Name: "created_at", Type: "timestamp", Default: "CURRENT_TIMESTAMP"},
                                {Name: "updated_at", Type: "timestamp", Nullable: true},
                        },
                        Indexes: []struct {
                                Name    string   `json:"name"`
                                Columns []string `json:"columns"`
                                Unique  bool     `json:"unique,omitempty"`
                        }{
                                {Name: "idx_users_email", Columns: []string{"email"}, Unique: true},
                        },
                },
                {
                        Name: "sessions",
                        Columns: []struct {
                                Name       string `json:"name"`
                                Type       string `json:"type"`
                                PrimaryKey bool   `json:"primary_key,omitempty"`
                                Nullable   bool   `json:"nullable,omitempty"`
                                Default    string `json:"default,omitempty"`
                        }{
                                {Name: "id", Type: "varchar(255)", PrimaryKey: true},
                                {Name: "user_id", Type: "int"},
                                {Name: "data", Type: "text"},
                                {Name: "created_at", Type: "timestamp", Default: "CURRENT_TIMESTAMP"},
                                {Name: "expires_at", Type: "timestamp"},
                        },
                        Indexes: []struct {
                                Name    string   `json:"name"`
                                Columns []string `json:"columns"`
                                Unique  bool     `json:"unique,omitempty"`
                        }{
                                {Name: "idx_sessions_user_id", Columns: []string{"user_id"}},
                        },
                },
                {
                        Name: "notifications",
                        Columns: []struct {
                                Name       string `json:"name"`
                                Type       string `json:"type"`
                                PrimaryKey bool   `json:"primary_key,omitempty"`
                                Nullable   bool   `json:"nullable,omitempty"`
                                Default    string `json:"default,omitempty"`
                        }{
                                {Name: "id", Type: "int", PrimaryKey: true},
                                {Name: "user_id", Type: "int"},
                                {Name: "type", Type: "varchar(50)"},
                                {Name: "title", Type: "varchar(255)"},
                                {Name: "message", Type: "text"},
                                {Name: "is_read", Type: "tinyint(1)", Default: "0"},
                                {Name: "created_at", Type: "timestamp", Default: "CURRENT_TIMESTAMP"},
                        },
                        Indexes: []struct {
                                Name    string   `json:"name"`
                                Columns []string `json:"columns"`
                                Unique  bool     `json:"unique,omitempty"`
                        }{
                                {Name: "idx_notifications_user_id", Columns: []string{"user_id"}},
                        },
                },
                {
                        Name: "posts",
                        Columns: []struct {
                                Name       string `json:"name"`
                                Type       string `json:"type"`
                                PrimaryKey bool   `json:"primary_key,omitempty"`
                                Nullable   bool   `json:"nullable,omitempty"`
                                Default    string `json:"default,omitempty"`
                        }{
                                {Name: "id", Type: "int", PrimaryKey: true},
                                {Name: "user_id", Type: "int"},
                                {Name: "title", Type: "varchar(255)"},
                                {Name: "content", Type: "text"},
                                {Name: "status", Type: "varchar(50)", Default: "'draft'"},
                                {Name: "created_at", Type: "timestamp", Default: "CURRENT_TIMESTAMP"},
                                {Name: "updated_at", Type: "timestamp", Nullable: true},
                        },
                        Indexes: []struct {
                                Name    string   `json:"name"`
                                Columns []string `json:"columns"`
                                Unique  bool     `json:"unique,omitempty"`
                        }{
                                {Name: "idx_posts_user_id", Columns: []string{"user_id"}},
                        },
                },
        }
}</span>

// DatabaseConfigExtended extends the base DatabaseConfig with additional fields
type DatabaseConfigExtended struct {
        Driver          string        `json:"driver"`
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        Username        string        `json:"username"`
        Password        string        `json:"password"`
        Database        string        `json:"database"`
        MaxOpenConns    int           `json:"max_open_conns"`
        MaxIdleConns    int           `json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
        Charset         string        `json:"charset"`
        ParseTime       bool          `json:"parse_time"`
        Tables          []TableConfig `json:"tables"`
}

// CreateTableSQL generates SQL to create a table
func (t *TableConfig) CreateTableSQL() string <span class="cov0" title="0">{
        sql := fmt.Sprintf("CREATE TABLE IF NOT EXISTS `%s` (\n", t.Name)

        // Add columns
        cols := []string{}
        for _, col := range t.Columns </span><span class="cov0" title="0">{
                colDef := fmt.Sprintf("  `%s` %s", col.Name, col.Type)

                if col.PrimaryKey </span><span class="cov0" title="0">{
                        colDef += " PRIMARY KEY AUTO_INCREMENT"
                }</span> else<span class="cov0" title="0"> {
                        if !col.Nullable </span><span class="cov0" title="0">{
                                colDef += " NOT NULL"
                        }</span> else<span class="cov0" title="0"> {
                                colDef += " NULL"
                        }</span>

                        <span class="cov0" title="0">if col.Default != "" </span><span class="cov0" title="0">{
                                colDef += " DEFAULT " + col.Default
                        }</span>
                }

                <span class="cov0" title="0">cols = append(cols, colDef)</span>
        }

        // Add indexes
        <span class="cov0" title="0">for _, idx := range t.Indexes </span><span class="cov0" title="0">{
                idxCols := []string{}
                for _, col := range idx.Columns </span><span class="cov0" title="0">{
                        idxCols = append(idxCols, "`"+col+"`")
                }</span>

                <span class="cov0" title="0">idxType := "INDEX"
                if idx.Unique </span><span class="cov0" title="0">{
                        idxType = "UNIQUE INDEX"
                }</span>

                <span class="cov0" title="0">cols = append(cols, fmt.Sprintf("  %s `%s` (%s)", idxType, idx.Name, strings.Join(idxCols, ", ")))</span>
        }

        <span class="cov0" title="0">sql += strings.Join(cols, ",\n")
        sql += "\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;"

        return sql</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

// NotificationType represents a notification type configuration
type NotificationType struct {
        Icon     string `json:"icon"`
        Color    string `json:"color"`
        Template string `json:"template"`
}

// UpdateNotificationConfig updates the NotificationConfig struct to include required fields
func UpdateNotificationConfig() {<span class="cov0" title="0">
        // Update the NotificationConfig struct in config.go to include these fields
        // This is just a placeholder function to document the changes needed
}</span>

// GetDefaultNotificationTypes returns default notification types
func GetDefaultNotificationTypes() map[string]NotificationType <span class="cov0" title="0">{
        return map[string]NotificationType{
                "info": {
                        Icon:     "info-circle",
                        Color:    "primary",
                        Template: "notifications/info",
                },
                "success": {
                        Icon:     "check-circle",
                        Color:    "success",
                        Template: "notifications/success",
                },
                "warning": {
                        Icon:     "exclamation-triangle",
                        Color:    "warning",
                        Template: "notifications/warning",
                },
                "error": {
                        Icon:     "exclamation-circle",
                        Color:    "danger",
                        Template: "notifications/error",
                },
        }
}</span>

// GetNotificationTypes returns configured notification types
func GetNotificationTypes() map[string]NotificationType <span class="cov0" title="0">{
        // In a real implementation, this would load from configuration
        return GetDefaultNotificationTypes()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import "net/http"

// RouteConfig represents a route configuration
type RouteConfig struct {
        Path     string        `json:"path"`
        Handler  string        `json:"handler"`
        Methods  []string      `json:"methods"`
        Template string        `json:"template"`
        Layout   string        `json:"layout,omitempty"`
        SEOMeta  SEOMetaConfig `json:"seo_meta"`
}

// SEOMetaConfig represents SEO metadata for a route
type SEOMetaConfig struct {
        Title       string   `json:"title"`
        Description string   `json:"description"`
        Keywords    []string `json:"keywords,omitempty"`
        Robots      string   `json:"robots,omitempty"`
}

// GetAuthRoutes returns the authentication routes configuration
func GetAuthRoutes() []RouteConfig <span class="cov0" title="0">{
        return []RouteConfig{
                {
                        Path:     "/login",
                        Handler:  "Login",
                        Methods:  []string{http.MethodGet, http.MethodPost},
                        Template: "auth/login",
                        Layout:   "auth",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Giriş Yap",
                                Description: "Hesabınıza giriş yapın",
                                Keywords:    []string{"giriş", "login", "hesap", "kullanıcı"},
                                Robots:      "noindex, nofollow",
                        },
                },
                {
                        Path:     "/register",
                        Handler:  "Register",
                        Methods:  []string{http.MethodGet, http.MethodPost},
                        Template: "auth/register",
                        Layout:   "auth",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Kayıt Ol",
                                Description: "Yeni bir hesap oluşturun",
                                Keywords:    []string{"kayıt", "register", "hesap", "kullanıcı"},
                                Robots:      "noindex, nofollow",
                        },
                },
                {
                        Path:     "/forgot-password",
                        Handler:  "ForgotPassword",
                        Methods:  []string{http.MethodGet, http.MethodPost},
                        Template: "auth/forgot-password",
                        Layout:   "auth",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Şifremi Unuttum",
                                Description: "Şifrenizi sıfırlayın",
                                Keywords:    []string{"şifre", "unuttum", "sıfırlama"},
                                Robots:      "noindex, nofollow",
                        },
                },
                {
                        Path:     "/reset-password",
                        Handler:  "ResetPassword",
                        Methods:  []string{http.MethodGet, http.MethodPost},
                        Template: "auth/reset-password",
                        Layout:   "auth",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Şifre Sıfırlama",
                                Description: "Yeni şifrenizi belirleyin",
                                Keywords:    []string{"şifre", "sıfırlama", "yeni şifre"},
                                Robots:      "noindex, nofollow",
                        },
                },
        }
}</span>

// GetMainRoutes returns the main routes configuration
func GetMainRoutes() []RouteConfig <span class="cov0" title="0">{
        return []RouteConfig{
                {
                        Path:     "/",
                        Handler:  "Index",
                        Methods:  []string{http.MethodGet},
                        Template: "index",
                        Layout:   "main",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Ana Sayfa",
                                Description: "KolajAI'ya Hoş Geldiniz",
                                Keywords:    []string{"anasayfa", "kolajAI", "yapay zeka"},
                        },
                },
                {
                        Path:     "/dashboard",
                        Handler:  "Dashboard",
                        Methods:  []string{http.MethodGet},
                        Template: "dashboard",
                        Layout:   "main",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Kontrol Paneli",
                                Description: "Kullanıcı kontrol paneli",
                                Keywords:    []string{"dashboard", "panel", "kontrol"},
                        },
                },
                {
                        Path:     "/settings",
                        Handler:  "Settings",
                        Methods:  []string{http.MethodGet, http.MethodPost},
                        Template: "settings",
                        Layout:   "main",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Ayarlar",
                                Description: "Hesap ayarlarınızı yönetin",
                                Keywords:    []string{"ayarlar", "hesap", "profil"},
                        },
                },
                {
                        Path:     "/components",
                        Handler:  "ComponentsExample",
                        Methods:  []string{http.MethodGet},
                        Template: "components/example",
                        Layout:   "main",
                        SEOMeta: SEOMetaConfig{
                                Title:       "Bileşen Örnekleri",
                                Description: "Yeniden kullanılabilir UI bileşenleri örnekleri",
                                Keywords:    []string{"bileşenler", "components", "UI", "arayüz"},
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

// DatabaseTables defines all table names used in the application
// This ensures consistency in table naming across the application
type DatabaseTables struct {
        Users              string
        UserRoles          string
        UserPermissions    string
        Roles              string
        Permissions        string
        RolePermissions    string
        Sessions           string
        PasswordResets     string
        EmailVerifications string
        LoginAttempts      string
        AuditLogs          string
        UserSettings       string
        UserProfiles       string
        SentEmails         string
        Notifications      string
        Projects           string
        ProjectMembers     string
        ProjectAssets      string
        Documents          string
        DocumentVersions   string
        Templates          string
        TemplateCategories string
        Media              string
        Tags               string
        Comments           string
        Products           string
        Orders             string
        OrderItems         string
        Payments           string
        Subscriptions      string
        Invoices           string
        Settings           string
}

// NewDatabaseTables returns a new DatabaseTables with default table names
func NewDatabaseTables() DatabaseTables <span class="cov0" title="0">{
        return DatabaseTables{
                Users:              "users",
                UserRoles:          "user_roles",
                UserPermissions:    "user_permissions",
                Roles:              "roles",
                Permissions:        "permissions",
                RolePermissions:    "role_permissions",
                Sessions:           "sessions",
                PasswordResets:     "password_resets",
                EmailVerifications: "email_verifications",
                LoginAttempts:      "login_attempts",
                AuditLogs:          "audit_logs",
                UserSettings:       "user_settings",
                UserProfiles:       "user_profiles",
                SentEmails:         "sent_emails",
                Notifications:      "notifications",
                Projects:           "projects",
                ProjectMembers:     "project_members",
                ProjectAssets:      "project_assets",
                Documents:          "documents",
                DocumentVersions:   "document_versions",
                Templates:          "templates",
                TemplateCategories: "template_categories",
                Media:              "media",
                Tags:               "tags",
                Comments:           "comments",
                Products:           "products",
                Orders:             "orders",
                OrderItems:         "order_items",
                Payments:           "payments",
                Subscriptions:      "subscriptions",
                Invoices:           "invoices",
                Settings:           "settings",
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
)

// ErrorCode represents a standardized error code
type ErrorCode string

// AppError standardizes application errors
type AppError struct {
        Code      ErrorCode
        Message   string
        UserMsg   string // User-friendly message
        Err       error  // Original error
        HTTPCode  int    // HTTP response code
        LogLevel  LogLevel
        RequestID string
}

// LogLevel indicates how an error should be logged
type LogLevel int

const (
        // Error codes
        ErrInternal     ErrorCode = "INTERNAL_ERROR"
        ErrValidation   ErrorCode = "VALIDATION_ERROR"
        ErrAuth         ErrorCode = "AUTH_ERROR"
        ErrNotFound     ErrorCode = "NOT_FOUND"
        ErrDatabase     ErrorCode = "DATABASE_ERROR"
        ErrFormParse    ErrorCode = "FORM_PARSE_ERROR"
        ErrUnauthorized ErrorCode = "UNAUTHORIZED"
        ErrForbidden    ErrorCode = "FORBIDDEN"
        ErrBadRequest   ErrorCode = "BAD_REQUEST"

        // Log levels
        LogSilent LogLevel = iota
        LogError
        LogWarn
        LogInfo
        LogDebug
)

// Error returns the error string
func (e *AppError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s (%s)", e.Code, e.Message, e.Err.Error())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// Unwrap returns the original error
func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// WithRequestID adds a request ID to the error
func (e *AppError) WithRequestID(id string) *AppError <span class="cov0" title="0">{
        e.RequestID = id
        return e
}</span>

// WithHTTPCode sets the HTTP response code
func (e *AppError) WithHTTPCode(code int) *AppError <span class="cov0" title="0">{
        e.HTTPCode = code
        return e
}</span>

// WithLogLevel sets the log level
func (e *AppError) WithLogLevel(level LogLevel) *AppError <span class="cov0" title="0">{
        e.LogLevel = level
        return e
}</span>

// Log logs the error according to its log level
func (e *AppError) Log() <span class="cov0" title="0">{
        switch e.LogLevel </span>{
        case LogDebug:<span class="cov0" title="0">
                log.Printf("[DEBUG] [%s] %s", e.Code, e.Error())</span>
        case LogInfo:<span class="cov0" title="0">
                log.Printf("[INFO] [%s] %s", e.Code, e.Error())</span>
        case LogWarn:<span class="cov0" title="0">
                log.Printf("[WARN] [%s] %s", e.Code, e.Error())</span>
        case LogError:<span class="cov0" title="0">
                log.Printf("[ERROR] [%s] %s", e.Code, e.Error())</span>
        }
}

// RespondWithError sends a JSON error response
func RespondWithError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        var appErr *AppError
        var httpCode int
        var userMsg string

        // Convert to AppError if not already
        if e, ok := err.(*AppError); ok </span><span class="cov0" title="0">{
                appErr = e
                httpCode = e.HTTPCode
                userMsg = e.UserMsg
                appErr.Log()
        }</span> else<span class="cov0" title="0"> {
                // Create a generic error
                appErr = NewError(ErrInternal, "Bir hata oluştu", err).
                        WithHTTPCode(http.StatusInternalServerError).
                        WithLogLevel(LogError)
                httpCode = http.StatusInternalServerError
                userMsg = "Bir hata oluştu, lütfen daha sonra tekrar deneyin."
                appErr.Log()
        }</span>

        // Default HTTP code if not set
        <span class="cov0" title="0">if httpCode == 0 </span><span class="cov0" title="0">{
                httpCode = http.StatusInternalServerError
        }</span>

        // Create response
        <span class="cov0" title="0">response := map[string]interface{}{
                "success": false,
                "error": map[string]interface{}{
                        "code":    appErr.Code,
                        "message": userMsg,
                },
        }

        // Add request ID if available
        if appErr.RequestID != "" </span><span class="cov0" title="0">{
                response["request_id"] = appErr.RequestID
        }</span>

        // Send JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(httpCode)
        json.NewEncoder(w).Encode(response)</span>
}

// NewError creates a new AppError
func NewError(code ErrorCode, message string, err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     code,
                Message:  message,
                UserMsg:  message, // Default user message to the same
                Err:      err,
                LogLevel: LogError,
        }
}</span>

// NewValidationError creates a validation error
func NewValidationError(message string, validationErrors map[string][]string) *AppError <span class="cov0" title="0">{
        data, _ := json.Marshal(validationErrors)
        err := fmt.Errorf("validation errors: %s", string(data))

        return &amp;AppError{
                Code:     ErrValidation,
                Message:  message,
                UserMsg:  message,
                Err:      err,
                HTTPCode: http.StatusBadRequest,
                LogLevel: LogWarn,
        }
}</span>

// NewDatabaseError creates a database error
func NewDatabaseError(message string, err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     ErrDatabase,
                Message:  message,
                UserMsg:  "Veritabanı işlemi sırasında bir hata oluştu",
                Err:      err,
                HTTPCode: http.StatusInternalServerError,
                LogLevel: LogError,
        }
}</span>

// NewAuthError creates an authentication error
func NewAuthError(message string, err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     ErrAuth,
                Message:  message,
                UserMsg:  message,
                Err:      err,
                HTTPCode: http.StatusUnauthorized,
                LogLevel: LogWarn,
        }
}</span>

// NewNotFoundError creates a not found error
func NewNotFoundError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     ErrNotFound,
                Message:  message,
                UserMsg:  message,
                HTTPCode: http.StatusNotFound,
                LogLevel: LogInfo,
        }
}</span>

// NewBadRequestError creates a bad request error
func NewBadRequestError(message string, err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     ErrBadRequest,
                Message:  message,
                UserMsg:  message,
                Err:      err,
                HTTPCode: http.StatusBadRequest,
                LogLevel: LogWarn,
        }
}</span>

// NewFormParseError creates a form parsing error
func NewFormParseError(err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:     ErrFormParse,
                Message:  "Form verileri işlenemedi",
                UserMsg:  "Form verileri işlenemedi, lütfen tekrar deneyin",
                Err:      err,
                HTTPCode: http.StatusBadRequest,
                LogLevel: LogWarn,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package database

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "time"
)

// AuditLog represents a database audit log entry
type AuditLog struct {
        TableName string                 `json:"table_name"`
        RecordID  interface{}            `json:"record_id"`
        Action    string                 `json:"action"`
        OldValues map[string]interface{} `json:"old_values,omitempty"`
        NewValues map[string]interface{} `json:"new_values,omitempty"`
        UserID    interface{}            `json:"user_id,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        IPAddress string                 `json:"ip_address,omitempty"`
        UserAgent string                 `json:"user_agent,omitempty"`
}

// QueryLogger represents a query logger
type QueryLogger struct {
        logger *log.Logger
}

// NewQueryLogger creates a new query logger
func NewQueryLogger(logger *log.Logger) *QueryLogger <span class="cov0" title="0">{
        return &amp;QueryLogger{logger: logger}
}</span>

// LogQuery logs a database query
func (l *QueryLogger) LogQuery(query string, args []interface{}, duration time.Duration) <span class="cov0" title="0">{
        l.logger.Printf("Query: %s\nArgs: %v\nDuration: %v", query, args, duration)
}</span>

// LogError logs a database error
func (l *QueryLogger) LogError(err error, query string, args []interface{}) <span class="cov0" title="0">{
        l.logger.Printf("Error: %v\nQuery: %s\nArgs: %v", err, query, args)
}</span>

// AuditLogger represents an audit logger
type AuditLogger struct {
        logger *log.Logger
}

// NewAuditLogger creates a new audit logger
func NewAuditLogger(logger *log.Logger) *AuditLogger <span class="cov0" title="0">{
        return &amp;AuditLogger{logger: logger}
}</span>

// LogAudit logs an audit entry
func (l *AuditLogger) LogAudit(log *AuditLog) error <span class="cov0" title="0">{
        data, err := json.Marshal(log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling audit log: %v", err)
        }</span>

        <span class="cov0" title="0">l.logger.Printf("Audit: %s", string(data))
        return nil</span>
}

// AuditRepository represents a repository with audit logging
type AuditRepository struct {
        repo        Repository
        auditLogger *AuditLogger
        queryLogger *QueryLogger
}

// NewAuditRepository creates a new audit repository
func NewAuditRepository(repo Repository, auditLogger *AuditLogger, queryLogger *QueryLogger) *AuditRepository <span class="cov0" title="0">{
        return &amp;AuditRepository{
                repo:        repo,
                auditLogger: auditLogger,
                queryLogger: queryLogger,
        }
}</span>

// Create creates a record with audit logging
func (r *AuditRepository) Create(table string, fields []string, values []interface{}) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        id, err := r.repo.Create(table, fields, values)
        duration := time.Since(start)

        r.queryLogger.LogQuery("CREATE", []interface{}{table, fields, values}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "CREATE", []interface{}{table, fields, values})
                return 0, err
        }</span>

        // Create a map from fields and values for audit logging
        <span class="cov0" title="0">newValues := make(map[string]interface{})
        for i, field := range fields </span><span class="cov0" title="0">{
                if i &lt; len(values) </span><span class="cov0" title="0">{
                        newValues[field] = values[i]
                }</span>
        }

        <span class="cov0" title="0">auditLog := &amp;AuditLog{
                TableName: table,
                RecordID:  id,
                Action:    "CREATE",
                NewValues: newValues,
                Timestamp: time.Now(),
        }

        if err := r.auditLogger.LogAudit(auditLog); err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "AUDIT_CREATE", []interface{}{auditLog})
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// Update updates a record with audit logging
func (r *AuditRepository) Update(table string, id interface{}, data interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.Update(table, id, data)
        duration := time.Since(start)

        r.queryLogger.LogQuery("UPDATE", []interface{}{table, id, data}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "UPDATE", []interface{}{table, id, data})
                return err
        }</span>

        <span class="cov0" title="0">auditLog := &amp;AuditLog{
                TableName: table,
                RecordID:  id,
                Action:    "UPDATE",
                NewValues: data.(map[string]interface{}),
                Timestamp: time.Now(),
        }

        if err := r.auditLogger.LogAudit(auditLog); err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "AUDIT_UPDATE", []interface{}{auditLog})
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a record with audit logging
func (r *AuditRepository) Delete(table string, id interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.Delete(table, id)
        duration := time.Since(start)

        r.queryLogger.LogQuery("DELETE", []interface{}{table, id}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "DELETE", []interface{}{table, id})
                return err
        }</span>

        <span class="cov0" title="0">auditLog := &amp;AuditLog{
                TableName: table,
                RecordID:  id,
                Action:    "DELETE",
                Timestamp: time.Now(),
        }

        if err := r.auditLogger.LogAudit(auditLog); err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "AUDIT_DELETE", []interface{}{auditLog})
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindByID finds a record by ID with audit logging
func (r *AuditRepository) FindByID(table string, id interface{}, result interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.FindByID(table, id, result)
        duration := time.Since(start)

        r.queryLogger.LogQuery("FIND_BY_ID", []interface{}{table, id}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "FIND_BY_ID", []interface{}{table, id})
        }</span>

        <span class="cov0" title="0">return err</span>
}

// FindAll finds all records with audit logging
func (r *AuditRepository) FindAll(table string, result interface{}, conditions map[string]interface{}, orderBy string, limit, offset int) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.FindAll(table, result, conditions, orderBy, limit, offset)
        duration := time.Since(start)

        r.queryLogger.LogQuery("FIND_ALL", []interface{}{table, conditions, orderBy, limit, offset}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "FIND_ALL", []interface{}{table, conditions, orderBy, limit, offset})
        }</span>

        <span class="cov0" title="0">return err</span>
}

// FindOne finds a single record with audit logging
func (r *AuditRepository) FindOne(table string, result interface{}, conditions map[string]interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.FindOne(table, result, conditions)
        duration := time.Since(start)

        r.queryLogger.LogQuery("FIND_ONE", []interface{}{table, conditions}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "FIND_ONE", []interface{}{table, conditions})
        }</span>

        <span class="cov0" title="0">return err</span>
}

// Count returns the number of records with audit logging
func (r *AuditRepository) Count(table string, conditions map[string]interface{}) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        count, err := r.repo.Count(table, conditions)
        duration := time.Since(start)

        r.queryLogger.LogQuery("COUNT", []interface{}{table, conditions}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "COUNT", []interface{}{table, conditions})
        }</span>

        <span class="cov0" title="0">return count, err</span>
}

// Search searches records with audit logging
func (r *AuditRepository) Search(table string, fields []string, term string, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.Search(table, fields, term, limit, offset, result)
        duration := time.Since(start)

        r.queryLogger.LogQuery("SEARCH", []interface{}{table, fields, term, limit, offset}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "SEARCH", []interface{}{table, fields, term, limit, offset})
        }</span>

        <span class="cov0" title="0">return err</span>
}

// FindByDateRange finds records within a date range with audit logging
func (r *AuditRepository) FindByDateRange(table, dateField string, startTime, endTime time.Time, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.FindByDateRange(table, dateField, startTime, endTime, limit, offset, result)
        duration := time.Since(start)

        r.queryLogger.LogQuery("FIND_BY_DATE_RANGE", []interface{}{table, dateField, startTime, endTime, limit, offset}, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "FIND_BY_DATE_RANGE", []interface{}{table, dateField, startTime, endTime, limit, offset})
        }</span>

        <span class="cov0" title="0">return err</span>
}

// Transaction executes a function within a transaction with audit logging
func (r *AuditRepository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        start := time.Now()
        err := r.repo.Transaction(fn)
        duration := time.Since(start)

        r.queryLogger.LogQuery("TRANSACTION", nil, duration)

        if err != nil </span><span class="cov0" title="0">{
                r.queryLogger.LogError(err, "TRANSACTION", nil)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// ... implement other Repository interface methods ...
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/patrickmn/go-cache"
)

// CacheRepository is a repository that caches database operations
type CacheRepository struct {
        repo  Repository
        cache *cache.Cache
        stats struct {
                hits   int64
                misses int64
                items  int64
        }
}

// NewCacheRepository creates a new cache repository
func NewCacheRepository(repo Repository, defaultExpiration, cleanupInterval time.Duration) *CacheRepository <span class="cov0" title="0">{
        return &amp;CacheRepository{
                repo:  repo,
                cache: cache.New(defaultExpiration, cleanupInterval),
        }
}</span>

// Create creates a record and caches it
func (r *CacheRepository) Create(table string, fields []string, values []interface{}) (int64, error) <span class="cov0" title="0">{
        id, err := r.repo.Create(table, fields, values)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Cache the new record - create a map from fields and values
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%d", table, id)
        data := make(map[string]interface{})
        for i, field := range fields </span><span class="cov0" title="0">{
                if i &lt; len(values) </span><span class="cov0" title="0">{
                        data[field] = values[i]
                }</span>
        }
        <span class="cov0" title="0">if err := r.cacheRecord(cacheKey, data); err != nil </span><span class="cov0" title="0">{
                // Log cache error but don't fail the operation
                fmt.Printf("Cache error: %v\n", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// Update updates a record and refreshes its cache
func (r *CacheRepository) Update(table string, id interface{}, data interface{}) error <span class="cov0" title="0">{
        if err := r.repo.Update(table, id, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%v", table, id)
        if err := r.cacheRecord(cacheKey, data); err != nil </span><span class="cov0" title="0">{
                // Log cache error but don't fail the operation
                fmt.Printf("Cache error: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a record and removes it from cache
func (r *CacheRepository) Delete(table string, id interface{}) error <span class="cov0" title="0">{
        if err := r.repo.Delete(table, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove from cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%v", table, id)
        r.cache.Delete(cacheKey)

        return nil</span>
}

// FindByID finds a record by ID, using cache if available
func (r *CacheRepository) FindByID(table string, id interface{}, result interface{}) error <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s:%v", table, id)

        // Try to get from cache first
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                r.stats.hits++
                return json.Unmarshal(cached.([]byte), result)
        }</span>

        // If not in cache, get from database
        <span class="cov0" title="0">if err := r.repo.FindByID(table, id, result); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Cache the result
        <span class="cov0" title="0">if err := r.cacheRecord(cacheKey, result); err != nil </span><span class="cov0" title="0">{
                // Log cache error but don't fail the operation
                fmt.Printf("Cache error: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindAll finds all records with pagination
func (r *CacheRepository) FindAll(table string, result interface{}, conditions map[string]interface{}, orderBy string, limit, offset int) error <span class="cov0" title="0">{
        // For list operations, we don't use cache as the data might be stale
        return r.repo.FindAll(table, result, conditions, orderBy, limit, offset)
}</span>

// FindOne finds a single record
func (r *CacheRepository) FindOne(table string, result interface{}, conditions map[string]interface{}) error <span class="cov0" title="0">{
        // For find operations with conditions, we don't use cache
        return r.repo.FindOne(table, result, conditions)
}</span>

// Count returns the number of records
func (r *CacheRepository) Count(table string, conditions map[string]interface{}) (int64, error) <span class="cov0" title="0">{
        // For count operations, we don't use cache
        return r.repo.Count(table, conditions)
}</span>

// Search searches records
func (r *CacheRepository) Search(table string, fields []string, term string, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        // For search operations, we don't use cache
        return r.repo.Search(table, fields, term, limit, offset, result)
}</span>

// FindByDateRange finds records within a date range
func (r *CacheRepository) FindByDateRange(table, dateField string, start, end time.Time, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        // For date range queries, we don't use cache
        return r.repo.FindByDateRange(table, dateField, start, end, limit, offset, result)
}</span>

// Transaction executes a function within a transaction
func (r *CacheRepository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        return r.repo.Transaction(fn)
}</span>

// Helper functions

// cacheRecord caches a record
func (r *CacheRepository) cacheRecord(key string, data interface{}) error <span class="cov0" title="0">{
        bytes, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling data for cache: %v", err)
        }</span>

        <span class="cov0" title="0">r.cache.Set(key, bytes, cache.DefaultExpiration)
        r.stats.items++
        return nil</span>
}

// ClearCache clears the entire cache
func (r *CacheRepository) ClearCache() <span class="cov0" title="0">{
        r.cache.Flush()
}</span>

// DeleteCache deletes a specific cache entry
func (r *CacheRepository) DeleteCache(key string) <span class="cov0" title="0">{
        r.cache.Delete(key)
}</span>

// GetStats returns cache statistics
func (r *CacheRepository) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "items":  r.stats.items,
                "hits":   r.stats.hits,
                "misses": r.stats.misses,
        }
}</span>

// Get retrieves a value from cache or database
func (r *CacheRepository) Get(table string, id interface{}, result interface{}) error <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s:%v", table, id)
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                r.stats.hits++
                return json.Unmarshal(cached.([]byte), result)
        }</span>

        <span class="cov0" title="0">r.stats.misses++
        if err := r.repo.FindByID(table, id, result); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.cache.Set(cacheKey, data, cache.DefaultExpiration)
        r.stats.items++
        return nil</span>
}

// Set stores a value in cache and database
func (r *CacheRepository) Set(table string, id interface{}, value interface{}) (int64, error) <span class="cov0" title="0">{
        // This method needs to be refactored to use proper fields and values
        // For now, we'll return an error to indicate it needs implementation
        return 0, fmt.Errorf("Set method needs to be properly implemented with field/value mapping")
}</span>

// Flush clears the cache
func (r *CacheRepository) Flush() <span class="cov0" title="0">{
        r.cache.Flush()
        r.stats.items = 0
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "kolajAi/internal/config"
        "log"
        "os"
        "time"

        _ "github.com/go-sql-driver/mysql"
        _ "github.com/mattn/go-sqlite3"
)

var DB *sql.DB

// Tx represents a database transaction
type Tx struct {
        *sql.Tx
}

// Config represents database configuration
type Config struct {
        Host         string
        Port         int
        User         string
        Password     string
        DatabaseName string
        MaxOpenConns int
        MaxIdleConns int
        MaxLifetime  time.Duration
}

// DefaultConfig returns a default database configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        // Önce yapılandırma dosyasından veritabanı ayarlarını almaya çalış
        dbConfig := &amp;Config{
                Host:         "localhost",
                Port:         3306,
                User:         "root",
                Password:     "",
                DatabaseName: "kolajdb",
                MaxOpenConns: 10,
                MaxIdleConns: 5,
                MaxLifetime:  time.Minute * 3,
        }

        // Yapılandırma dosyasından ayarları al
        appConfig, err := config.GetConfig()
        if err == nil &amp;&amp; appConfig != nil </span><span class="cov0" title="0">{
                // Yapılandırma dosyasından veritabanı ayarlarını al
                dbConfig.Host = appConfig.Database.Host
                dbConfig.Port = appConfig.Database.Port
                dbConfig.User = appConfig.Database.Username
                dbConfig.Password = appConfig.Database.Password
                dbConfig.DatabaseName = appConfig.Database.Database
                dbConfig.MaxOpenConns = appConfig.Database.MaxOpenConns
                dbConfig.MaxIdleConns = appConfig.Database.MaxIdleConns
                dbConfig.MaxLifetime = appConfig.Database.ConnMaxLifetime

                log.Printf("Loaded database configuration from config file: %s:%d/%s",
                        dbConfig.Host, dbConfig.Port, dbConfig.DatabaseName)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Using default database configuration: %s:%d/%s",
                        dbConfig.Host, dbConfig.Port, dbConfig.DatabaseName)
        }</span>

        <span class="cov0" title="0">return dbConfig</span>
}

// BuildConnectionString builds a MySQL connection string from config
func (c *Config) BuildConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&amp;loc=Local",
                c.User, c.Password, c.Host, c.Port, c.DatabaseName)
}</span>

// BuildRootConnectionString builds a MySQL connection string without database name
func (c *Config) BuildRootConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s@tcp(%s:%d)/?parseTime=true&amp;loc=Local",
                c.User, c.Password, c.Host, c.Port)
}</span>

// NewConnection creates a new database connection using connection string
func NewConnection(connectionString string) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("mysql", connectionString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(10)
        db.SetConnMaxLifetime(time.Minute * 5)

        if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to the database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to database")
        return db, nil</span>
}

// NewSQLiteConnection creates a new SQLite database connection
func NewSQLiteConnection(dbPath string) (*sql.DB, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening SQLite database: %w", err)
        }</span>

        // Enable foreign keys for SQLite
        <span class="cov8" title="1">_, err = db.Exec("PRAGMA foreign_keys = ON")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error enabling foreign keys: %w", err)
        }</span>

        <span class="cov8" title="1">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to the SQLite database: %w", err)
        }</span>

        <span class="cov8" title="1">log.Println("Successfully connected to SQLite database")
        return db, nil</span>
}

// InitDB initializes the database connection
func InitDB(config *Config) (*sql.DB, error) <span class="cov0" title="0">{
        // Önce veritabanı oluşturulacak
        err := createDatabaseIfNotExists(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database: %w", err)
        }</span>

        // Veritabanına bağlan
        <span class="cov0" title="0">db, err := sql.Open("mysql", config.BuildConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(config.MaxOpenConns)
        db.SetMaxIdleConns(config.MaxIdleConns)
        db.SetConnMaxLifetime(config.MaxLifetime)

        if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to the database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to database")
        DB = db
        return db, nil</span>
}

// createDatabaseIfNotExists creates the database if it doesn't exist
func createDatabaseIfNotExists(config *Config) error <span class="cov0" title="0">{
        // Önce varsayılan bağlantıyla MySQL'e bağlan (veritabanı adı olmadan)
        rootConn, err := sql.Open("mysql", config.BuildRootConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open root database connection: %w", err)
        }</span>
        <span class="cov0" title="0">defer rootConn.Close()

        // Veritabanı varlığını kontrol et
        rows, err := rootConn.Query("SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = ?", config.DatabaseName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check database existence: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Veritabanı yoksa oluştur
        dbExists := rows.Next()
        if !dbExists </span><span class="cov0" title="0">{
                log.Printf("Database '%s' does not exist, creating it...", config.DatabaseName)
                _, err = rootConn.Exec("CREATE DATABASE " + config.DatabaseName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create database: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("Database '%s' created successfully", config.DatabaseName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SetupDatabase initializes database tables
func SetupDatabase(db *sql.DB) error <span class="cov0" title="0">{
        // Migrasyon yöneticisi oluştur
        migrator, err := NewMigrator(db)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrator: %w", err)
        }</span>

        // Core migrasyonları uygula
        <span class="cov0" title="0">err = migrator.ApplyCoreMigrations()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply migrations: %w", err)
        }</span>

        // Seed verileri oluştur
        <span class="cov0" title="0">log.Printf("Applying database seeds...")

        // Default admin kullanıcısı oluştur
        err = CreateDefaultAdminUser(db)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to create default admin user: %v", err)
                // Devam et, kritik bir hata değil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DatabaseExists checks if a database file exists
func DatabaseExists(dbPath string) bool <span class="cov8" title="1">{
        _, err := os.Stat(dbPath)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "reflect"
        "strings"
        "time"
)

// DatabaseError represents a database error
type DatabaseError struct {
        Code    string
        Message string
        Err     error
}

func (e *DatabaseError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s (%v)", e.Code, e.Message, e.Err)
}</span>

// Repository interface for database operations
type Repository interface {
        Create(table string, fields []string, values []interface{}) (int64, error)
        Update(table string, id interface{}, data interface{}) error
        Delete(table string, id interface{}) error
        FindByID(table string, id interface{}, result interface{}) error
        FindAll(table string, result interface{}, conditions map[string]interface{}, orderBy string, limit, offset int) error
        FindOne(table string, result interface{}, conditions map[string]interface{}) error
        Count(table string, conditions map[string]interface{}) (int64, error)
        Search(table string, fields []string, term string, limit, offset int, result interface{}) error
        FindByDateRange(table, dateField string, start, end time.Time, limit, offset int, result interface{}) error
        Transaction(fn func(*sql.Tx) error) error
        SetConnectionPool(maxOpen, maxIdle int, maxLifetime time.Duration)
        SoftDelete(table string, id interface{}) error
        BulkCreate(table string, data []interface{}) ([]int64, error)
        BulkUpdate(table string, ids []interface{}, data interface{}) error
        BulkDelete(table string, ids []interface{}) error
        Exists(table string, conditions map[string]interface{}) (bool, error)
}

// MySQLRepository represents a MySQL database repository
type MySQLRepository struct {
        db *sql.DB
}

// NewMySQLRepository creates a new MySQL repository
func NewMySQLRepository(db *sql.DB) *MySQLRepository <span class="cov0" title="0">{
        return &amp;MySQLRepository{db: db}
}</span>

// SetConnectionPool sets the connection pool parameters
func (r *MySQLRepository) SetConnectionPool(maxOpen, maxIdle int, maxLifetime time.Duration) <span class="cov0" title="0">{
        r.db.SetMaxOpenConns(maxOpen)
        r.db.SetMaxIdleConns(maxIdle)
        r.db.SetConnMaxLifetime(maxLifetime)
}</span>

// validateTableName checks if the table name is valid
func validateTableName(table string) bool <span class="cov0" title="0">{
        // Basit bir regex kontrolü - sadece harf, rakam ve alt çizgi
        for _, c := range table </span><span class="cov0" title="0">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '_') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Create inserts a new record
func (r *MySQLRepository) Create(table string, fields []string, values []interface{}) (int64, error) <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return 0, &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        data := make(map[string]interface{})
        for i, field := range fields </span><span class="cov0" title="0">{
                // Byte array'i string'e dönüştür
                value := values[i]
                if byteArray, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                        value = string(byteArray)
                }</span>
                <span class="cov0" title="0">data[field] = value</span>
        }

        <span class="cov0" title="0">query, args := qb.BuildInsert(data)
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        result, err := stmt.Exec(args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, &amp;DatabaseError{
                        Code:    "EXEC_ERROR",
                        Message: "error executing query",
                        Err:     err,
                }
        }</span>

        <span class="cov0" title="0">return result.LastInsertId()</span>
}

// Update updates a record
func (r *MySQLRepository) Update(table string, id interface{}, data interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">fields, values := getFieldsAndValues(data)
        qb := NewQueryBuilder(table)
        dataMap := make(map[string]interface{})
        for i, field := range fields </span><span class="cov0" title="0">{
                // Byte array'i string'e dönüştür
                value := values[i]
                if byteArray, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                        value = string(byteArray)
                }</span>
                <span class="cov0" title="0">dataMap[field] = value</span>
        }

        <span class="cov0" title="0">query, args := qb.Where("id", Equal, id).BuildUpdate(dataMap)
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        _, err = stmt.Exec(args...)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "EXEC_ERROR",
                        Message: "error executing query",
                        Err:     err,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a record
func (r *MySQLRepository) Delete(table string, id interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        query, args := qb.Where("id", Equal, id).BuildDelete()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        _, err = stmt.Exec(args...)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "EXEC_ERROR",
                        Message: "error executing query",
                        Err:     err,
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindByID finds a record by ID
func (r *MySQLRepository) FindByID(table string, id interface{}, result interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        query, args := qb.FindByID(id)
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        row := stmt.QueryRow(args...)
        return row.Scan(result)</span>
}

// FindAll finds all records with pagination
func (r *MySQLRepository) FindAll(table string, orderBy string, limit, offset int, dest interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid table name: %s", table)
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        query, args := qb.OrderBy(orderBy, Descending).Limit(limit).Offset(offset).Build()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error preparing statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.Query(args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error executing query: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return rows.Scan(dest)</span>
}

// FindOne finds a single record
func (r *MySQLRepository) FindOne(table string, conditions map[string]interface{}, dest interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        qb.Filter(conditions)
        query, args := qb.Limit(1).Build()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.Query(args...)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "QUERY_ERROR",
                        Message: "error executing query",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        // Struct tipini kontrol et
        <span class="cov0" title="0">v := reflect.ValueOf(dest)
        if v.Kind() == reflect.Ptr &amp;&amp; v.Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                // Struct için özel işlem
                columns, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;DatabaseError{
                                Code:    "COLUMN_ERROR",
                                Message: "error getting columns",
                                Err:     err,
                        }
                }</span>

                <span class="cov0" title="0">values := make([]interface{}, len(columns))
                valuePtrs := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">err = rows.Scan(valuePtrs...)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;DatabaseError{
                                Code:    "SCAN_ERROR",
                                Message: "error scanning row",
                                Err:     err,
                        }
                }</span>

                // Struct'ı doldur
                <span class="cov0" title="0">elem := v.Elem()
                for i, col := range columns </span><span class="cov0" title="0">{
                        field := elem.FieldByName(col)
                        if field.IsValid() &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                                val := values[i]
                                if val != nil </span><span class="cov0" title="0">{
                                        // Byte array'i string'e dönüştür
                                        if byteArray, ok := val.([]byte); ok </span><span class="cov0" title="0">{
                                                // Eğer şifre alanıysa ve bcrypt formatındaysa, doğrudan byte array'i stringe çevir
                                                if col == "password" &amp;&amp; (strings.HasPrefix(string(byteArray), "$2a$") ||
                                                        strings.HasPrefix(string(byteArray), "$2b$") ||
                                                        strings.HasPrefix(string(byteArray), "$2y$")) </span><span class="cov0" title="0">{
                                                        val = string(byteArray)
                                                }</span> else<span class="cov0" title="0"> {
                                                        val = string(byteArray)
                                                }</span>
                                        }

                                        // Değeri set et
                                        <span class="cov0" title="0">if field.Type().Kind() == reflect.String </span><span class="cov0" title="0">{
                                                field.SetString(fmt.Sprintf("%v", val))
                                        }</span> else<span class="cov0" title="0"> {
                                                field.Set(reflect.ValueOf(val))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }

        // Basit tip için doğrudan Scan kullan
        <span class="cov0" title="0">var result interface{}
        err = rows.Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "SCAN_ERROR",
                        Message: "error scanning row",
                        Err:     err,
                }
        }</span>

        // Byte array'i string'e dönüştür
        <span class="cov0" title="0">if byteArray, ok := result.([]byte); ok </span><span class="cov0" title="0">{
                result = string(byteArray)
        }</span>

        <span class="cov0" title="0">reflect.ValueOf(dest).Elem().Set(reflect.ValueOf(result))
        return nil</span>
}

// Count counts records
func (r *MySQLRepository) Count(table string, conditions map[string]interface{}) (int64, error) <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid table name: %s", table)
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        qb.Filter(conditions)
        query, args := qb.BuildCount()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error preparing statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var count int64
        err = stmt.QueryRow(args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error executing query: %v", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Search searches records
func (r *MySQLRepository) Search(table string, fields []string, term string, limit, offset int, dest interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid table name: %s", table)
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        qb.Search(fields, term)
        query, args := qb.Limit(limit).Offset(offset).Build()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error preparing statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.Query(args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error executing query: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return rows.Scan(dest)</span>
}

// FindByDateRange finds records within a date range
func (r *MySQLRepository) FindByDateRange(table, dateField string, start, end time.Time, limit, offset int, dest interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid table name: %s", table)
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        query, args := qb.WhereDateBetween(dateField, start, end).Limit(limit).Offset(offset).Build()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error preparing statement: %v", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.Query(args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error executing query: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return rows.Scan(dest)</span>
}

// Transaction executes a function within a transaction
func (r *MySQLRepository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error beginning transaction: %v", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                        panic(p)</span>
                }
        }()

        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error rolling back transaction: %v (original error: %v)", rbErr, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error committing transaction: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the database connection
func (r *MySQLRepository) Close() error <span class="cov0" title="0">{
        return r.db.Close()
}</span>

// SoftDelete performs a soft delete operation
func (r *MySQLRepository) SoftDelete(table string, id interface{}) error <span class="cov0" title="0">{
        return r.Update(table, id, map[string]interface{}{
                "deleted_at": time.Now(),
                "is_deleted": true,
        })
}</span>

// BulkCreate performs bulk insert operations
func (r *MySQLRepository) BulkCreate(table string, data []interface{}) ([]int64, error) <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return nil, &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">ids := make([]int64, 0, len(data))
        for _, item := range data </span><span class="cov0" title="0">{
                fields, values := getFieldsAndValues(item)
                id, err := r.Create(table, fields, values)
                if err != nil </span><span class="cov0" title="0">{
                        return ids, err
                }</span>
                <span class="cov0" title="0">ids = append(ids, id)</span>
        }
        <span class="cov0" title="0">return ids, nil</span>
}

// BulkUpdate performs bulk update operations
func (r *MySQLRepository) BulkUpdate(table string, ids []interface{}, data interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">for _, id := range ids </span><span class="cov0" title="0">{
                if err := r.Update(table, id, data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// BulkDelete performs bulk delete operations
func (r *MySQLRepository) BulkDelete(table string, ids []interface{}) error <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">for _, id := range ids </span><span class="cov0" title="0">{
                if err := r.Delete(table, id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a record exists
func (r *MySQLRepository) Exists(table string, conditions map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        if !validateTableName(table) </span><span class="cov0" title="0">{
                return false, &amp;DatabaseError{
                        Code:    "INVALID_TABLE",
                        Message: fmt.Sprintf("invalid table name: %s", table),
                }
        }</span>

        <span class="cov0" title="0">qb := NewQueryBuilder(table)
        qb.Filter(conditions)
        query, args := qb.BuildCount()
        stmt, err := r.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;DatabaseError{
                        Code:    "PREPARE_ERROR",
                        Message: "error preparing statement",
                        Err:     err,
                }
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var count int64
        err = stmt.QueryRow(args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;DatabaseError{
                        Code:    "EXEC_ERROR",
                        Message: "error executing query",
                        Err:     err,
                }
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Helper functions

// getFieldsAndValues extracts fields and values from a struct
func getFieldsAndValues(data interface{}) ([]string, []interface{}) <span class="cov0" title="0">{
        fields := make([]string, 0)
        values := make([]interface{}, 0)

        val := reflect.ValueOf(data)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>

        <span class="cov0" title="0">if val.Kind() == reflect.Map </span><span class="cov0" title="0">{
                mapType := val.Type()
                if mapType.Key().Kind() == reflect.String </span><span class="cov0" title="0">{
                        iter := val.MapRange()
                        for iter.Next() </span><span class="cov0" title="0">{
                                key := iter.Key().String()
                                value := iter.Value().Interface()
                                fields = append(fields, key)
                                values = append(values, value)
                        }</span>
                }
                <span class="cov0" title="0">return fields, values</span>
        }

        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fields, values
        }</span>

        <span class="cov0" title="0">typ := val.Type()
        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i)
                // Skip unexported fields
                if field.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get field tag or use field name
                <span class="cov0" title="0">tag := field.Tag.Get("db")
                if tag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if tag == "" </span><span class="cov0" title="0">{
                        tag = field.Name
                }</span>

                // Handle embedded structs
                <span class="cov0" title="0">if field.Anonymous &amp;&amp; val.Field(i).Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        embeddedFields, embeddedValues := getFieldsAndValues(val.Field(i).Interface())
                        fields = append(fields, embeddedFields...)
                        values = append(values, embeddedValues...)
                        continue</span>
                }

                <span class="cov0" title="0">fields = append(fields, tag)
                values = append(values, val.Field(i).Interface())</span>
        }

        <span class="cov0" title="0">return fields, values</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "reflect"
        "strings"
)

// DynamicRepository provides a completely dynamic database interface
type DynamicRepository struct {
        db *sql.DB
}

// NewDynamicRepository creates a new dynamic repository
func NewDynamicRepository(db *sql.DB) *DynamicRepository <span class="cov0" title="0">{
        return &amp;DynamicRepository{db: db}
}</span>

// DynamicQuery represents a dynamic query
type DynamicQuery struct {
        db            *sql.DB
        Table         string
        Operation     string // "SELECT", "INSERT", "UPDATE", "DELETE"
        Fields        []string
        Values        []interface{}
        Conditions    map[string]interface{}
        Joins         []Join
        GroupByClause string
        HavingClause  string
        OrderByClause string
        LimitValue    int
        OffsetValue   int
        ReturnID      bool
        Transaction   *sql.Tx
}

// Join represents a table join
type Join struct {
        Table     string
        Type      string // "INNER", "LEFT", "RIGHT"
        Condition string
}

// NewQuery creates a new dynamic query
func (r *DynamicRepository) NewQuery(table string) *DynamicQuery <span class="cov0" title="0">{
        return &amp;DynamicQuery{
                db:         r.db,
                Table:      table,
                Operation:  "SELECT",
                Conditions: make(map[string]interface{}),
                Joins:      make([]Join, 0),
        }
}</span>

// Select sets the fields to select
func (q *DynamicQuery) Select(fields ...string) *DynamicQuery <span class="cov0" title="0">{
        q.Operation = "SELECT"
        q.Fields = fields
        return q
}</span>

// Insert prepares an insert operation
func (q *DynamicQuery) Insert(data interface{}) *DynamicQuery <span class="cov0" title="0">{
        q.Operation = "INSERT"

        // Get fields and values from the struct
        v := reflect.ValueOf(data)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">t := v.Type()

        fields := make([]string, 0)
        values := make([]interface{}, 0)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                value := v.Field(i).Interface()

                // Skip zero values and unexported fields
                if !reflect.DeepEqual(value, reflect.Zero(field.Type).Interface()) &amp;&amp; field.IsExported() </span><span class="cov0" title="0">{
                        fields = append(fields, field.Name)
                        values = append(values, value)
                }</span>
        }

        <span class="cov0" title="0">q.Fields = fields
        q.Values = values
        return q</span>
}

// Update prepares an update operation
func (q *DynamicQuery) Update(data interface{}) *DynamicQuery <span class="cov0" title="0">{
        q.Operation = "UPDATE"

        // Get fields and values from the struct
        v := reflect.ValueOf(data)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">t := v.Type()

        fields := make([]string, 0)
        values := make([]interface{}, 0)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                value := v.Field(i).Interface()

                // Skip zero values and unexported fields
                if !reflect.DeepEqual(value, reflect.Zero(field.Type).Interface()) &amp;&amp; field.IsExported() </span><span class="cov0" title="0">{
                        fields = append(fields, field.Name)
                        values = append(values, value)
                }</span>
        }

        <span class="cov0" title="0">q.Fields = fields
        q.Values = values
        return q</span>
}

// Delete prepares a delete operation
func (q *DynamicQuery) Delete() *DynamicQuery <span class="cov0" title="0">{
        q.Operation = "DELETE"
        return q
}</span>

// Where adds a condition
func (q *DynamicQuery) Where(field string, value interface{}) *DynamicQuery <span class="cov0" title="0">{
        q.Conditions[field] = value
        return q
}</span>

// WhereIn adds a WHERE IN condition
func (q *DynamicQuery) WhereIn(field string, values []interface{}) *DynamicQuery <span class="cov0" title="0">{
        placeholders := make([]string, len(values))
        for i := range values </span><span class="cov0" title="0">{
                placeholders[i] = "?"
        }</span>
        <span class="cov0" title="0">q.Conditions[field+" IN ("+strings.Join(placeholders, ",")+")"] = values
        return q</span>
}

// Join adds a table join
func (q *DynamicQuery) Join(joinType, table, condition string) *DynamicQuery <span class="cov0" title="0">{
        q.Joins = append(q.Joins, Join{
                Type:      joinType,
                Table:     table,
                Condition: condition,
        })
        return q
}</span>

// GroupBy sets the GROUP BY clause
func (q *DynamicQuery) GroupBy(groupBy string) *DynamicQuery <span class="cov0" title="0">{
        q.GroupByClause = groupBy
        return q
}</span>

// Having sets the HAVING clause
func (q *DynamicQuery) Having(having string) *DynamicQuery <span class="cov0" title="0">{
        q.HavingClause = having
        return q
}</span>

// OrderBy sets the ORDER BY clause
func (q *DynamicQuery) OrderBy(orderBy string) *DynamicQuery <span class="cov0" title="0">{
        q.OrderByClause = orderBy
        return q
}</span>

// Limit sets the LIMIT clause
func (q *DynamicQuery) Limit(limit int) *DynamicQuery <span class="cov0" title="0">{
        q.LimitValue = limit
        return q
}</span>

// Offset sets the OFFSET clause
func (q *DynamicQuery) Offset(offset int) *DynamicQuery <span class="cov0" title="0">{
        q.OffsetValue = offset
        return q
}</span>

// WithTransaction sets the transaction
func (q *DynamicQuery) WithTransaction(tx *sql.Tx) *DynamicQuery <span class="cov0" title="0">{
        q.Transaction = tx
        return q
}</span>

// Build constructs the SQL query
func (q *DynamicQuery) Build() (string, []interface{}) <span class="cov0" title="0">{
        var query strings.Builder
        args := make([]interface{}, 0)

        switch q.Operation </span>{
        case "SELECT":<span class="cov0" title="0">
                query.WriteString("SELECT ")
                if len(q.Fields) &gt; 0 </span><span class="cov0" title="0">{
                        query.WriteString(strings.Join(q.Fields, ", "))
                }</span> else<span class="cov0" title="0"> {
                        query.WriteString("*")
                }</span>
                <span class="cov0" title="0">query.WriteString(" FROM ")
                query.WriteString(q.Table)</span>

        case "INSERT":<span class="cov0" title="0">
                query.WriteString("INSERT INTO ")
                query.WriteString(q.Table)
                query.WriteString(" (")
                query.WriteString(strings.Join(q.Fields, ", "))
                query.WriteString(") VALUES (")
                placeholders := make([]string, len(q.Fields))
                for i := range q.Fields </span><span class="cov0" title="0">{
                        placeholders[i] = "?"
                }</span>
                <span class="cov0" title="0">query.WriteString(strings.Join(placeholders, ", "))
                query.WriteString(")")
                args = append(args, q.Values...)
                return query.String(), args</span>

        case "UPDATE":<span class="cov0" title="0">
                query.WriteString("UPDATE ")
                query.WriteString(q.Table)
                query.WriteString(" SET ")
                setClause := make([]string, len(q.Fields))
                for i, field := range q.Fields </span><span class="cov0" title="0">{
                        setClause[i] = fmt.Sprintf("%s = ?", field)
                }</span>
                <span class="cov0" title="0">query.WriteString(strings.Join(setClause, ", "))
                args = append(args, q.Values...)</span>

        case "DELETE":<span class="cov0" title="0">
                query.WriteString("DELETE FROM ")
                query.WriteString(q.Table)</span>
        }

        // Add joins
        <span class="cov0" title="0">if len(q.Joins) &gt; 0 </span><span class="cov0" title="0">{
                for _, join := range q.Joins </span><span class="cov0" title="0">{
                        query.WriteString(fmt.Sprintf(" %s JOIN %s ON %s", join.Type, join.Table, join.Condition))
                }</span>
        }

        // Add where conditions
        <span class="cov0" title="0">if len(q.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(" WHERE ")
                whereClause := make([]string, 0)
                for field, value := range q.Conditions </span><span class="cov0" title="0">{
                        if strings.Contains(field, " IN ") </span><span class="cov0" title="0">{
                                whereClause = append(whereClause, field)
                                if values, ok := value.([]interface{}); ok </span><span class="cov0" title="0">{
                                        args = append(args, values...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                whereClause = append(whereClause, fmt.Sprintf("%s = ?", field))
                                args = append(args, value)
                        }</span>
                }
                <span class="cov0" title="0">query.WriteString(strings.Join(whereClause, " AND "))</span>
        }

        // Add group by
        <span class="cov0" title="0">if q.GroupByClause != "" </span><span class="cov0" title="0">{
                query.WriteString(" GROUP BY ")
                query.WriteString(q.GroupByClause)
        }</span>

        // Add having
        <span class="cov0" title="0">if q.HavingClause != "" </span><span class="cov0" title="0">{
                query.WriteString(" HAVING ")
                query.WriteString(q.HavingClause)
        }</span>

        // Add order by
        <span class="cov0" title="0">if q.OrderByClause != "" </span><span class="cov0" title="0">{
                query.WriteString(" ORDER BY ")
                query.WriteString(q.OrderByClause)
        }</span>

        // Add limit and offset
        <span class="cov0" title="0">if q.LimitValue &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(fmt.Sprintf(" LIMIT %d", q.LimitValue))
                if q.OffsetValue &gt; 0 </span><span class="cov0" title="0">{
                        query.WriteString(fmt.Sprintf(" OFFSET %d", q.OffsetValue))
                }</span>
        }

        <span class="cov0" title="0">return query.String(), args</span>
}

// Execute executes the query
func (q *DynamicQuery) Execute() (sql.Result, error) <span class="cov0" title="0">{
        query, args := q.Build()

        if q.Transaction != nil </span><span class="cov0" title="0">{
                return q.Transaction.Exec(query, args...)
        }</span>
        <span class="cov0" title="0">return q.db.Exec(query, args...)</span>
}

// Query executes the query and returns rows
func (q *DynamicQuery) Query() (*sql.Rows, error) <span class="cov0" title="0">{
        query, args := q.Build()

        if q.Transaction != nil </span><span class="cov0" title="0">{
                return q.Transaction.Query(query, args...)
        }</span>
        <span class="cov0" title="0">return q.db.Query(query, args...)</span>
}

// QueryRow executes the query and returns a single row
func (q *DynamicQuery) QueryRow() *sql.Row <span class="cov0" title="0">{
        query, args := q.Build()

        if q.Transaction != nil </span><span class="cov0" title="0">{
                return q.Transaction.QueryRow(query, args...)
        }</span>
        <span class="cov0" title="0">return q.db.QueryRow(query, args...)</span>
}

// Scan scans the result into the provided interface
func (q *DynamicQuery) Scan(result interface{}) error <span class="cov0" title="0">{
        rows, err := q.Query()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        v := reflect.ValueOf(result)
        if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return fmt.Errorf("result must be a pointer to a slice")
        }</span>
        <span class="cov0" title="0">v = v.Elem()
        t := v.Type().Elem()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values </span><span class="cov0" title="0">{
                valuePtrs[i] = &amp;values[i]
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">item := reflect.New(t).Elem()
                for i, col := range columns </span><span class="cov0" title="0">{
                        field := item.FieldByName(col)
                        if field.IsValid() &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                                val := values[i]
                                if val != nil </span><span class="cov0" title="0">{
                                        field.Set(reflect.ValueOf(val))
                                }</span>
                        }
                }

                <span class="cov0" title="0">v.Set(reflect.Append(v, item))</span>
        }

        <span class="cov0" title="0">return rows.Err()</span>
}

// NewDynamicQuery creates a new dynamic query
func NewDynamicQuery(db *sql.DB, table string) *DynamicQuery <span class="cov0" title="0">{
        return &amp;DynamicQuery{
                db:         db,
                Table:      table,
                Operation:  "SELECT",
                Conditions: make(map[string]interface{}),
                Joins:      make([]Join, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        "kolajAi/internal/database/migrations"
)

// Migration represents a database migration
type Migration struct {
        ID        int
        Name      string
        SQL       string
        CreatedAt time.Time
}

// Migrator handles database migrations
type Migrator struct {
        db *sql.DB
}

// NewMigrator creates a new migrator
func NewMigrator(db *sql.DB) (*Migrator, error) <span class="cov0" title="0">{
        m := &amp;Migrator{db: db}

        // Create migrations table if it doesn't exist
        err := m.createMigrationsTable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}

// createMigrationsTable creates the migrations table if it doesn't exist
func (m *Migrator) createMigrationsTable() error <span class="cov0" title="0">{
        // Bu işlem için doğrudan SQL kullanmak gerekiyor çünkü tablo oluşturma
        // işlemi için QueryBuilder'da uygun bir metod bulunmuyor
        query := `
        CREATE TABLE IF NOT EXISTS migrations (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(255) NOT NULL UNIQUE,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        stmt, err := m.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        _, err = stmt.Exec()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ApplyMigration applies a single migration
func (m *Migrator) ApplyMigration(migration Migration) error <span class="cov0" title="0">{
        // QueryBuilder kullanarak migration kontrolü yap
        qb := NewQueryBuilder("migrations")
        query, args := qb.Where("name", Equal, migration.Name).BuildCount()

        stmt, err := m.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var count int64
        err = stmt.QueryRow(args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check migration status: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                // Migration already applied
                return nil
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := m.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>

        // Migration SQL'i doğrudan uygulanmalı çünkü bu özel bir SQL ifadesi
        // ve QueryBuilder ile oluşturulamaz
        <span class="cov0" title="0">stmt, err = tx.Prepare(migration.SQL)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to prepare migration statement: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = stmt.Exec()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to apply migration: %w", err)
        }</span>
        <span class="cov0" title="0">stmt.Close()

        // QueryBuilder kullanarak migration kaydı ekle
        insertQb := NewQueryBuilder("migrations")
        insertQuery, insertArgs := insertQb.BuildInsert(map[string]interface{}{
                "name": migration.Name,
        })

        stmt, err = tx.Prepare(insertQuery)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to prepare insert statement: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = stmt.Exec(insertArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to record migration: %w", err)
        }</span>
        <span class="cov0" title="0">stmt.Close()

        // Commit transaction
        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit migration: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Applied migration: %s", migration.Name)
        return nil</span>
}

// ApplyMigrations applies multiple migrations in order
func (m *Migrator) ApplyMigrations(migrations []Migration) error <span class="cov0" title="0">{
        for _, migration := range migrations </span><span class="cov0" title="0">{
                err := m.ApplyMigration(migration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetAppliedMigrations returns all applied migrations
func (m *Migrator) GetAppliedMigrations() ([]string, error) <span class="cov0" title="0">{
        // QueryBuilder kullanarak uygulanmış migrasyonları al
        qb := NewQueryBuilder("migrations")
        query, args := qb.Select("name").OrderBy("id", Ascending).Build()

        stmt, err := m.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        rows, err := stmt.Query(args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get applied migrations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var migrations []string
        for rows.Next() </span><span class="cov0" title="0">{
                var name string
                err := rows.Scan(&amp;name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan migration: %w", err)
                }</span>
                <span class="cov0" title="0">migrations = append(migrations, name)</span>
        }

        <span class="cov0" title="0">return migrations, nil</span>
}

// ApplyCoreMigrations applies the core migrations that are built into the application
func (m *Migrator) ApplyCoreMigrations() error <span class="cov0" title="0">{
        coreMigrations := []Migration{
                {
                        Name: "001_create_users_table",
                        SQL:  migrations.CreateUsersTable,
                },
                {
                        Name: "002_create_sessions_table",
                        SQL:  migrations.CreateSessionsTable,
                },
                {
                        Name: "003_create_email_log_table",
                        SQL:  migrations.CreateEmailLogTable,
                },
                {
                        Name: "004_create_user_profiles_table",
                        SQL:  migrations.CreateUserProfilesTable,
                },
        }

        return m.ApplyMigrations(coreMigrations)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "strings"
        "time"
)

// MigrationService handles database migrations
type MigrationService struct {
        db     *sql.DB
        dbName string
}

// NewMigrationService creates a new migration service
func NewMigrationService(db *sql.DB, dbName string) *MigrationService <span class="cov0" title="0">{
        return &amp;MigrationService{
                db:     db,
                dbName: dbName,
        }
}</span>

// EnsureMigrationTable creates the migrations table if it doesn't exist
func (m *MigrationService) EnsureMigrationTable() error <span class="cov0" title="0">{
        query := `
        CREATE TABLE IF NOT EXISTS schema_migrations (
                version VARCHAR(255) NOT NULL,
                applied_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (version)
        );`

        _, err := m.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating migration table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAppliedMigrations returns a list of already applied migrations
func (m *MigrationService) GetAppliedMigrations() (map[string]bool, error) <span class="cov0" title="0">{
        applied := make(map[string]bool)

        rows, err := m.db.Query("SELECT version FROM schema_migrations ORDER BY version")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error querying migrations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var version string
                if err := rows.Scan(&amp;version); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error scanning migration version: %w", err)
                }</span>
                <span class="cov0" title="0">applied[version] = true</span>
        }

        <span class="cov0" title="0">return applied, nil</span>
}

// CreateMigration creates a new migration file with the given name
func (m *MigrationService) CreateMigration(name string) (string, error) <span class="cov0" title="0">{
        timestamp := time.Now().Format("20060102150405")
        safeName := strings.ReplaceAll(strings.ToLower(name), " ", "_")

        // Create both up and down migrations
        upFileName := fmt.Sprintf("%s_%s.up.sql", timestamp, safeName)
        downFileName := fmt.Sprintf("%s_%s.down.sql", timestamp, safeName)

        // Note: In an actual implementation, this would create the files
        // For this example, we'll just return the filenames
        return fmt.Sprintf("Created migration files: %s and %s", upFileName, downFileName), nil
}</span>

// RunMigrations runs all pending migrations
func (m *MigrationService) RunMigrations() error <span class="cov0" title="0">{
        // Ensure migration table exists
        if err := m.EnsureMigrationTable(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get applied migrations
        <span class="cov0" title="0">applied, err := m.GetAppliedMigrations()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Define all migrations in order
        <span class="cov0" title="0">migrations := []struct {
                version string
                sql     string
        }{
                {"001_create_users_table", CreateUsersTable},
                {"002_create_sessions_table", CreateSessionsTable},
                {"003_create_email_log_table", CreateEmailLogTable},
                {"004_create_user_profiles_table", CreateUserProfilesTable},
                {"005_create_vendors_table", CreateVendorsTable},
                {"006_create_products_table", CreateProductsTable},
                {"007_create_orders_table", CreateOrdersTable},
                {"008_create_auctions_table", CreateAuctionsTable},
                {"009_create_wholesale_table", CreateWholesaleTable},
        }

        // Run pending migrations
        for _, migration := range migrations </span><span class="cov0" title="0">{
                if !applied[migration.version] </span><span class="cov0" title="0">{
                        fmt.Printf("Running migration: %s\n", migration.version)

                        // Execute migration
                        _, err := m.db.Exec(migration.sql)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error running migration %s: %w", migration.version, err)
                        }</span>

                        // Record migration as applied
                        <span class="cov0" title="0">_, err = m.db.Exec("INSERT INTO schema_migrations (version) VALUES (?)", migration.version)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error recording migration %s: %w", migration.version, err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Migration %s completed successfully\n", migration.version)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package database

import (
        "fmt"
        "strings"
        "time"
)

// QueryType represents the type of query
type QueryType string

const (
        Select QueryType = "SELECT"
        Insert QueryType = "INSERT"
        Update QueryType = "UPDATE"
        Delete QueryType = "DELETE"
        Count  QueryType = "COUNT"
)

// JoinType represents the type of join
type JoinType string

const (
        InnerJoin JoinType = "INNER JOIN"
        LeftJoin  JoinType = "LEFT JOIN"
        RightJoin JoinType = "RIGHT JOIN"
        FullJoin  JoinType = "FULL JOIN"
)

// Operator represents the comparison operator
type Operator string

const (
        Equal        Operator = "="
        NotEqual     Operator = "!="
        GreaterThan  Operator = "&gt;"
        LessThan     Operator = "&lt;"
        GreaterEqual Operator = "&gt;="
        LessEqual    Operator = "&lt;="
        Like         Operator = "LIKE"
        In           Operator = "IN"
        NotIn        Operator = "NOT IN"
        Between      Operator = "BETWEEN"
        IsNull       Operator = "IS NULL"
        IsNotNull    Operator = "IS NOT NULL"
)

// SortDirection represents the sort direction
type SortDirection string

const (
        Ascending  SortDirection = "ASC"
        Descending SortDirection = "DESC"
)

// Condition represents a where condition
type Condition struct {
        Field    string
        Operator Operator
        Value    interface{}
        Or       bool // If true, condition will be joined with OR instead of AND
}

// Subquery represents a subquery in the query
type Subquery struct {
        Query *QueryBuilder
        Alias string
}

// Case represents a CASE-WHEN expression
type Case struct {
        Field        string
        Cases        map[interface{}]interface{}
        DefaultValue interface{}
}

// QueryBuilder helps build SQL queries safely
type QueryBuilder struct {
        queryType  QueryType
        table      string
        selects    []string
        joins      []string
        conditions []Condition
        orderBy    []string
        groupBy    []string
        having     string
        limit      int
        offset     int
        values     map[string]interface{}
        subqueries []Subquery
        cases      []Case
}

// NewQueryBuilder creates a new query builder
func NewQueryBuilder(table string) *QueryBuilder <span class="cov0" title="0">{
        return &amp;QueryBuilder{
                table:      table,
                queryType:  Select,
                selects:    []string{"*"},
                conditions: make([]Condition, 0),
                orderBy:    make([]string, 0),
                groupBy:    make([]string, 0),
                values:     make(map[string]interface{}),
                subqueries: make([]Subquery, 0),
                cases:      make([]Case, 0),
        }
}</span>

// Select sets the columns to select
func (qb *QueryBuilder) Select(columns ...string) *QueryBuilder <span class="cov0" title="0">{
        qb.queryType = Select
        qb.selects = columns
        return qb
}</span>

// Insert prepares an insert query
func (qb *QueryBuilder) Insert(data map[string]interface{}) *QueryBuilder <span class="cov0" title="0">{
        qb.queryType = Insert
        qb.values = data
        return qb
}</span>

// Update prepares an update query
func (qb *QueryBuilder) Update(data map[string]interface{}) *QueryBuilder <span class="cov0" title="0">{
        qb.queryType = Update
        qb.values = data
        return qb
}</span>

// Delete prepares a delete query
func (qb *QueryBuilder) Delete() *QueryBuilder <span class="cov0" title="0">{
        qb.queryType = Delete
        return qb
}</span>

// Count prepares a count query
func (qb *QueryBuilder) Count() *QueryBuilder <span class="cov0" title="0">{
        qb.queryType = Count
        return qb
}</span>

// Join adds a join clause
func (qb *QueryBuilder) Join(joinType JoinType, table, condition string) *QueryBuilder <span class="cov0" title="0">{
        qb.joins = append(qb.joins, fmt.Sprintf("%s %s ON %s", joinType, table, condition))
        return qb
}</span>

// Where adds a where condition
func (qb *QueryBuilder) Where(field string, operator Operator, value interface{}) *QueryBuilder <span class="cov0" title="0">{
        qb.conditions = append(qb.conditions, Condition{
                Field:    field,
                Operator: operator,
                Value:    value,
        })
        return qb
}</span>

// OrWhere adds a where condition with OR
func (qb *QueryBuilder) OrWhere(field string, operator Operator, value interface{}) *QueryBuilder <span class="cov0" title="0">{
        qb.conditions = append(qb.conditions, Condition{
                Field:    field,
                Operator: operator,
                Value:    value,
                Or:       true,
        })
        return qb
}</span>

// WhereIn adds a WHERE IN condition
func (qb *QueryBuilder) WhereIn(field string, values []interface{}) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, In, values)
}</span>

// WhereNotIn adds a WHERE NOT IN condition
func (qb *QueryBuilder) WhereNotIn(field string, values []interface{}) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, NotIn, values)
}</span>

// WhereLike adds a WHERE LIKE condition
func (qb *QueryBuilder) WhereLike(field, pattern string) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, Like, "%"+pattern+"%")
}</span>

// WhereStartsWith adds a WHERE LIKE condition for prefix match
func (qb *QueryBuilder) WhereStartsWith(field, prefix string) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, Like, prefix+"%")
}</span>

// WhereEndsWith adds a WHERE LIKE condition for suffix match
func (qb *QueryBuilder) WhereEndsWith(field, suffix string) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, Like, "%"+suffix)
}</span>

// WhereBetween adds a WHERE BETWEEN condition
func (qb *QueryBuilder) WhereBetween(field string, start, end interface{}) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, Between, []interface{}{start, end})
}</span>

// WhereNull adds a WHERE IS NULL condition
func (qb *QueryBuilder) WhereNull(field string) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, IsNull, nil)
}</span>

// WhereNotNull adds a WHERE IS NOT NULL condition
func (qb *QueryBuilder) WhereNotNull(field string) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, IsNotNull, nil)
}</span>

// WhereDate adds a WHERE condition for date comparison
func (qb *QueryBuilder) WhereDate(field string, operator Operator, date time.Time) *QueryBuilder <span class="cov0" title="0">{
        return qb.Where(field, operator, date.Format("2006-01-02"))
}</span>

// WhereDateBetween adds a WHERE BETWEEN condition for date range
func (qb *QueryBuilder) WhereDateBetween(field string, start, end time.Time) *QueryBuilder <span class="cov0" title="0">{
        return qb.WhereBetween(field, start.Format("2006-01-02"), end.Format("2006-01-02"))
}</span>

// OrderBy adds an ORDER BY clause
func (qb *QueryBuilder) OrderBy(field string, direction SortDirection) *QueryBuilder <span class="cov0" title="0">{
        qb.orderBy = append(qb.orderBy, fmt.Sprintf("%s %s", field, direction))
        return qb
}</span>

// GroupBy adds a GROUP BY clause
func (qb *QueryBuilder) GroupBy(fields ...string) *QueryBuilder <span class="cov0" title="0">{
        qb.groupBy = append(qb.groupBy, fields...)
        return qb
}</span>

// Having adds a HAVING clause
func (qb *QueryBuilder) Having(having string) *QueryBuilder <span class="cov0" title="0">{
        qb.having = having
        return qb
}</span>

// Limit sets the limit
func (qb *QueryBuilder) Limit(limit int) *QueryBuilder <span class="cov0" title="0">{
        qb.limit = limit
        return qb
}</span>

// Offset sets the offset
func (qb *QueryBuilder) Offset(offset int) *QueryBuilder <span class="cov0" title="0">{
        qb.offset = offset
        return qb
}</span>

// Subquery adds a subquery to the query
func (qb *QueryBuilder) Subquery(subquery *QueryBuilder, alias string) *QueryBuilder <span class="cov0" title="0">{
        qb.subqueries = append(qb.subqueries, Subquery{
                Query: subquery,
                Alias: alias,
        })
        return qb
}</span>

// Case adds a CASE-WHEN expression to the query
func (qb *QueryBuilder) Case(field string, cases map[interface{}]interface{}, defaultValue interface{}) *QueryBuilder <span class="cov0" title="0">{
        qb.cases = append(qb.cases, Case{
                Field:        field,
                Cases:        cases,
                DefaultValue: defaultValue,
        })
        return qb
}</span>

// Validate validates the query builder
func (qb *QueryBuilder) Validate() error <span class="cov0" title="0">{
        if qb.table == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("table name is required")
        }</span>

        <span class="cov0" title="0">if qb.queryType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("query type is required")
        }</span>

        <span class="cov0" title="0">if qb.queryType == Insert &amp;&amp; len(qb.values) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("values are required for insert query")
        }</span>

        <span class="cov0" title="0">if qb.queryType == Update &amp;&amp; len(qb.values) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("values are required for update query")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Build constructs the SQL query
func (qb *QueryBuilder) Build() (string, []interface{}) <span class="cov0" title="0">{
        if err := qb.Validate(); err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">var query strings.Builder
        args := make([]interface{}, 0)

        switch qb.queryType </span>{
        case Select:<span class="cov0" title="0">
                query.WriteString("SELECT ")
                if len(qb.selects) &gt; 0 </span><span class="cov0" title="0">{
                        query.WriteString(strings.Join(qb.selects, ", "))
                }</span> else<span class="cov0" title="0"> {
                        query.WriteString("*")
                }</span>
                <span class="cov0" title="0">query.WriteString(" FROM ")
                query.WriteString(qb.table)

                // Add subqueries
                for _, subquery := range qb.subqueries </span><span class="cov0" title="0">{
                        subquerySQL, subqueryArgs := subquery.Query.Build()
                        query.WriteString(fmt.Sprintf(" (%s) AS %s", subquerySQL, subquery.Alias))
                        args = append(args, subqueryArgs...)
                }</span>

                // Add CASE expressions
                <span class="cov0" title="0">for _, caseExpr := range qb.cases </span><span class="cov0" title="0">{
                        query.WriteString(fmt.Sprintf(" CASE %s", caseExpr.Field))
                        for when, then := range caseExpr.Cases </span><span class="cov0" title="0">{
                                query.WriteString(fmt.Sprintf(" WHEN %v THEN %v", when, then))
                        }</span>
                        <span class="cov0" title="0">if caseExpr.DefaultValue != nil </span><span class="cov0" title="0">{
                                query.WriteString(fmt.Sprintf(" ELSE %v", caseExpr.DefaultValue))
                        }</span>
                        <span class="cov0" title="0">query.WriteString(" END")</span>
                }

        case Count:<span class="cov0" title="0">
                query.WriteString("SELECT COUNT(*) FROM ")
                query.WriteString(qb.table)</span>

        case Insert:<span class="cov0" title="0">
                query.WriteString("INSERT INTO ")
                query.WriteString(qb.table)
                query.WriteString(" (")
                columns := make([]string, 0, len(qb.values))
                values := make([]interface{}, 0, len(qb.values))
                for column, value := range qb.values </span><span class="cov0" title="0">{
                        columns = append(columns, column)
                        values = append(values, value)
                }</span>
                <span class="cov0" title="0">query.WriteString(strings.Join(columns, ", "))
                query.WriteString(") VALUES (")
                placeholders := make([]string, len(columns))
                for i := range columns </span><span class="cov0" title="0">{
                        placeholders[i] = "?"
                }</span>
                <span class="cov0" title="0">query.WriteString(strings.Join(placeholders, ", "))
                query.WriteString(")")
                args = append(args, values...)
                return query.String(), args</span>

        case Update:<span class="cov0" title="0">
                query.WriteString("UPDATE ")
                query.WriteString(qb.table)
                query.WriteString(" SET ")
                setClause := make([]string, 0, len(qb.values))
                for field, value := range qb.values </span><span class="cov0" title="0">{
                        setClause = append(setClause, fmt.Sprintf("%s = ?", field))
                        args = append(args, value)
                }</span>
                <span class="cov0" title="0">query.WriteString(strings.Join(setClause, ", "))</span>

        case Delete:<span class="cov0" title="0">
                query.WriteString("DELETE FROM ")
                query.WriteString(qb.table)</span>
        }

        // Add joins
        <span class="cov0" title="0">if len(qb.joins) &gt; 0 </span><span class="cov0" title="0">{
                for _, join := range qb.joins </span><span class="cov0" title="0">{
                        query.WriteString(fmt.Sprintf(" %s", join))
                }</span>
        }

        // Add where conditions
        <span class="cov0" title="0">if len(qb.conditions) &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(" WHERE ")
                whereClause := make([]string, 0)
                for i, condition := range qb.conditions </span><span class="cov0" title="0">{
                        // İlk koşul değilse ve OR değilse, AND ekle
                        if i &gt; 0 &amp;&amp; !condition.Or </span><span class="cov0" title="0">{
                                whereClause = append(whereClause, "AND")
                        }</span> else<span class="cov0" title="0"> if i &gt; 0 &amp;&amp; condition.Or </span><span class="cov0" title="0">{
                                whereClause = append(whereClause, "OR")
                        }</span>

                        // Operatör tipine göre koşul oluştur
                        <span class="cov0" title="0">if condition.Operator == IsNull || condition.Operator == IsNotNull </span><span class="cov0" title="0">{
                                whereClause = append(whereClause, fmt.Sprintf("%s %s", condition.Field, condition.Operator))
                        }</span> else<span class="cov0" title="0"> {
                                whereClause = append(whereClause, fmt.Sprintf("%s %s ?", condition.Field, condition.Operator))
                                args = append(args, condition.Value)
                        }</span>
                }
                <span class="cov0" title="0">query.WriteString(strings.Join(whereClause, " "))</span>
        }

        // Add group by
        <span class="cov0" title="0">if len(qb.groupBy) &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(" GROUP BY ")
                query.WriteString(strings.Join(qb.groupBy, ", "))
        }</span>

        // Add having
        <span class="cov0" title="0">if qb.having != "" </span><span class="cov0" title="0">{
                query.WriteString(" HAVING ")
                query.WriteString(qb.having)
        }</span>

        // Add order by
        <span class="cov0" title="0">if len(qb.orderBy) &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(" ORDER BY ")
                query.WriteString(strings.Join(qb.orderBy, ", "))
        }</span>

        // Add limit and offset
        <span class="cov0" title="0">if qb.limit &gt; 0 </span><span class="cov0" title="0">{
                query.WriteString(fmt.Sprintf(" LIMIT %d", qb.limit))
                if qb.offset &gt; 0 </span><span class="cov0" title="0">{
                        query.WriteString(fmt.Sprintf(" OFFSET %d", qb.offset))
                }</span>
        }

        <span class="cov0" title="0">return query.String(), args</span>
}

// Helper functions for common queries

// FindByID constructs a query to find a record by ID
func (qb *QueryBuilder) FindByID(id interface{}) (string, []interface{}) <span class="cov0" title="0">{
        return qb.Where("id", Equal, id).Build()
}</span>

// FindByField constructs a query to find records by a field value
func (qb *QueryBuilder) FindByField(field string, value interface{}) (string, []interface{}) <span class="cov0" title="0">{
        return qb.Where(field, Equal, value).Build()
}</span>

// FindByFields constructs a query to find records by multiple field values
func (qb *QueryBuilder) FindByFields(fields map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        for field, value := range fields </span><span class="cov0" title="0">{
                qb.Where(field, Equal, value)
        }</span>
        <span class="cov0" title="0">return qb.Build()</span>
}

// Search constructs a query to search records
func (qb *QueryBuilder) Search(fields []string, term string) (string, []interface{}) <span class="cov0" title="0">{
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return qb.Build()
        }</span>

        <span class="cov0" title="0">conditions := make([]Condition, 0, len(fields))
        for _, field := range fields </span><span class="cov0" title="0">{
                conditions = append(conditions, Condition{
                        Field:    field,
                        Operator: Like,
                        Value:    "%" + term + "%",
                })
        }</span>

        <span class="cov0" title="0">qb.conditions = append(qb.conditions, conditions...)
        return qb.Build()</span>
}

// DateRange constructs a query to find records within a date range
func (qb *QueryBuilder) DateRange(field string, start, end time.Time) (string, []interface{}) <span class="cov0" title="0">{
        return qb.WhereBetween(field, start, end).Build()
}</span>

// Paginate constructs a query with pagination
func (qb *QueryBuilder) Paginate(page, perPage int) (string, []interface{}) <span class="cov0" title="0">{
        offset := (page - 1) * perPage
        return qb.Limit(perPage).Offset(offset).Build()
}</span>

// Filter constructs a query with filters
func (qb *QueryBuilder) Filter(filters map[string]interface{}) *QueryBuilder <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return qb
        }</span>

        <span class="cov0" title="0">for field, value := range filters </span><span class="cov0" title="0">{
                switch v := value.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        qb.WhereIn(field, v)</span>
                case string:<span class="cov0" title="0">
                        if strings.HasPrefix(v, "%") || strings.HasSuffix(v, "%") </span><span class="cov0" title="0">{
                                qb.Where(field, Like, v)
                        }</span> else<span class="cov0" title="0"> {
                                qb.Where(field, Equal, v)
                        }</span>
                default:<span class="cov0" title="0">
                        qb.Where(field, Equal, v)</span>
                }
        }
        <span class="cov0" title="0">return qb</span>
}

// Sort constructs a query with sorting
func (qb *QueryBuilder) Sort(field string, direction SortDirection) (string, []interface{}) <span class="cov0" title="0">{
        return qb.OrderBy(field, direction).Build()
}</span>

// BuildCount constructs a count query
func (qb *QueryBuilder) BuildCount() (string, []interface{}) <span class="cov0" title="0">{
        qb.queryType = Count
        return qb.Build()
}</span>

// BuildInsert constructs an insert query
func (qb *QueryBuilder) BuildInsert(data map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        qb.queryType = Insert
        qb.values = data
        return qb.Build()
}</span>

// BuildUpdate constructs an update query
func (qb *QueryBuilder) BuildUpdate(data map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        qb.queryType = Update
        qb.values = data
        return qb.Build()
}</span>

// BuildDelete constructs a delete query
func (qb *QueryBuilder) BuildDelete() (string, []interface{}) <span class="cov0" title="0">{
        qb.queryType = Delete
        return qb.Build()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package database

import (
        "reflect"
        "time"
)

// RepositoryWrapper wraps MySQLRepository to provide struct-based operations
type RepositoryWrapper struct {
        *MySQLRepository
}

// NewRepositoryWrapper creates a new repository wrapper
func NewRepositoryWrapper(repo *MySQLRepository) *RepositoryWrapper <span class="cov0" title="0">{
        return &amp;RepositoryWrapper{MySQLRepository: repo}
}</span>

// CreateStruct creates a record from a struct
func (r *RepositoryWrapper) CreateStruct(table string, data interface{}) (int64, error) <span class="cov0" title="0">{
        fields, values := r.structToFieldsAndValues(data)
        return r.MySQLRepository.Create(table, fields, values)
}</span>

// structToFieldsAndValues converts a struct to fields and values
func (r *RepositoryWrapper) structToFieldsAndValues(data interface{}) ([]string, []interface{}) <span class="cov0" title="0">{
        v := reflect.ValueOf(data)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov0" title="0">t := v.Type()
        var fields []string
        var values []interface{}

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                value := v.Field(i)

                // Skip ID field for creation
                if field.Name == "ID" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get db tag or use field name
                <span class="cov0" title="0">dbTag := field.Tag.Get("db")
                if dbTag == "" </span><span class="cov0" title="0">{
                        dbTag = field.Name
                }</span>

                <span class="cov0" title="0">fields = append(fields, dbTag)
                values = append(values, value.Interface())</span>
        }

        <span class="cov0" title="0">return fields, values</span>
}

// SimpleRepository interface for struct-based operations
type SimpleRepository interface {
        CreateStruct(table string, data interface{}) (int64, error)
        Update(table string, id interface{}, data interface{}) error
        Delete(table string, id interface{}) error
        FindByID(table string, id interface{}, result interface{}) error
        FindAll(table string, result interface{}, conditions map[string]interface{}, orderBy string, limit, offset int) error
        FindOne(table string, result interface{}, conditions map[string]interface{}) error
        Count(table string, conditions map[string]interface{}) (int64, error)
        Search(table string, fields []string, term string, limit, offset int, result interface{}) error
        FindByDateRange(table, dateField string, start, end time.Time, limit, offset int, result interface{}) error
        SetConnectionPool(maxOpen, maxIdle int, maxLifetime time.Duration)
        SoftDelete(table string, id interface{}) error
        BulkCreate(table string, data []interface{}) ([]int64, error)
        BulkUpdate(table string, ids []interface{}, data interface{}) error
        BulkDelete(table string, ids []interface{}) error
        Exists(table string, conditions map[string]interface{}) (bool, error)
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        "golang.org/x/crypto/bcrypt"
)

// Seed represents a database seed operation
type Seed struct {
        Name string
        Run  func(*sql.DB) error
}

// Seeder handles database seeding operations
type Seeder struct {
        db *sql.DB
}

// NewSeeder creates a new seeder
func NewSeeder(db *sql.DB) *Seeder <span class="cov0" title="0">{
        return &amp;Seeder{db: db}
}</span>

// ApplySeeds applies multiple seed operations
func (s *Seeder) ApplySeeds(seeds []Seed) error <span class="cov0" title="0">{
        // Create seeds table if it doesn't exist
        err := s.createSeedsTable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create seeds table: %w", err)
        }</span>

        <span class="cov0" title="0">for _, seed := range seeds </span><span class="cov0" title="0">{
                err := s.ApplySeed(seed)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createSeedsTable creates the seeds table if it doesn't exist
func (s *Seeder) createSeedsTable() error <span class="cov0" title="0">{
        // Bu işlem için doğrudan SQL kullanmak gerekiyor çünkü tablo oluşturma
        // işlemi için QueryBuilder'da uygun bir metod bulunmuyor
        query := `
        CREATE TABLE IF NOT EXISTS seeds (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(255) NOT NULL UNIQUE,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        stmt, err := s.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        _, err = stmt.Exec()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create seeds table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ApplySeed applies a single seed operation
func (s *Seeder) ApplySeed(seed Seed) error <span class="cov0" title="0">{
        // QueryBuilder kullanarak seed kontrolü yap
        qb := NewQueryBuilder("seeds")
        query, args := qb.Where("name", Equal, seed.Name).BuildCount()

        stmt, err := s.db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var count int64
        err = stmt.QueryRow(args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check seed status: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                // Seed already applied
                return nil
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>

        // Apply seed
        <span class="cov0" title="0">err = seed.Run(s.db)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to apply seed: %w", err)
        }</span>

        // QueryBuilder kullanarak seed kaydı ekle
        <span class="cov0" title="0">insertQb := NewQueryBuilder("seeds")
        insertQuery, insertArgs := insertQb.BuildInsert(map[string]interface{}{
                "name": seed.Name,
        })

        stmt, err = tx.Prepare(insertQuery)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to prepare insert statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        _, err = stmt.Exec(insertArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to record seed: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit seed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Applied seed: %s", seed.Name)
        return nil</span>
}

// CreateDefaultAdminUser creates a default admin user if no users exist
func CreateDefaultAdminUser(db *sql.DB) error <span class="cov0" title="0">{
        // QueryBuilder kullanarak kullanıcı kontrolü yap
        log.Printf("Checking for existing users...")
        qb := NewQueryBuilder("users")
        query, args := qb.BuildCount()

        stmt, err := db.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        var count int64
        err = stmt.QueryRow(args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check users: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                // Users already exist, skip
                log.Printf("Found %d existing users, skipping default admin creation", count)
                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("No users found in database, creating default admin user...")

        // Hash the default password
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // QueryBuilder kullanarak admin kullanıcısı ekle
        <span class="cov0" title="0">insertQb := NewQueryBuilder("users")
        insertQuery, insertArgs := insertQb.BuildInsert(map[string]interface{}{
                "name":      "Admin User",
                "email":     "admin@kolajAi.com",
                "password":  string(hashedPassword),
                "phone":     "05555555555",
                "is_active": 1,
                "is_admin":  1,
        })

        stmt, err = db.Prepare(insertQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare insert statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        result, err := stmt.Exec(insertArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create admin user: %w", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        log.Printf("Created default admin user with ID %d: admin@kolajAi.com / admin123", id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package email

import (
        "crypto/tls"
        "fmt"
)

// Config holds the email configuration
type Config struct {
        Host     string
        Port     int
        Username string
        Password string
        FromAddr string
        FromName string
        TLS      bool
        Debug    bool // Debug mode for local development
}

// NewConfig creates a new email configuration
func NewConfig(host string, port int, username, password, fromName, fromAddr string, useTLS bool) *Config <span class="cov0" title="0">{
        return &amp;Config{
                Host:     host,
                Port:     port,
                Username: username,
                Password: password,
                FromName: fromName,
                FromAddr: fromAddr,
                TLS:      useTLS,
        }
}</span>

// DefaultConfig returns a default email configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Host:     "ilkeraydogdu.com.tr",
                Port:     465,
                Username: "mail@ilkeraydogdu.com.tr",
                Password: "ilkN.2801",
                FromAddr: "mail@ilkeraydogdu.com.tr",
                FromName: "Pofuduk DİJİTAL",
                TLS:      true,
                Debug:    true,
        }
}</span>

// SMTPAddr returns the SMTP address with port
func (c *Config) SMTPAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Host, c.Port)
}</span>

// TLSConfig returns the TLS configuration
func (c *Config) TLSConfig() *tls.Config <span class="cov0" title="0">{
        return &amp;tls.Config{
                ServerName:         c.Host,
                InsecureSkipVerify: false, // Güvenlik için false yapıyoruz
                MinVersion:         tls.VersionTLS12,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package email

import (
        "bytes"
        "crypto/tls"
        "fmt"
        "html/template"
        "log"
        "net/smtp"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Service handles email sending operations
type Service struct {
        Config      *Config
        Templates   map[string]*template.Template
        TemplateDir string
}

// NewService creates a new email service
func NewService(config *Config, templateDir string) (*Service, error) <span class="cov0" title="0">{
        service := &amp;Service{
                Config:      config,
                Templates:   make(map[string]*template.Template),
                TemplateDir: templateDir,
        }

        // Load email templates
        err := service.LoadTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// LoadTemplates loads all email templates
func (s *Service) LoadTemplates() error <span class="cov0" title="0">{
        log.Printf("Loading internal email templates from: %s", s.TemplateDir)

        // Load base template
        baseTemplatePath := filepath.Join(s.TemplateDir, "email_template.gohtml")
        log.Printf("Loading base template from: %s", baseTemplatePath)
        baseTemplate, err := template.ParseFiles(baseTemplatePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to parse base email template: %v", err)
                return fmt.Errorf("failed to parse base email template: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Base template loaded successfully")

        // Load all template files
        templateFiles, err := filepath.Glob(filepath.Join(s.TemplateDir, "*.gohtml"))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to find email templates: %v", err)
                return fmt.Errorf("failed to find email templates: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Found %d template files", len(templateFiles))

        for _, file := range templateFiles </span><span class="cov0" title="0">{
                if file == baseTemplatePath </span><span class="cov0" title="0">{
                        log.Printf("Skipping base template: %s", file)
                        continue</span> // Skip base template
                }

                <span class="cov0" title="0">log.Printf("Loading template file: %s", file)
                name := filepath.Base(file)
                name = name[:len(name)-7] // Remove .gohtml
                log.Printf("Template name: %s", name)

                // Template içeriğini okuyorum
                content, err := os.ReadFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to read template file %s: %v", file, err)
                        return fmt.Errorf("failed to read email template %s: %w", name, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Template content: %s", string(content))

                // Yeni bir template oluşturup, base template'i kopyalıyorum
                newTemplate, err := template.Must(baseTemplate.Clone()).ParseFiles(file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse email template %s: %v", name, err)
                        return fmt.Errorf("failed to parse email template %s: %w", name, err)
                }</span>

                // Template'leri listeleyerek tanımları kontrol ediyorum
                <span class="cov0" title="0">templateNames := []string{}
                for _, t := range newTemplate.Templates() </span><span class="cov0" title="0">{
                        templateNames = append(templateNames, t.Name())
                }</span>
                <span class="cov0" title="0">log.Printf("Templates in %s: %v", name, templateNames)

                // Verify template has necessary templates defined
                if t := newTemplate.Lookup("email_template"); t == nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Template %s does not define 'email_template'", name)
                }</span>

                <span class="cov0" title="0">if t := newTemplate.Lookup("email_content"); t == nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Template %s does not define 'email_content'", name)
                }</span>

                <span class="cov0" title="0">s.Templates[name] = newTemplate
                log.Printf("Successfully loaded template: %s", name)</span>
        }

        // Log all available templates
        <span class="cov0" title="0">log.Printf("Loaded templates: %v", s.listTemplateNames())

        return nil</span>
}

// listTemplateNames returns all loaded template names
func (s *Service) listTemplateNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(s.Templates))
        for name := range s.Templates </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// SendEmail sends an email
func (s *Service) SendEmail(to, subject, body string) error <span class="cov0" title="0">{
        log.Printf("Sending email to: %s, subject: %s", to, subject)

        // Debug mode for local development
        if s.Config.Debug </span><span class="cov0" title="0">{
                log.Printf("DEBUG EMAIL:\nTo: %s\nSubject: %s\nBody: %s", to, subject, body)
                return nil
        }</span>

        // Create email data
        <span class="cov0" title="0">emailData := &amp;EmailData{
                To:      []string{to},
                Subject: subject,
        }

        // Add retry logic
        maxRetries := 3
        var lastErr error
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                err := s.sendMail(emailData, body)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">lastErr = err
                log.Printf("Attempt %d failed: %v", i+1, err)
                time.Sleep(time.Second * time.Duration(i+1))</span> // Exponential backoff
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to send email after %d attempts: %w", maxRetries, lastErr)</span>
}

// sendMail sends an email using SMTP
func (s *Service) sendMail(data *EmailData, body string) error <span class="cov0" title="0">{
        log.Printf("Attempting to connect to SMTP server: %s:%d", s.Config.Host, s.Config.Port)

        // Prepare email headers
        headers := make(map[string]string)
        headers["From"] = fmt.Sprintf("%s &lt;%s&gt;", s.Config.FromName, s.Config.FromAddr)
        headers["To"] = strings.Join(data.To, ", ")
        headers["Subject"] = data.Subject
        headers["MIME-Version"] = "1.0"
        headers["Content-Type"] = "text/html; charset=UTF-8"
        headers["Date"] = time.Now().Format(time.RFC1123Z)

        if len(data.CC) &gt; 0 </span><span class="cov0" title="0">{
                headers["Cc"] = strings.Join(data.CC, ", ")
        }</span>

        <span class="cov0" title="0">if len(data.BCC) &gt; 0 </span><span class="cov0" title="0">{
                headers["Bcc"] = strings.Join(data.BCC, ", ")
        }</span>

        // Prepare email message
        <span class="cov0" title="0">var message bytes.Buffer
        for k, v := range headers </span><span class="cov0" title="0">{
                message.WriteString(fmt.Sprintf("%s: %s\r\n", k, v))
        }</span>
        <span class="cov0" title="0">message.WriteString("\r\n")
        message.WriteString(body)

        // Create SMTP client with SSL/TLS
        tlsConfig := &amp;tls.Config{
                ServerName:         s.Config.Host,
                InsecureSkipVerify: true, // Kendinden imzalı sertifika için
        }

        // Create connection
        conn, err := tls.Dial("tcp", s.Config.SMTPAddr(), tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("TLS Connection Error: %v", err)
                return fmt.Errorf("TLS bağlantı hatası: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMTP client
        client, err := smtp.NewClient(conn, s.Config.Host)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Client Error: %v", err)
                return fmt.Errorf("SMTP istemci hatası: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Authenticate
        auth := smtp.PlainAuth("", s.Config.Username, s.Config.Password, s.Config.Host)
        if err = client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Authentication Error: %v", err)
                return fmt.Errorf("SMTP kimlik doğrulama hatası: %w", err)
        }</span>

        // Set sender
        <span class="cov0" title="0">if err = client.Mail(s.Config.FromAddr); err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Sender Error: %v", err)
                return fmt.Errorf("SMTP gönderici hatası: %w", err)
        }</span>

        // Set recipients
        <span class="cov0" title="0">recipients := append(data.To, append(data.CC, data.BCC...)...)
        for _, recipient := range recipients </span><span class="cov0" title="0">{
                if err = client.Rcpt(recipient); err != nil </span><span class="cov0" title="0">{
                        log.Printf("SMTP Recipient Error: %v", err)
                        return fmt.Errorf("SMTP alıcı hatası: %w", err)
                }</span>
        }

        // Send email body
        <span class="cov0" title="0">w, err := client.Data()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Data Error: %v", err)
                return fmt.Errorf("SMTP veri hatası: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = w.Write(message.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Write Error: %v", err)
                return fmt.Errorf("SMTP yazma hatası: %w", err)
        }</span>

        <span class="cov0" title="0">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SMTP Close Error: %v", err)
                return fmt.Errorf("SMTP kapatma hatası: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Email sent successfully to: %s", strings.Join(data.To, ", "))
        return nil</span>
}

// SendTemplateEmail sends an email using a template
func (s *Service) SendTemplateEmail(to, subject, templateName string, data map[string]interface{}) error <span class="cov0" title="0">{
        // Find template
        tmpl, exists := s.Templates[templateName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("email template '%s' not found", templateName)
        }</span>

        // Add standard data
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                data = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">data["Subject"] = subject
        data["Year"] = time.Now().Year()
        data["SiteName"] = "Pofuduk DİJİTAL"
        data["SiteURL"] = "https://pofudukdijital.com"

        // Render template
        var buffer bytes.Buffer

        // Email_template şablonunu doğrudan çalıştırıyoruz
        if err := tmpl.ExecuteTemplate(&amp;buffer, "email_template", data); err != nil </span><span class="cov0" title="0">{
                // Hata durumunda farklı bir yöntem dene - base template'i çağır
                log.Printf("Error executing template '%s': %v, trying Execute method", templateName, err)

                if err := tmpl.Execute(&amp;buffer, data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error with Execute method too: %v", err)
                        return fmt.Errorf("failed to render email template: %w", err)
                }</span>
        }

        // Email içeriğini alıyoruz
        <span class="cov0" title="0">renderedContent := buffer.String()

        // Debug modda template render sorununu tespit etmek için içeriği yazdır
        if s.Config.Debug </span><span class="cov0" title="0">{
                log.Printf("Template %s rendered to: %s", templateName, renderedContent)
        }</span>

        // Send email
        <span class="cov0" title="0">return s.SendEmail(to, subject, renderedContent)</span>
}

// SendStructuredEmail sends an email using EmailData struct
func (s *Service) SendStructuredEmailFromData(data *EmailData) error <span class="cov0" title="0">{
        // Debug mode for local development
        if s.Config.Debug </span><span class="cov0" title="0">{
                log.Printf("DEBUG EMAIL:\nTo: %s\nSubject: %s\nType: %s",
                        strings.Join(data.To, ", "), data.Subject, data.Type)
                return nil
        }</span>

        // Find template based on email type
        <span class="cov0" title="0">templateName := string(data.Type)
        tmpl, exists := s.Templates[templateName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("email template for type '%s' not found", data.Type)
        }</span>

        // Render template
        <span class="cov0" title="0">var buffer bytes.Buffer
        if err := tmpl.Execute(&amp;buffer, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to render email template: %w", err)
        }</span>

        // Send email
        <span class="cov0" title="0">return s.sendMail(data, buffer.String())</span>
}

// LogEmailSend logs an email send attempt to the database
func (s *Service) LogEmailSend(userID interface{}, to, subject, emailType, errorMsg string) error <span class="cov0" title="0">{
        // TODO: Implement database logging
        return nil
}</span>

// SendWelcomeEmail sends a welcome email
func (s *Service) SendWelcomeEmail(to, name string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "Name": name,
                "Year": time.Now().Year(),
        }
        return s.SendTemplateEmail(to, "Hoş Geldiniz - Pofuduk Dijital", "welcome", data)
}</span>

// SendPasswordResetEmail sends a password reset email
func (s *Service) SendPasswordResetEmail(to, name, resetLink string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "Name":      name,
                "ResetLink": resetLink,
                "Year":      time.Now().Year(),
        }
        return s.SendTemplateEmail(to, "Şifre Sıfırlama - Pofuduk Dijital", "password_reset", data)
}</span>

// SendVerificationEmail sends an account verification email
func (s *Service) SendVerificationEmail(to, name, verificationLink string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "Name":             name,
                "VerificationLink": verificationLink,
                "Year":             time.Now().Year(),
        }
        return s.SendTemplateEmail(to, "Hesap Doğrulama - Pofuduk Dijital", "verification", data)
}</span>

// SendPasswordChangedEmail sends a password changed notification
func (s *Service) SendPasswordChangedEmail(to, name string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "Name": name,
                "Year": time.Now().Year(),
        }
        return s.SendTemplateEmail(to, "Şifreniz Değiştirildi - Pofuduk Dijital", "password_changed", data)
}</span>

// SendCustomEmail sends a custom email using EmailData
func (s *Service) SendCustomEmail(data *EmailData) error <span class="cov0" title="0">{
        return s.SendStructuredEmailFromData(data)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package email

import "time"

// EmailType represents different types of emails
type EmailType string

const (
        EmailTypeWelcome         EmailType = "welcome"
        EmailTypePasswordReset   EmailType = "password_reset"
        EmailTypeVerification    EmailType = "verification"
        EmailTypePasswordChanged EmailType = "password_changed"
        EmailTypeInvoice         EmailType = "invoice"
        EmailTypeNotification    EmailType = "notification"
        EmailTypeMarketing       EmailType = "marketing"
)

// EmailPriority represents email priority
type EmailPriority int

const (
        PriorityLow    EmailPriority = 1
        PriorityNormal EmailPriority = 2
        PriorityHigh   EmailPriority = 3
)

// Attachment represents a file attachment for an email
type Attachment struct {
        Filename string
        Content  []byte
        MIMEType string
}

// SocialLink represents a social media link
type SocialLink struct {
        Name string
        URL  string
        Last bool
}

// ActionButton represents a call to action button
type ActionButton struct {
        Text string
        URL  string
        Type string // primary, success, danger, etc.
}

// AlertBox represents an alert box in the email
type AlertBox struct {
        Type    string // success, danger, warning, info
        Title   string
        Content string
}

// EmailData represents data for an email
type EmailData struct {
        // Core fields
        Type     EmailType
        To       []string
        CC       []string
        BCC      []string
        Subject  string
        Priority EmailPriority
        Name     string

        // Header customization
        CompanyName string
        HeaderLogo  string
        HeaderBg    string

        // Content fields
        Title            string
        Greeting         string
        Paragraphs       []string
        Features         []string
        FeatureIntro     string
        Alert            *AlertBox
        PrimaryAction    *ActionButton
        SecondaryContent interface{} // HTML içerik olarak kullanılabilir

        // Footer customization
        SupportEmail    string
        Signature       string
        SocialLinks     []SocialLink
        UnsubscribeLink string
        PrivacyLink     string

        // Advanced options
        CustomCSS   string
        Attachments []Attachment
        SendAt      time.Time
        Metadata    map[string]string
}

// NewEmailData creates a new EmailData with defaults
func NewEmailData(emailType EmailType, to []string, subject, name string) *EmailData <span class="cov0" title="0">{
        return &amp;EmailData{
                Type:         emailType,
                To:           to,
                Subject:      subject,
                Name:         name,
                Priority:     PriorityNormal,
                CompanyName:  "KolajAI | Pofuduk Dijital",
                SupportEmail: "destek@kolaj.ai",
        }
}</span>

// SetAlert adds an alert box to the email
func (d *EmailData) SetAlert(alertType, title, content string) *EmailData <span class="cov0" title="0">{
        d.Alert = &amp;AlertBox{
                Type:    alertType,
                Title:   title,
                Content: content,
        }
        return d
}</span>

// AddParagraph adds a paragraph to the email content
func (d *EmailData) AddParagraph(paragraph string) *EmailData <span class="cov0" title="0">{
        d.Paragraphs = append(d.Paragraphs, paragraph)
        return d
}</span>

// AddFeature adds a feature bullet point to the email
func (d *EmailData) AddFeature(feature string) *EmailData <span class="cov0" title="0">{
        d.Features = append(d.Features, feature)
        return d
}</span>

// SetPrimaryAction sets the primary call-to-action button
func (d *EmailData) SetPrimaryAction(text, url, buttonType string) *EmailData <span class="cov0" title="0">{
        d.PrimaryAction = &amp;ActionButton{
                Text: text,
                URL:  url,
                Type: buttonType,
        }
        return d
}</span>

// AddSocialLink adds a social media link to the email footer
func (d *EmailData) AddSocialLink(name, url string) *EmailData <span class="cov0" title="0">{
        d.SocialLinks = append(d.SocialLinks, SocialLink{
                Name: name,
                URL:  url,
                Last: false,
        })
        // Mark the last one as last
        if len(d.SocialLinks) &gt; 0 </span><span class="cov0" title="0">{
                for i := range d.SocialLinks </span><span class="cov0" title="0">{
                        d.SocialLinks[i].Last = (i == len(d.SocialLinks)-1)
                }</span>
        }
        <span class="cov0" title="0">return d</span>
}

// AddAttachment adds an attachment to the email
func (d *EmailData) AddAttachment(filename string, content []byte, mimeType string) *EmailData <span class="cov0" title="0">{
        d.Attachments = append(d.Attachments, Attachment{
                Filename: filename,
                Content:  content,
                MIMEType: mimeType,
        })
        return d
}</span>

// AddMetadata adds a metadata key-value pair
func (d *EmailData) AddMetadata(key, value string) *EmailData <span class="cov0" title="0">{
        if d.Metadata == nil </span><span class="cov0" title="0">{
                d.Metadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">d.Metadata[key] = value
        return d</span>
}

// GetCurrentYear returns the current year for copyright
func (d *EmailData) GetCurrentYear() int <span class="cov0" title="0">{
        return time.Now().Year()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "kolajAi/internal/models"
        "kolajAi/internal/services"
)

// AdminHandler handles admin-related requests
type AdminHandler struct {
        *Handler
        productService *services.ProductService
        vendorService  *services.VendorService
        orderService   *services.OrderService
        auctionService *services.AuctionService
}

// NewAdminHandler creates a new admin handler
func NewAdminHandler(h *Handler, productService *services.ProductService, vendorService *services.VendorService, orderService *services.OrderService, auctionService *services.AuctionService) *AdminHandler <span class="cov0" title="0">{
        return &amp;AdminHandler{
                Handler:        h,
                productService: productService,
                vendorService:  vendorService,
                orderService:   orderService,
                auctionService: auctionService,
        }
}</span>

// AdminDashboard shows the main admin dashboard
func (h *AdminHandler) AdminDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        // İstatistikler
        stats := make(map[string]interface{})

        // Ürün sayısı
        if productCount, err := h.productService.GetProductCount(); err == nil </span><span class="cov0" title="0">{
                stats["ProductCount"] = productCount
        }</span>

        // Satıcı sayısı
        <span class="cov0" title="0">if vendorCount, err := h.vendorService.GetVendorCount(); err == nil </span><span class="cov0" title="0">{
                stats["VendorCount"] = vendorCount
        }</span>

        // Aktif açık artırma sayısı
        <span class="cov0" title="0">if auctionCount, err := h.auctionService.GetActiveAuctionCount(); err == nil </span><span class="cov0" title="0">{
                stats["ActiveAuctionCount"] = auctionCount
        }</span>

        // Son eklenen ürünler
        <span class="cov0" title="0">if recentProducts, err := h.productService.GetRecentProducts(5); err == nil </span><span class="cov0" title="0">{
                stats["RecentProducts"] = recentProducts
        }</span>

        // Bekleyen satıcılar
        <span class="cov0" title="0">if pendingVendors, err := h.vendorService.GetPendingVendors(); err == nil </span><span class="cov0" title="0">{
                stats["PendingVendors"] = pendingVendors
        }</span>

        <span class="cov0" title="0">data["Stats"] = stats
        h.RenderTemplate(w, r, "admin/dashboard", data)</span>
}

// AdminProducts shows product management page
func (h *AdminHandler) AdminProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        page := 1
        if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(pageStr); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        page = p
                }</span>
        }
        <span class="cov0" title="0">limit := 20
        offset := (page - 1) * limit

        // Ürünleri getir
        products, err := h.productService.GetAllProducts(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Ürünler yüklenirken hata oluştu")
                return
        }</span>

        <span class="cov0" title="0">data["Products"] = products
        data["CurrentPage"] = page
        h.RenderTemplate(w, r, "admin/products", data)</span>
}

// AdminProductEdit shows product edit form
func (h *AdminHandler) AdminProductEdit(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">if r.Method == "GET" </span><span class="cov0" title="0">{
                h.showProductEditForm(w, r)
        }</span> else<span class="cov0" title="0"> if r.Method == "POST" </span><span class="cov0" title="0">{
                h.updateProduct(w, r)
        }</span>
}

func (h *AdminHandler) showProductEditForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.GetTemplateData()

        // Ürün ID'sini al
        idStr := r.URL.Path[len("/admin/products/edit/"):]
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Geçersiz ürün ID")
                return
        }</span>

        // Ürünü getir
        <span class="cov0" title="0">product, err := h.productService.GetProductByID(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Ürün bulunamadı")
                return
        }</span>

        // Kategorileri getir
        <span class="cov0" title="0">categories, err := h.productService.GetAllCategories()
        if err == nil </span><span class="cov0" title="0">{
                data["Categories"] = categories
        }</span>

        <span class="cov0" title="0">data["Product"] = product
        h.RenderTemplate(w, r, "admin/product_edit", data)</span>
}

func (h *AdminHandler) updateProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Ürün ID'sini al
        idStr := r.URL.Path[len("/admin/products/edit/"):]
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Geçersiz ürün ID")
                return
        }</span>

        // Form verilerini al
        <span class="cov0" title="0">product := &amp;models.Product{
                ID:          id,
                Name:        r.FormValue("name"),
                Description: r.FormValue("description"),
                ShortDesc:   r.FormValue("short_desc"),
                SKU:         r.FormValue("sku"),
                Status:      r.FormValue("status"),
                Tags:        r.FormValue("tags"),
        }

        // Fiyat
        if priceStr := r.FormValue("price"); priceStr != "" </span><span class="cov0" title="0">{
                if price, err := strconv.ParseFloat(priceStr, 64); err == nil </span><span class="cov0" title="0">{
                        product.Price = price
                }</span>
        }

        // Karşılaştırma fiyatı
        <span class="cov0" title="0">if comparePriceStr := r.FormValue("compare_price"); comparePriceStr != "" </span><span class="cov0" title="0">{
                if comparePrice, err := strconv.ParseFloat(comparePriceStr, 64); err == nil </span><span class="cov0" title="0">{
                        product.ComparePrice = comparePrice
                }</span>
        }

        // Stok
        <span class="cov0" title="0">if stockStr := r.FormValue("stock"); stockStr != "" </span><span class="cov0" title="0">{
                if stock, err := strconv.Atoi(stockStr); err == nil </span><span class="cov0" title="0">{
                        product.Stock = stock
                }</span>
        }

        // Kategori ID
        <span class="cov0" title="0">if categoryIDStr := r.FormValue("category_id"); categoryIDStr != "" </span><span class="cov0" title="0">{
                if categoryID, err := strconv.Atoi(categoryIDStr); err == nil </span><span class="cov0" title="0">{
                        product.CategoryID = categoryID
                }</span>
        }

        // Öne çıkan ürün
        <span class="cov0" title="0">product.IsFeatured = r.FormValue("is_featured") == "on"

        // Ürünü güncelle
        err = h.productService.UpdateProduct(id, product)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Ürün güncellenirken hata oluştu")
                return
        }</span>

        <span class="cov0" title="0">h.RedirectWithFlash(w, r, "/admin/products", "Ürün başarıyla güncellendi")</span>
}

// AdminVendors shows vendor management page
func (h *AdminHandler) AdminVendors(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        page := 1
        if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(pageStr); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        page = p
                }</span>
        }
        <span class="cov0" title="0">limit := 20
        offset := (page - 1) * limit

        // Satıcıları getir
        vendors, err := h.vendorService.GetAllVendors(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Satıcılar yüklenirken hata oluştu")
                return
        }</span>

        <span class="cov0" title="0">data["Vendors"] = vendors
        data["CurrentPage"] = page
        h.RenderTemplate(w, r, "admin/vendors", data)</span>
}

// AdminVendorApprove approves a vendor
func (h *AdminHandler) AdminVendorApprove(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">if r.Method != "POST" </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Satıcı ID'sini al
        <span class="cov0" title="0">idStr := r.FormValue("vendor_id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Geçersiz satıcı ID")
                return
        }</span>

        // Satıcıyı onayla
        <span class="cov0" title="0">err = h.vendorService.ApproveVendor(id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Satıcı onaylanırken hata oluştu")
                return
        }</span>

        <span class="cov0" title="0">h.RedirectWithFlash(w, r, "/admin/vendors", "Satıcı başarıyla onaylandı")</span>
}

// AdminSettings shows system settings
func (h *AdminHandler) AdminSettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAdmin(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Admin yetkisi gerekli")
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        // Sistem ayarları burada yüklenebilir
        settings := map[string]interface{}{
                "SiteName":        "KolajAI Marketplace",
                "MaintenanceMode": false,
                "MaxUploadSize":   "10MB",
                "DefaultCurrency": "TRY",
        }

        data["Settings"] = settings
        h.RenderTemplate(w, r, "admin/settings", data)</span>
}

// IsAdmin checks if the current user is an admin
func (h *Handler) IsAdmin(r *http.Request) bool <span class="cov0" title="0">{
        session, _ := h.SessionManager.GetSession(r)
        userID, ok := session.Values["user_id"]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">isAdmin, ok := session.Values["is_admin"]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return userID != nil &amp;&amp; isAdmin == true</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "kolajAi/internal/services"
)

// AIAnalyticsHandler handles advanced AI analytics requests
type AIAnalyticsHandler struct {
        *Handler
        analyticsService *services.AIAnalyticsService
}

// NewAIAnalyticsHandler creates a new AI analytics handler
func NewAIAnalyticsHandler(h *Handler, analyticsService *services.AIAnalyticsService) *AIAnalyticsHandler <span class="cov0" title="0">{
        return &amp;AIAnalyticsHandler{
                Handler:          h,
                analyticsService: analyticsService,
        }
}</span>

// GetMarketTrends returns market trend analysis
func (h *AIAnalyticsHandler) GetMarketTrends(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get market trends
        <span class="cov0" title="0">trends, err := h.analyticsService.AnalyzeMarketTrends()
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting market trends: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "trends":  trends,
                "count":   len(trends),
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding market trends response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetProductInsights returns detailed product insights
func (h *AIAnalyticsHandler) GetProductInsights(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Extract product ID from URL path
        <span class="cov0" title="0">productIDStr := r.URL.Path[len("/api/ai/product-insights/"):]
        productID, err := strconv.Atoi(productIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid product ID", http.StatusBadRequest)
                return
        }</span>

        // Get product insights
        <span class="cov0" title="0">insights, err := h.analyticsService.AnalyzeProductInsights(productID)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting product insights for product %d: %v", productID, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":  true,
                "insights": insights,
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding product insights response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetCustomerSegments returns customer segmentation analysis
func (h *AIAnalyticsHandler) GetCustomerSegments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get customer segments
        <span class="cov0" title="0">segments, err := h.analyticsService.AnalyzeCustomerSegments()
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting customer segments: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":  true,
                "segments": segments,
                "count":    len(segments),
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding customer segments response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetPricingStrategy returns AI-powered pricing recommendations
func (h *AIAnalyticsHandler) GetPricingStrategy(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Extract product ID from URL path
        <span class="cov0" title="0">productIDStr := r.URL.Path[len("/api/ai/pricing-strategy/"):]
        productID, err := strconv.Atoi(productIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid product ID", http.StatusBadRequest)
                return
        }</span>

        // Get pricing strategy
        <span class="cov0" title="0">strategy, err := h.analyticsService.GeneratePricingStrategy(productID)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting pricing strategy for product %d: %v", productID, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":  true,
                "strategy": strategy,
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding pricing strategy response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetAnalyticsDashboard renders the AI analytics dashboard page
func (h *AIAnalyticsHandler) GetAnalyticsDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check authentication
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["PageTitle"] = "AI Analytics Dashboard"
        data["PageDescription"] = "Gelişmiş AI analitikleri ve pazar içgörüleri"

        // Get some sample data for the dashboard
        trends, err := h.analyticsService.AnalyzeMarketTrends()
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting market trends for dashboard: %v", err)
                trends = make([]*services.MarketTrend, 0)
        }</span>

        <span class="cov0" title="0">segments, err := h.analyticsService.AnalyzeCustomerSegments()
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting customer segments for dashboard: %v", err)
                segments = make([]*services.CustomerSegment, 0)
        }</span>

        <span class="cov0" title="0">data["MarketTrends"] = trends
        data["CustomerSegments"] = segments

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/analytics-dashboard", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering analytics dashboard template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetMarketTrendsPage renders the market trends analysis page
func (h *AIAnalyticsHandler) GetMarketTrendsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check authentication
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["PageTitle"] = "Pazar Trend Analizi"
        data["PageDescription"] = "AI destekli pazar trend analizi ve tahminleri"

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/market-trends", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering market trends template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetProductInsightsPage renders the product insights page
func (h *AIAnalyticsHandler) GetProductInsightsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check authentication
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["PageTitle"] = "Ürün İçgörüleri"
        data["PageDescription"] = "AI destekli ürün performans analizi ve öneriler"

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/product-insights", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering product insights template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetCustomerSegmentsPage renders the customer segments analysis page
func (h *AIAnalyticsHandler) GetCustomerSegmentsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check authentication
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["PageTitle"] = "Müşteri Segmentasyonu"
        data["PageDescription"] = "AI destekli müşteri davranış analizi ve segmentasyon"

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/customer-segments", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering customer segments template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetPricingStrategyPage renders the pricing strategy page
func (h *AIAnalyticsHandler) GetPricingStrategyPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check authentication
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["PageTitle"] = "Fiyatlandırma Stratejisi"
        data["PageDescription"] = "AI destekli fiyat optimizasyonu ve strateji önerileri"

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/pricing-strategy", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering pricing strategy template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "kolajAi/internal/models"
        "kolajAi/internal/services"
)

// AIHandler handles AI-related requests
type AIHandler struct {
        *Handler
        aiService *services.AIService
}

// NewAIHandler creates a new AI handler
func NewAIHandler(h *Handler, aiService *services.AIService) *AIHandler <span class="cov0" title="0">{
        return &amp;AIHandler{
                Handler:   h,
                aiService: aiService,
        }
}</span>

// getUserFromSession is a helper function to get user from session
func (h *AIHandler) getUserFromSession(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not authenticated")
        }</span>

        <span class="cov0" title="0">session, err := h.SessionManager.GetSession(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        <span class="cov0" title="0">userInterface, ok := session.Values[UserKey]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found in session")
        }</span>

        <span class="cov0" title="0">user, ok := userInterface.(*models.User)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user data")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetRecommendations returns personalized product recommendations for a user
func (h *AIHandler) GetRecommendations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">user, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Parse limit parameter
        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        limit := 12 // Default limit
        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 50 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        // Get recommendations
        <span class="cov0" title="0">recommendations, err := h.aiService.GetPersonalizedRecommendations(int(user.ID), limit)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting recommendations for user %d: %v", int(user.ID), err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":         true,
                "recommendations": recommendations,
                "count":           len(recommendations),
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding recommendations response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// OptimizePrice provides AI-powered price optimization for a product
func (h *AIHandler) OptimizePrice(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">_, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Parse product ID from URL
        <span class="cov0" title="0">pathParts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
        if len(pathParts) &lt; 3 </span><span class="cov0" title="0">{
                http.Error(w, "Product ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">productID, err := strconv.Atoi(pathParts[2])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid product ID", http.StatusBadRequest)
                return
        }</span>

        // Get price optimization
        <span class="cov0" title="0">optimization, err := h.aiService.OptimizeProductPricing(productID)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error optimizing price for product %d: %v", productID, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":      true,
                "optimization": optimization,
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding price optimization response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// PredictCategory predicts product category based on name and description
func (h *AIHandler) PredictCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">_, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var request struct {
                ProductName string `json:"product_name"`
                Description string `json:"description"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(request.ProductName) == "" </span><span class="cov0" title="0">{
                http.Error(w, "Product name is required", http.StatusBadRequest)
                return
        }</span>

        // Get category predictions
        <span class="cov0" title="0">predictions, err := h.aiService.PredictProductCategory(request.ProductName, request.Description)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error predicting category for product '%s': %v", request.ProductName, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success":     true,
                "predictions": predictions,
                "count":       len(predictions),
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding category prediction response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// SmartSearch performs AI-enhanced product search
func (h *AIHandler) SmartSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get search parameters
        <span class="cov0" title="0">query := strings.TrimSpace(r.URL.Query().Get("q"))
        if query == "" </span><span class="cov0" title="0">{
                http.Error(w, "Search query is required", http.StatusBadRequest)
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 20 // Default limit
        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">offset := 0 // Default offset
        if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        // Perform smart search
        <span class="cov0" title="0">searchResult, err := h.aiService.SmartSearch(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error performing smart search for query '%s': %v", query, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "result":  searchResult,
        }); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error encoding smart search response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetAIDashboard shows the AI dashboard page
func (h *AIHandler) GetAIDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">user, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["User"] = user
        data["PageTitle"] = "AI Dashboard - KolajAI"
        data["PageDescription"] = "AI-powered insights and recommendations for your marketplace experience"

        // Get some sample recommendations for display
        recommendations, err := h.aiService.GetPersonalizedRecommendations(int(user.ID), 6)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting recommendations for dashboard: %v", err)
                recommendations = make([]*services.ProductRecommendation, 0)
        }</span>
        <span class="cov0" title="0">data["Recommendations"] = recommendations

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/dashboard", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering AI dashboard template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetRecommendationsPage shows the recommendations page
func (h *AIHandler) GetRecommendationsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">user, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        limit := 24 // Default limit
        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        // Get recommendations
        <span class="cov0" title="0">recommendations, err := h.aiService.GetPersonalizedRecommendations(int(user.ID), limit)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error getting recommendations: %v", err)
                recommendations = make([]*services.ProductRecommendation, 0)
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["User"] = user
        data["PageTitle"] = "Kişisel Öneriler - KolajAI"
        data["PageDescription"] = "Size özel AI destekli ürün önerileri"
        data["Recommendations"] = recommendations
        data["RecommendationCount"] = len(recommendations)

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/recommendations", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering recommendations template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetPriceOptimizationPage shows the price optimization page for vendors
func (h *AIHandler) GetPriceOptimizationPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get user from session
        <span class="cov0" title="0">user, err := h.getUserFromSession(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := h.GetTemplateData()
        data["User"] = user
        data["PageTitle"] = "Fiyat Optimizasyonu - KolajAI"
        data["PageDescription"] = "AI destekli fiyat optimizasyon önerileri"

        // Render template
        if err := h.Templates.ExecuteTemplate(w, "ai/price-optimization", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering price optimization template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetSmartSearchPage shows the enhanced search page
func (h *AIHandler) GetSmartSearchPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get search query
        <span class="cov0" title="0">query := strings.TrimSpace(r.URL.Query().Get("q"))

        // Prepare template data
        data := h.GetTemplateData()
        data["PageTitle"] = "Akıllı Arama - KolajAI"
        data["PageDescription"] = "AI destekli gelişmiş ürün arama"
        data["SearchQuery"] = query

        // If there's a query, perform search
        if query != "" </span><span class="cov0" title="0">{
                searchResult, err := h.aiService.SmartSearch(query, 24, 0)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Printf("Error performing smart search: %v", err)
                        data["SearchError"] = "Arama sırasında bir hata oluştu"
                }</span> else<span class="cov0" title="0"> {
                        data["SearchResult"] = searchResult
                }</span>
        }

        // Render template
        <span class="cov0" title="0">if err := h.Templates.ExecuteTemplate(w, "ai/smart-search", data); err != nil </span><span class="cov0" title="0">{
                Logger.Printf("Error rendering smart search template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "os"
)

var (
        AuthLogger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Auth işlemleri için log dosyası oluştur
        logFile, err := os.OpenFile("auth_ops_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Auth log dosyası oluşturulamadı:", err)
                AuthLogger = log.New(os.Stdout, "[AUTH-OPS-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                AuthLogger = log.New(logFile, "[AUTH-OPS-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

// Login handles the login request
func (h *Handler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AuthLogger.Printf("Login handler çağrıldı: Method=%s, URL=%s", r.Method, r.URL.Path)

        // Tüm çerezleri logla
        AuthLogger.Printf("Login - Request'teki tüm çerezler:")
        for _, cookie := range r.Cookies() </span><span class="cov0" title="0">{
                AuthLogger.Printf("- Çerez: %s=%s, Path=%s, MaxAge=%d", cookie.Name, cookie.Value, cookie.Path, cookie.MaxAge)
        }</span>

        // Eğer kullanıcı zaten oturum açmışsa, anasayfaya yönlendir
        <span class="cov0" title="0">if h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                AuthLogger.Printf("Login - Kullanıcı zaten oturum açmış, dashboard'a yönlendiriliyor")
                http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
                return
        }</span>

        // POST isteği için giriş işlemi
        <span class="cov0" title="0">if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                AuthLogger.Printf("Login - POST isteği alındı, giriş yapılmaya çalışılıyor")

                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        AuthLogger.Printf("Login - Form parse hatası: %v", err)
                        h.RedirectWithFlash(w, r, "/login", "Form işlenirken hata oluştu")
                        return
                }</span>

                <span class="cov0" title="0">email := r.FormValue("email")
                password := r.FormValue("password")

                AuthLogger.Printf("Login - Giriş denemesi: Email=%s", email)

                // Basitleştirilmiş kimlik doğrulama (gerçek uygulamada veritabanı sorgusu ile doğrulama yapılmalı)
                // Not: Bu örnek sadece demo amaçlıdır, gerçek uygulamalarda güvenli kimlik doğrulama kullanılmalıdır
                if email == "admin@example.com" &amp;&amp; password == "password" </span><span class="cov0" title="0">{
                        AuthLogger.Printf("Login - Başarılı giriş: %s", email)

                        // Kullanıcı bilgilerini oluştur
                        user := struct {
                                ID    int64
                                Email string
                                Name  string
                        }{
                                ID:    1,
                                Email: email,
                                Name:  "Admin User",
                        }

                        // Oturum oluştur
                        err := h.SessionManager.SetSession(w, r, "user", user)
                        if err != nil </span><span class="cov0" title="0">{
                                AuthLogger.Printf("Login - Oturum oluşturma hatası: %v", err)
                                h.RedirectWithFlash(w, r, "/login", "Oturum oluşturulurken hata oluştu")
                                return
                        }</span>

                        <span class="cov0" title="0">AuthLogger.Printf("Login - Oturum başarıyla oluşturuldu, dashboard'a yönlendiriliyor")
                        http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
                        return</span>
                }

                // Hatalı giriş
                <span class="cov0" title="0">AuthLogger.Printf("Login - Hatalı giriş denemesi: %s", email)
                h.RedirectWithFlash(w, r, "/login", "Hatalı e-posta veya şifre")
                return</span>
        }

        // GET isteği için giriş sayfasını göster
        <span class="cov0" title="0">AuthLogger.Printf("Login - GET isteği, login sayfası gösteriliyor")

        data := map[string]interface{}{
                "Title":          "Giriş - KolajAI",
                "PageHeading":    "Giriş Yap",
                "PageSubHeading": "Hesabınıza giriş yapın ve işlemlerinize devam edin!",
        }

        // Şablonu render et
        h.RenderTemplate(w, r, "auth/login", data)</span>
}

// Logout logs out the user
func (h *Handler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AuthLogger.Printf("Logout handler çağrıldı: Method=%s, URL=%s", r.Method, r.URL.Path)

        // Tüm çerezleri temizle
        AuthLogger.Printf("Logout - Tüm çerezler temizleniyor")
        h.SessionManager.CleanupAllCookies(w, r)

        // Oturumu temizle
        err := h.SessionManager.ClearSession(w, r)
        if err != nil </span><span class="cov0" title="0">{
                AuthLogger.Printf("Logout - Oturum temizleme hatası: %v", err)
        }</span> else<span class="cov0" title="0"> {
                AuthLogger.Printf("Logout - Oturum başarıyla temizlendi")
        }</span>

        // Kullanıcıyı login sayfasına yönlendir
        <span class="cov0" title="0">AuthLogger.Printf("Logout - Kullanıcı login sayfasına yönlendiriliyor")
        h.RedirectWithFlash(w, r, "/login", "Başarıyla çıkış yapıldı")</span>
}

// ForgotPassword handles the forgot password request
func (h *Handler) ForgotPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AuthLogger.Printf("ForgotPassword handler çağrıldı: Method=%s", r.Method)

        if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                AuthLogger.Printf("ForgotPassword - POST isteği alındı")

                // Form verilerini al
                email := r.FormValue("email")
                AuthLogger.Printf("ForgotPassword - İstek email: %s", email)

                // Kullanıcı var mı kontrol et (gerçek uygulamada veritabanı sorgusu ile yapılmalı)
                if email != "" </span><span class="cov0" title="0">{
                        AuthLogger.Printf("ForgotPassword - Sıfırlama bağlantısı gönderildi (simüle): %s", email)
                        h.RedirectWithFlash(w, r, "/login", "Şifre sıfırlama bağlantısı e-posta adresinize gönderildi")
                        return
                }</span>

                <span class="cov0" title="0">AuthLogger.Printf("ForgotPassword - Geçersiz e-posta")
                h.RedirectWithFlash(w, r, "/forgot-password", "Geçersiz e-posta adresi")
                return</span>
        }

        <span class="cov0" title="0">AuthLogger.Printf("ForgotPassword - GET isteği, şifre sıfırlama sayfası gösteriliyor")

        data := map[string]interface{}{
                "Title":          "Şifremi Unuttum - KolajAI",
                "PageHeading":    "Şifremi Unuttum",
                "PageSubHeading": "Şifrenizi sıfırlamak için e-posta adresinizi girin!",
        }

        h.RenderTemplate(w, r, "auth/forgot-password", data)</span>
}

// ResetPassword handles the password reset process
func (h *Handler) ResetPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AuthLogger.Printf("ResetPassword handler çağrıldı: Method=%s", r.Method)

        if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                AuthLogger.Printf("ResetPassword - POST isteği alındı")

                // Form verilerini al
                email := r.FormValue("email")
                password := r.FormValue("password")
                confirmPassword := r.FormValue("confirm_password")

                AuthLogger.Printf("ResetPassword - İstek email: %s", email)

                // Şifrelerin eşleştiğini kontrol et
                if password != confirmPassword </span><span class="cov0" title="0">{
                        AuthLogger.Printf("ResetPassword - Şifreler eşleşmiyor")
                        h.RedirectWithFlash(w, r, fmt.Sprintf("/reset-password?email=%s", email), "Şifreler eşleşmiyor")
                        return
                }</span>

                // Şifre değiştirme işlemi (gerçek uygulamada veritabanı güncellemesi yapılmalı)
                <span class="cov0" title="0">AuthLogger.Printf("ResetPassword - Şifre başarıyla değiştirildi (simüle): %s", email)
                h.RedirectWithFlash(w, r, "/login", "Şifreniz başarıyla değiştirildi. Şimdi giriş yapabilirsiniz.")
                return</span>
        }

        // GET isteği için şifre sıfırlama sayfasını göster
        <span class="cov0" title="0">email := r.URL.Query().Get("email")
        token := r.URL.Query().Get("token")

        AuthLogger.Printf("ResetPassword - GET isteği, email=%s, token=%s", email, token)

        // Email parametresi kontrolü
        if email == "" </span><span class="cov0" title="0">{
                AuthLogger.Printf("ResetPassword - Email parametresi eksik, giriş sayfasına yönlendiriliyor")
                h.RedirectWithFlash(w, r, "/login", "Geçersiz şifre sıfırlama bağlantısı")
                return
        }</span>

        // Token kontrolü (gerçek uygulamada veritabanı sorgusu ile doğrulanmalı)
        // Bu örnekte token kontrolünü atlıyoruz

        <span class="cov0" title="0">data := map[string]interface{}{
                "Title":          "Şifre Sıfırla - KolajAI",
                "PageHeading":    "Yeni Şifre Oluştur",
                "PageSubHeading": "Şifre sıfırlama talebinizi aldık. Lütfen yeni şifrenizi girin!",
                "Email":          email,
        }

        AuthLogger.Printf("ResetPassword - Şifre sıfırlama sayfası gösteriliyor: %s", email)
        h.RenderTemplate(w, r, "auth/reset-password", data)</span>
}

// Register handles the user registration process
func (h *Handler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AuthLogger.Printf("Register handler çağrıldı: Method=%s", r.Method)

        if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                AuthLogger.Printf("Register - POST isteği alındı")

                // Form verilerini al
                name := r.FormValue("name")
                email := r.FormValue("email")
                password := r.FormValue("password")

                AuthLogger.Printf("Register - Kayıt denemesi: Name=%s, Email=%s", name, email)

                // Basit doğrulama
                if name == "" || email == "" || password == "" </span><span class="cov0" title="0">{
                        AuthLogger.Printf("Register - Eksik form verileri")
                        h.RedirectWithFlash(w, r, "/register", "Lütfen tüm alanları doldurun")
                        return
                }</span>

                // Kullanıcı kaydı (gerçek uygulamada veritabanına kayıt yapılmalı)
                // Bu örnek sadece demo amaçlıdır
                <span class="cov0" title="0">AuthLogger.Printf("Register - Kullanıcı başarıyla kaydedildi (simüle): %s", email)
                h.RedirectWithFlash(w, r, "/login", "Kaydınız başarıyla tamamlandı. Şimdi giriş yapabilirsiniz.")
                return</span>
        }

        // GET isteği için kayıt sayfasını göster
        <span class="cov0" title="0">AuthLogger.Printf("Register - GET isteği, kayıt sayfası gösteriliyor")

        data := map[string]interface{}{
                "Title":          "Kayıt Ol - KolajAI",
                "PageHeading":    "Hesap Oluştur",
                "PageSubHeading": "Yeni bir hesap oluşturmak için lütfen bilgilerinizi girin!",
        }

        h.RenderTemplate(w, r, "auth/register", data)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "net/http"
)

// ComponentsExample renders the components example page
func (h *Handler) ComponentsExample(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "title":       "UI Bileşen Örnekleri",
                "description": "KolajAI Uygulaması UI Bileşen Örnekleri",
                "app_name":    "KolajAI",
                "version":     "1.0.0",
        }

        h.RenderTemplate(w, r, "components/example", data)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "log"
        "net/http"
        "os"
)

var (
        DashboardLogger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Dashboard için log dosyası oluştur
        logFile, err := os.OpenFile("dashboard_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Dashboard log dosyası oluşturulamadı:", err)
                DashboardLogger = log.New(os.Stdout, "[DASHBOARD-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                DashboardLogger = log.New(logFile, "[DASHBOARD-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

// Dashboard handles the dashboard page
func (h *Handler) Dashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        DashboardLogger.Printf("Dashboard handler çağrıldı: Method=%s, URL=%s", r.Method, r.URL.Path)

        // Tüm çerezleri logla
        DashboardLogger.Printf("Dashboard - Request'teki tüm çerezler:")
        for _, cookie := range r.Cookies() </span><span class="cov0" title="0">{
                DashboardLogger.Printf("- Çerez: %s=%s, Path=%s, MaxAge=%d", cookie.Name, cookie.Value, cookie.Path, cookie.MaxAge)
        }</span>

        // Kimlik doğrulaması kontrolü
        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                DashboardLogger.Printf("Dashboard - Kullanıcı kimliği doğrulanmamış, login sayfasına yönlendiriliyor")
                h.RedirectWithFlash(w, r, "/login", "Lütfen önce giriş yapın")
                return
        }</span>

        // Şablonu render et
        <span class="cov0" title="0">DashboardLogger.Printf("Dashboard - Kimlik doğrulanmış, dashboard sayfası gösteriliyor")
        h.RenderTemplate(w, r, "dashboard/index", map[string]interface{}{
                "Title": "Dashboard - KolajAI",
        })</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "kolajAi/internal/models"
        "kolajAi/internal/services"
)

// EcommerceHandler handles e-commerce related requests
type EcommerceHandler struct {
        *Handler
        vendorService  *services.VendorService
        productService *services.ProductService
        orderService   *services.OrderService
        auctionService *services.AuctionService
}

// NewEcommerceHandler creates a new e-commerce handler
func NewEcommerceHandler(h *Handler, vendorService *services.VendorService, productService *services.ProductService, orderService *services.OrderService, auctionService *services.AuctionService) *EcommerceHandler <span class="cov0" title="0">{
        return &amp;EcommerceHandler{
                Handler:        h,
                vendorService:  vendorService,
                productService: productService,
                orderService:   orderService,
                auctionService: auctionService,
        }
}</span>

// Marketplace - Ana sayfa
func (h *EcommerceHandler) Marketplace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.GetTemplateData()

        // Öne çıkan ürünler
        featuredProducts, err := h.productService.GetFeaturedProducts(12, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["FeaturedProducts"] = featuredProducts
        }</span>

        // Kategoriler
        <span class="cov0" title="0">categories, err := h.productService.GetAllCategories()
        if err == nil </span><span class="cov0" title="0">{
                data["Categories"] = categories
        }</span>

        // Aktif açık artırmalar
        <span class="cov0" title="0">activeAuctions, err := h.auctionService.GetActiveAuctions(6, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["ActiveAuctions"] = activeAuctions
        }</span>

        <span class="cov0" title="0">h.RenderTemplate(w, r, "marketplace/index", data)</span>
}

// Products - Ürün listesi
func (h *EcommerceHandler) Products(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.GetTemplateData()

        // Query parametreleri
        categoryID := r.URL.Query().Get("category")
        search := r.URL.Query().Get("search")
        page := h.getPageFromQuery(r)
        limit := 20
        offset := (page - 1) * limit

        var products []models.Product
        var err error

        if search != "" </span><span class="cov0" title="0">{
                products, err = h.productService.SearchProducts(search, limit, offset)
                data["SearchTerm"] = search
        }</span> else<span class="cov0" title="0"> if categoryID != "" </span><span class="cov0" title="0">{
                catID, _ := strconv.Atoi(categoryID)
                products, err = h.productService.GetProductsByCategory(catID, limit, offset)

                // Kategori bilgisi
                if catID &gt; 0 </span><span class="cov0" title="0">{
                        category, catErr := h.productService.GetCategoryByID(catID)
                        if catErr == nil </span><span class="cov0" title="0">{
                                data["Category"] = category
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Tüm aktif ürünler (bu fonksiyon ProductService'e eklenmeli)
                products, err = h.productService.GetFeaturedProducts(limit, offset)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Ürünler yüklenirken hata oluştu")
                return
        }</span>

        // Kategoriler
        <span class="cov0" title="0">categories, err := h.productService.GetAllCategories()
        if err == nil </span><span class="cov0" title="0">{
                data["Categories"] = categories
        }</span>

        <span class="cov0" title="0">data["Products"] = products
        data["CurrentPage"] = page
        h.RenderTemplate(w, r, "marketplace/products", data)</span>
}

// ProductDetail - Ürün detayı
func (h *EcommerceHandler) ProductDetail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        productIDStr := strings.TrimPrefix(r.URL.Path, "/product/")
        productID, err := strconv.Atoi(productIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        // Ürün bilgisi
        product, err := h.productService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        // Görüntülenme sayısını artır
        <span class="cov0" title="0">go h.productService.IncrementProductViews(productID)

        // Ürün resimleri
        images, err := h.productService.GetProductImages(productID)
        if err == nil </span><span class="cov0" title="0">{
                data["ProductImages"] = images
        }</span>

        // Ürün yorumları
        <span class="cov0" title="0">reviews, err := h.productService.GetProductReviews(productID, 10, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["ProductReviews"] = reviews
        }</span>

        // Satıcı bilgisi
        <span class="cov0" title="0">vendor, err := h.vendorService.GetVendorByID(product.VendorID)
        if err == nil </span><span class="cov0" title="0">{
                data["Vendor"] = vendor
        }</span>

        // Benzer ürünler
        <span class="cov0" title="0">similarProducts, err := h.productService.GetProductsByCategory(product.CategoryID, 4, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["SimilarProducts"] = similarProducts
        }</span>

        <span class="cov0" title="0">data["Product"] = product
        h.RenderTemplate(w, r, "marketplace/product-detail", data)</span>
}

// AddToCart - Sepete ekleme
func (h *EcommerceHandler) AddToCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Form verilerini al
        <span class="cov0" title="0">productID, _ := strconv.Atoi(r.FormValue("product_id"))
        quantity, _ := strconv.Atoi(r.FormValue("quantity"))
        if quantity &lt;= 0 </span><span class="cov0" title="0">{
                quantity = 1
        }</span>

        // Ürün bilgisini al
        <span class="cov0" title="0">product, err := h.productService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                h.SetFlashError("Ürün bulunamadı")
                http.Redirect(w, r, "/products", http.StatusSeeOther)
                return
        }</span>

        // Stok kontrolü
        <span class="cov0" title="0">if product.Stock &lt; quantity </span><span class="cov0" title="0">{
                h.SetFlashError("Yeterli stok bulunmamaktadır")
                http.Redirect(w, r, fmt.Sprintf("/product/%d", productID), http.StatusSeeOther)
                return
        }</span>

        // Sepeti al veya oluştur
        <span class="cov0" title="0">var cart *models.Cart
        userID := h.GetUserID(r)

        if userID &gt; 0 </span><span class="cov0" title="0">{
                cart, err = h.orderService.GetCartByUser(userID)
                if err != nil </span><span class="cov0" title="0">{
                        // Yeni sepet oluştur
                        cart = &amp;models.Cart{UserID: userID}
                        err = h.orderService.CreateCart(cart)
                        if err != nil </span><span class="cov0" title="0">{
                                h.HandleError(w, r, err, "Sepet oluşturulamadı")
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Session tabanlı sepet
                sessionID := h.GetSessionID(r)
                cart, err = h.orderService.GetCartBySession(sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        cart = &amp;models.Cart{SessionID: sessionID}
                        err = h.orderService.CreateCart(cart)
                        if err != nil </span><span class="cov0" title="0">{
                                h.HandleError(w, r, err, "Sepet oluşturulamadı")
                                return
                        }</span>
                }
        }

        // Sepete ürün ekle
        <span class="cov0" title="0">cartItem := &amp;models.CartItem{
                CartID:    cart.ID,
                ProductID: productID,
                Quantity:  quantity,
                Price:     product.Price,
        }

        err = h.orderService.AddCartItem(cartItem)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Ürün sepete eklenemedi")
                return
        }</span>

        <span class="cov0" title="0">h.SetFlashSuccess("Ürün sepete eklendi")
        http.Redirect(w, r, "/cart", http.StatusSeeOther)</span>
}

// Cart - Sepet görüntüleme
func (h *EcommerceHandler) Cart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.GetTemplateData()

        // Sepeti al
        var cart *models.Cart
        var err error
        userID := h.GetUserID(r)

        if userID &gt; 0 </span><span class="cov0" title="0">{
                cart, err = h.orderService.GetCartByUser(userID)
        }</span> else<span class="cov0" title="0"> {
                sessionID := h.GetSessionID(r)
                cart, err = h.orderService.GetCartBySession(sessionID)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                data["CartItems"] = []models.CartItem{}
                data["CartTotal"] = 0.0
        }</span> else<span class="cov0" title="0"> {
                // Sepet öğelerini al
                cartItems, err := h.orderService.GetCartItems(cart.ID)
                if err == nil </span><span class="cov0" title="0">{
                        data["CartItems"] = cartItems

                        // Toplam hesapla
                        var total float64
                        for _, item := range cartItems </span><span class="cov0" title="0">{
                                total += item.Price * float64(item.Quantity)
                        }</span>
                        <span class="cov0" title="0">data["CartTotal"] = total</span>
                }
        }

        <span class="cov0" title="0">h.RenderTemplate(w, r, "marketplace/cart", data)</span>
}

// Auctions - Açık artırmalar
func (h *EcommerceHandler) Auctions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.GetTemplateData()

        page := h.getPageFromQuery(r)
        limit := 20
        offset := (page - 1) * limit

        // Aktif açık artırmalar
        auctions, err := h.auctionService.GetActiveAuctions(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleError(w, r, err, "Açık artırmalar yüklenirken hata oluştu")
                return
        }</span>

        // Yakında bitecek açık artırmalar
        <span class="cov0" title="0">endingAuctions, err := h.auctionService.GetEndingAuctions(24, 6, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["EndingAuctions"] = endingAuctions
        }</span>

        <span class="cov0" title="0">data["Auctions"] = auctions
        data["CurrentPage"] = page
        h.RenderTemplate(w, r, "marketplace/auctions", data)</span>
}

// AuctionDetail - Açık artırma detayı
func (h *EcommerceHandler) AuctionDetail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        auctionIDStr := strings.TrimPrefix(r.URL.Path, "/auction/")
        auctionID, err := strconv.Atoi(auctionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()

        // Açık artırma bilgisi
        auction, err := h.auctionService.GetAuctionByID(auctionID)
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        // Görüntülenme sayısını artır
        <span class="cov0" title="0">go h.auctionService.IncrementAuctionViews(auctionID)

        // Teklifler
        bids, err := h.auctionService.GetAuctionBids(auctionID, 10, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["AuctionBids"] = bids
        }</span>

        // Açık artırma resimleri
        <span class="cov0" title="0">images, err := h.auctionService.GetAuctionImages(auctionID)
        if err == nil </span><span class="cov0" title="0">{
                data["AuctionImages"] = images
        }</span>

        // Satıcı bilgisi
        <span class="cov0" title="0">vendor, err := h.vendorService.GetVendorByID(auction.VendorID)
        if err == nil </span><span class="cov0" title="0">{
                data["Vendor"] = vendor
        }</span>

        // Kullanıcının bu açık artırmayı takip edip etmediğini kontrol et
        <span class="cov0" title="0">userID := h.GetUserID(r)
        if userID &gt; 0 </span><span class="cov0" title="0">{
                isWatching, err := h.auctionService.IsUserWatching(auctionID, userID)
                if err == nil </span><span class="cov0" title="0">{
                        data["IsWatching"] = isWatching
                }</span>
        }

        <span class="cov0" title="0">data["Auction"] = auction
        h.RenderTemplate(w, r, "marketplace/auction-detail", data)</span>
}

// PlaceBid - Teklif verme
func (h *EcommerceHandler) PlaceBid(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                h.SetFlashError("Teklif vermek için giriş yapmalısınız")
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">auctionID, _ := strconv.Atoi(r.FormValue("auction_id"))
        amount, _ := strconv.ParseFloat(r.FormValue("amount"), 64)
        userID := h.GetUserID(r)

        bid := &amp;models.AuctionBid{
                AuctionID: auctionID,
                UserID:    userID,
                Amount:    amount,
                IPAddress: r.RemoteAddr,
        }

        err := h.auctionService.PlaceBid(bid)
        if err != nil </span><span class="cov0" title="0">{
                h.SetFlashError(err.Error())
        }</span> else<span class="cov0" title="0"> {
                h.SetFlashSuccess("Teklifiniz başarıyla verildi")
        }</span>

        <span class="cov0" title="0">http.Redirect(w, r, fmt.Sprintf("/auction/%d", auctionID), http.StatusSeeOther)</span>
}

// Vendor Dashboard
func (h *EcommerceHandler) VendorDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">data := h.GetTemplateData()
        userID := h.GetUserID(r)

        // Satıcı bilgisini al
        vendor, err := h.vendorService.GetVendorByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                // Satıcı değilse, satıcı olmak için yönlendir
                h.SetFlashError("Satıcı paneline erişmek için önce satıcı başvurusu yapmalısınız")
                http.Redirect(w, r, "/become-vendor", http.StatusSeeOther)
                return
        }</span>

        // Satıcı istatistikleri
        <span class="cov0" title="0">stats, err := h.vendorService.GetVendorStats(vendor.ID)
        if err == nil </span><span class="cov0" title="0">{
                data["VendorStats"] = stats
        }</span>

        // Son ürünler
        <span class="cov0" title="0">products, err := h.productService.GetProductsByVendor(vendor.ID, 5, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["RecentProducts"] = products
        }</span>

        // Son siparişler
        <span class="cov0" title="0">orders, err := h.orderService.GetVendorOrders(vendor.ID, 5, 0)
        if err == nil </span><span class="cov0" title="0">{
                data["RecentOrders"] = orders
        }</span>

        <span class="cov0" title="0">data["Vendor"] = vendor
        h.RenderTemplate(w, r, "vendor/dashboard", data)</span>
}

// Helper methods

func (h *EcommerceHandler) getPageFromQuery(r *http.Request) int <span class="cov0" title="0">{
        pageStr := r.URL.Query().Get("page")
        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">return page</span>
}

func (h *EcommerceHandler) SetFlashSuccess(message string) {<span class="cov0" title="0">
        // Flash message implementation - bu gerçek implementasyonda session'a eklenir
        // Şimdilik boş bırakıyoruz
}</span>

func (h *EcommerceHandler) SetFlashError(message string) {<span class="cov0" title="0">
        // Flash message implementation - bu gerçek implementasyonda session'a eklenir
        // Şimdilik boş bırakıyoruz
}</span>

func (h *EcommerceHandler) GetUserID(r *http.Request) int <span class="cov0" title="0">{
        // Get user ID from session - gerçek implementasyonda session'dan alınır
        return 1 // Test için sabit değer
}</span>

func (h *EcommerceHandler) GetSessionID(r *http.Request) string <span class="cov0" title="0">{
        // Get session ID - gerçek implementasyonda session'dan alınır
        return "test-session-id" // Test için sabit değer
}</span>

// API Endpoints

// API - Ürün arama
func (h *EcommerceHandler) APISearchProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                http.Error(w, "Query parameter 'q' is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">products, err := h.productService.SearchProducts(query, 10, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Search failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(products)</span>
}

// API - Sepet güncelleme
func (h *EcommerceHandler) APIUpdateCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ItemID   int `json:"item_id"`
                Quantity int `json:"quantity"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Quantity &lt;= 0 </span><span class="cov0" title="0">{
                // Öğeyi sil
                err := h.orderService.RemoveCartItem(req.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to remove item", http.StatusInternalServerError)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Miktarı güncelle
                cartItem := &amp;models.CartItem{Quantity: req.Quantity}
                err := h.orderService.UpdateCartItem(req.ItemID, cartItem)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to update item", http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "success"})</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "context"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "os"
        "sync"
        "time"

        "github.com/gorilla/sessions"
)

// contextKey, context değerleri için özel anahtar tipi
type contextKey string

const (
        SessionCookieName = "kolaj-session"
        UserKey           = contextKey("user")
        FlashKey          = "flash"
)

var (
        Logger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Detaylı log için logger oluştur
        logFile, err := os.OpenFile("auth_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Log dosyası oluşturulamadı:", err)
                Logger = log.New(os.Stdout, "[AUTH-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                Logger = log.New(logFile, "[AUTH-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

// SessionManager oturum yönetimi için kullanılır
type SessionManager struct {
        store  *sessions.CookieStore
        mutex  sync.Mutex
        Logger *log.Logger
}

// NewSessionManager yeni bir session manager oluşturur
func NewSessionManager(secret string) *SessionManager <span class="cov0" title="0">{
        return &amp;SessionManager{
                store:  sessions.NewCookieStore([]byte(secret)),
                Logger: Logger,
        }
}</span>

// GetSession mevcut HTTP isteği için oturum bilgisini getirir
func (sm *SessionManager) GetSession(r *http.Request) (*sessions.Session, error) <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        session, err := sm.store.Get(r, SessionCookieName)

        sm.Logger.Printf("GetSession çağrıldı - Cookie Adı: %s, Hata: %v", SessionCookieName, err)
        if err != nil </span><span class="cov0" title="0">{
                sm.Logger.Printf("Oturum çerezini okuma hatası: %v", err)
                return nil, err
        }</span>

        // Session bilgilerini detaylı logla
        <span class="cov0" title="0">sm.Logger.Printf("Oturum Bilgileri: IsNew=%v, Values=%+v", session.IsNew, session.Values)

        // UserKey kontrolü
        if user, ok := session.Values[UserKey]; ok </span><span class="cov0" title="0">{
                sm.Logger.Printf("Kullanıcı oturumda bulundu: %+v", user)
        }</span> else<span class="cov0" title="0"> {
                sm.Logger.Printf("Kullanıcı oturumda bulunamadı")
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// SetSession HTTP yanıtı için oturum bilgilerini günceller
func (sm *SessionManager) SetSession(w http.ResponseWriter, r *http.Request, key, val interface{}) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        session, err := sm.store.Get(r, SessionCookieName)
        if err != nil </span><span class="cov0" title="0">{
                sm.Logger.Printf("SetSession - Oturum çerezini okuma hatası: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">session.Values[key] = val
        sm.Logger.Printf("Oturum güncellendi - Key: %v, Value: %+v", key, val)

        return session.Save(r, w)</span>
}

// ClearSession HTTP yanıtı için oturum bilgilerini temizler
func (sm *SessionManager) ClearSession(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        session, err := sm.store.Get(r, SessionCookieName)
        if err != nil </span><span class="cov0" title="0">{
                sm.Logger.Printf("ClearSession - Oturum çerezini okuma hatası: %v", err)
                return err
        }</span>

        // Tüm session değerlerini temizle
        <span class="cov0" title="0">for k := range session.Values </span><span class="cov0" title="0">{
                sm.Logger.Printf("Oturum değeri siliniyor: %v", k)
                delete(session.Values, k)
        }</span>

        // Çerezi geçersiz kılmak için
        <span class="cov0" title="0">session.Options.MaxAge = -1

        sm.Logger.Printf("Oturum tamamen temizlendi")
        return session.Save(r, w)</span>
}

// cleanupAllCookies istemcideki tüm çerezleri temizler
func (sm *SessionManager) CleanupAllCookies(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sm.Logger.Printf("CleanupAllCookies çağrıldı - Tüm çerezler temizleniyor")

        // Session çerezini temizle
        session, err := sm.store.Get(r, SessionCookieName)
        if err == nil </span><span class="cov0" title="0">{
                session.Options.MaxAge = -1
                session.Save(r, w)
                sm.Logger.Printf("Session çerezi temizlendi: %s", SessionCookieName)
        }</span> else<span class="cov0" title="0"> {
                sm.Logger.Printf("Session çerezi temizlenirken hata: %v", err)
        }</span>

        // Request'teki tüm çerezleri al ve temizle
        <span class="cov0" title="0">for _, cookie := range r.Cookies() </span><span class="cov0" title="0">{
                expiredCookie := &amp;http.Cookie{
                        Name:    cookie.Name,
                        Value:   "",
                        Path:    "/",
                        Expires: time.Unix(0, 0),
                        MaxAge:  -1,
                }
                http.SetCookie(w, expiredCookie)
                sm.Logger.Printf("Çerez temizlendi: %s", cookie.Name)
        }</span>
}

// AddFlash oturum için flash mesajı ekler
func (sm *SessionManager) AddFlash(w http.ResponseWriter, r *http.Request, message string) error <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        session, err := sm.store.Get(r, SessionCookieName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.AddFlash(message, FlashKey)
        sm.Logger.Printf("Flash mesajı eklendi: %s", message)

        return session.Save(r, w)</span>
}

// GetFlashes oturumdaki flash mesajlarını getirir
func (sm *SessionManager) GetFlashes(w http.ResponseWriter, r *http.Request) ([]interface{}, error) <span class="cov0" title="0">{
        sm.mutex.Lock()
        defer sm.mutex.Unlock()

        session, err := sm.store.Get(r, SessionCookieName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">flashes := session.Flashes(FlashKey)
        sm.Logger.Printf("Flash mesajları alındı: %+v", flashes)

        err = session.Save(r, w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return flashes, nil</span>
}

// Handler temel handler yapısı
type Handler struct {
        Templates       *template.Template
        SessionManager  *SessionManager
        TemplateContext map[string]interface{}
}

// WithUser kullanıcı bilgisini context'e ekler
func WithUser(ctx context.Context, user interface{}) context.Context <span class="cov0" title="0">{
        Logger.Printf("WithUser çağrıldı - User: %+v", user)
        return context.WithValue(ctx, UserKey, user)
}</span>

// UserFromContext context'ten kullanıcı bilgisini alır
func UserFromContext(ctx context.Context) (interface{}, bool) <span class="cov0" title="0">{
        user := ctx.Value(UserKey)
        Logger.Printf("UserFromContext çağrıldı - User: %+v, Exists: %v", user, user != nil)
        return user, user != nil
}</span>

// IsAuthenticated kullanıcının oturum açmış olup olmadığını kontrol eder
func (h *Handler) IsAuthenticated(r *http.Request) bool <span class="cov0" title="0">{
        session, err := h.SessionManager.GetSession(r)
        if err != nil </span><span class="cov0" title="0">{
                h.SessionManager.Logger.Printf("IsAuthenticated - Oturum alınamadı: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">_, ok := session.Values[UserKey]
        h.SessionManager.Logger.Printf("IsAuthenticated sonucu: %v", ok)
        return ok</span>
}

// RenderTemplate şablon render işlemini gerçekleştirir
func (h *Handler) RenderTemplate(w http.ResponseWriter, r *http.Request, name string, data map[string]interface{}) <span class="cov0" title="0">{
        h.SessionManager.Logger.Printf("RenderTemplate çağrıldı - Şablon: %s", name)

        // Şablon bağlamını oluştur
        templateContext := make(map[string]interface{})

        // Global bağlamdan değerleri al
        for k, v := range h.TemplateContext </span><span class="cov0" title="0">{
                templateContext[k] = v
        }</span>

        // Gelen veriyi bağlama ekle
        <span class="cov0" title="0">for k, v := range data </span><span class="cov0" title="0">{
                templateContext[k] = v
        }</span>

        // Oturumdaki flash mesajlarını al
        <span class="cov0" title="0">flashes, err := h.SessionManager.GetFlashes(w, r)
        if err == nil </span><span class="cov0" title="0">{
                templateContext["flashes"] = flashes
        }</span>

        // Kimlik doğrulaması durumunu kontrol et
        <span class="cov0" title="0">if h.IsAuthenticated(r) </span><span class="cov0" title="0">{
                session, _ := h.SessionManager.GetSession(r)
                if user, ok := session.Values[UserKey]; ok </span><span class="cov0" title="0">{
                        templateContext["currentUser"] = user
                        templateContext["isAuthenticated"] = true
                }</span>
        } else<span class="cov0" title="0"> {
                templateContext["isAuthenticated"] = false
        }</span>

        <span class="cov0" title="0">h.SessionManager.Logger.Printf("Şablon verileri: %+v", templateContext)

        // Şablonu render et
        err = h.Templates.ExecuteTemplate(w, name, templateContext)
        if err != nil </span><span class="cov0" title="0">{
                h.SessionManager.Logger.Printf("Şablon render hatası: %v", err)
                http.Error(w, fmt.Sprintf("Template rendering error: %v", err), http.StatusInternalServerError)
                return
        }</span>
}

// RedirectWithFlash kullanıcıyı flash mesajı ile birlikte yönlendirir
func (h *Handler) RedirectWithFlash(w http.ResponseWriter, r *http.Request, url, message string) <span class="cov0" title="0">{
        h.SessionManager.Logger.Printf("RedirectWithFlash - URL: %s, Mesaj: %s", url, message)

        if message != "" </span><span class="cov0" title="0">{
                err := h.SessionManager.AddFlash(w, r, message)
                if err != nil </span><span class="cov0" title="0">{
                        h.SessionManager.Logger.Printf("Flash mesajı eklenirken hata: %v", err)
                }</span>
        }

        <span class="cov0" title="0">http.Redirect(w, r, url, http.StatusSeeOther)</span>
}

// GetTemplateData returns base template data
func (h *Handler) GetTemplateData() map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})

        // Copy template context
        for k, v := range h.TemplateContext </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return data</span>
}

// HandleError handles errors and renders error page
func (h *Handler) HandleError(w http.ResponseWriter, r *http.Request, err error, message string) <span class="cov0" title="0">{
        Logger.Printf("Error: %v", err)

        data := h.GetTemplateData()
        data["Error"] = message
        data["ErrorDetails"] = err.Error()

        w.WriteHeader(http.StatusInternalServerError)
        h.RenderTemplate(w, r, "error", data)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package middleware

import (
        "context"
        "net/http"

        "kolajAi/internal/core"
        "kolajAi/internal/validation"
)

// FormContext key types
type formContextKey string

// Context keys
const (
        FormDataKey   formContextKey = "form_data"
        FormErrorsKey formContextKey = "form_errors"
)

// FormData stores the form data
type FormData struct {
        Data      map[string]string
        Errors    map[string][]string
        IsValid   bool
        Schema    string
        Validator *validation.FormValidator
}

// ProcessFormMiddleware middleware for processing form data
func ProcessFormMiddleware(validator *validation.FormValidator) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Process only POST, PUT requests
                        if r.Method != http.MethodPost &amp;&amp; r.Method != http.MethodPut </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Get schema name from the path or query parameter
                        <span class="cov0" title="0">schema := r.URL.Query().Get("schema")
                        if schema == "" </span><span class="cov0" title="0">{
                                // Try to extract from path
                                parts := SplitPath(r.URL.Path)
                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                        schema = parts[len(parts)-1]
                                }</span>
                        }

                        // If still no schema, continue without processing
                        <span class="cov0" title="0">if schema == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Parse form
                        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                                appErr := core.NewFormParseError(err)
                                if r.Header.Get("Content-Type") == "application/json" </span><span class="cov0" title="0">{
                                        core.RespondWithError(w, appErr)
                                        return
                                }</span>
                                // Store error in context and continue
                                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), FormErrorsKey, appErr)
                                next.ServeHTTP(w, r.WithContext(ctx))
                                return</span>
                        }

                        // Convert form data to map
                        <span class="cov0" title="0">formData := make(map[string]string)
                        for key, values := range r.Form </span><span class="cov0" title="0">{
                                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                        formData[key] = values[0]
                                }</span>
                        }

                        // Validate form
                        <span class="cov0" title="0">isValid, validationErrors := validator.ValidateForm(schema, formData)

                        // Create form data structure
                        data := &amp;FormData{
                                Data:      formData,
                                Errors:    validationErrors,
                                IsValid:   isValid,
                                Schema:    schema,
                                Validator: validator,
                        }

                        // Store form data in context
                        ctx := context.WithValue(r.Context(), FormDataKey, data)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// GetFormData retrieves form data from the request context
func GetFormData(r *http.Request) *FormData <span class="cov0" title="0">{
        data, ok := r.Context().Value(FormDataKey).(*FormData)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return data</span>
}

// GetFormErrors retrieves form errors from the request context
func GetFormErrors(r *http.Request) *core.AppError <span class="cov0" title="0">{
        err, ok := r.Context().Value(FormErrorsKey).(*core.AppError)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// SplitPath splits a URL path into segments
func SplitPath(path string) []string <span class="cov0" title="0">{
        var parts []string
        var current string

        for _, c := range path </span><span class="cov0" title="0">{
                if c == '/' </span><span class="cov0" title="0">{
                        if current != "" </span><span class="cov0" title="0">{
                                parts = append(parts, current)
                                current = ""
                        }</span>
                } else<span class="cov0" title="0"> {
                        current += string(c)
                }</span>
        }

        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                parts = append(parts, current)
        }</span>

        <span class="cov0" title="0">return parts</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package middleware

import (
        "log"
        "net/http"
        "os"
)

var (
        Logger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Middleware için log dosyası oluştur
        logFile, err := os.OpenFile("middleware_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Middleware log dosyası oluşturulamadı:", err)
                Logger = log.New(os.Stdout, "[MIDDLEWARE-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                Logger = log.New(logFile, "[MIDDLEWARE-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

// Middleware represents a middleware
type Middleware func(http.Handler) http.Handler

// Chain chains multiple middlewares
func Chain(middlewares ...Middleware) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        next = middlewares[i](next)
                }</span>
                <span class="cov0" title="0">return next</span>
        }
}

// Auth middleware for authentication
func Auth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                Logger.Printf("Auth middleware çalışıyor: URL=%s, Method=%s", r.URL.Path, r.Method)

                // Tüm çerezleri logla
                Logger.Printf("Request'teki tüm çerezler:")
                for _, cookie := range r.Cookies() </span><span class="cov0" title="0">{
                        Logger.Printf("- Çerez: %s=%s, Path=%s, MaxAge=%d", cookie.Name, cookie.Value, cookie.Path, cookie.MaxAge)
                }</span>

                // Session kontrolü (örnek implementasyon, gerçek uygulamada oturum mantığına göre değiştirilmeli)
                <span class="cov0" title="0">authToken, err := r.Cookie("kolaj-session")

                if err != nil </span><span class="cov0" title="0">{
                        Logger.Printf("Auth hatası: Session çerezi bulunamadı - %v", err)
                        http.Redirect(w, r, "/login", http.StatusSeeOther)
                        return
                }</span>

                <span class="cov0" title="0">Logger.Printf("Auth token bulundu: %s", authToken.Value)

                // Public URL'ler için erişimi kontrol etmiyoruz
                if isPublicURL(r.URL.Path) </span><span class="cov0" title="0">{
                        Logger.Printf("Bu bir public URL, auth kontrolü atlanıyor: %s", r.URL.Path)
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Token geçerli mi kontrol et
                <span class="cov0" title="0">if authToken.Value == "" </span><span class="cov0" title="0">{
                        Logger.Printf("Auth token değeri boş, login sayfasına yönlendiriliyor")
                        http.Redirect(w, r, "/login", http.StatusSeeOther)
                        return
                }</span>

                // Token geçerli, isteği işlemeye devam et
                <span class="cov0" title="0">Logger.Printf("Auth başarılı, isteği handler'a iletiyorum")
                next.ServeHTTP(w, r)</span>
        })
}

// isPublicURL checks if a URL path is public
func isPublicURL(path string) bool <span class="cov0" title="0">{
        publicPaths := []string{
                "/login",
                "/register",
                "/forgot-password",
                "/reset-password",
                "/static/",
                "/favicon.ico",
        }

        for _, p := range publicPaths </span><span class="cov0" title="0">{
                if p == path || (len(p) &gt; 0 &amp;&amp; p[len(p)-1] == '/' &amp;&amp; len(path) &gt;= len(p) &amp;&amp; path[:len(p)] == p) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Secure middleware for security headers
func Secure(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                Logger.Printf("Secure middleware çalışıyor: %s", r.URL.Path)

                // Set security headers
                w.Header().Set("X-XSS-Protection", "1; mode=block")
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
                w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;")

                next.ServeHTTP(w, r)
        }</span>)
}

// Logger middleware for logging requests
func RequestLogger(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                Logger.Printf("Request: %s %s %s", r.RemoteAddr, r.Method, r.URL.Path)
                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

import (
        "errors"
        "strings"
        "time"
)

// Category represents a product category
type Category struct {
        ID          int       `json:"id" db:"id"`
        Name        string    `json:"name" db:"name"`
        Description string    `json:"description" db:"description"`
        ParentID    *int      `json:"parent_id" db:"parent_id"`
        Image       string    `json:"image" db:"image"`
        IsActive    bool      `json:"is_active" db:"is_active"`
        SortOrder   int       `json:"sort_order" db:"sort_order"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

// Product represents a product in the marketplace
type Product struct {
        ID              int       `json:"id" db:"id"`
        VendorID        int       `json:"vendor_id" db:"vendor_id"`
        CategoryID      int       `json:"category_id" db:"category_id"`
        Name            string    `json:"name" db:"name"`
        Description     string    `json:"description" db:"description"`
        ShortDesc       string    `json:"short_desc" db:"short_desc"`
        SKU             string    `json:"sku" db:"sku"`
        Price           float64   `json:"price" db:"price"`
        ComparePrice    float64   `json:"compare_price" db:"compare_price"`
        CostPrice       float64   `json:"cost_price" db:"cost_price"`
        WholesalePrice  float64   `json:"wholesale_price" db:"wholesale_price"`
        MinWholesaleQty int       `json:"min_wholesale_qty" db:"min_wholesale_qty"`
        Stock           int       `json:"stock" db:"stock"`
        MinStock        int       `json:"min_stock" db:"min_stock"`
        Weight          float64   `json:"weight" db:"weight"`
        Dimensions      string    `json:"dimensions" db:"dimensions"`
        Status          string    `json:"status" db:"status"` // draft, active, inactive, out_of_stock
        IsDigital       bool      `json:"is_digital" db:"is_digital"`
        IsFeatured      bool      `json:"is_featured" db:"is_featured"`
        AllowReviews    bool      `json:"allow_reviews" db:"allow_reviews"`
        MetaTitle       string    `json:"meta_title" db:"meta_title"`
        MetaDesc        string    `json:"meta_desc" db:"meta_desc"`
        Tags            string    `json:"tags" db:"tags"`
        ViewCount       int       `json:"view_count" db:"view_count"`
        SalesCount      int       `json:"sales_count" db:"sales_count"`
        Rating          float64   `json:"rating" db:"rating"`
        ReviewCount     int       `json:"review_count" db:"review_count"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time `json:"updated_at" db:"updated_at"`
}

// Validate checks if the product data is valid
func (p *Product) Validate() error <span class="cov8" title="1">{
        if strings.TrimSpace(p.Name) == "" </span><span class="cov8" title="1">{
                return errors.New("product name cannot be empty")
        }</span>

        <span class="cov8" title="1">if p.Price &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("product price cannot be negative")
        }</span>

        <span class="cov8" title="1">if p.Stock &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("product stock cannot be negative")
        }</span>

        <span class="cov8" title="1">if p.VendorID &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("valid vendor ID is required")
        }</span>

        <span class="cov8" title="1">if p.CategoryID &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("valid category ID is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsAvailable checks if the product is available for purchase
func (p *Product) IsAvailable() bool <span class="cov0" title="0">{
        return p.Status == "active" &amp;&amp; p.Stock &gt; 0
}</span>

// ProductImage represents product images
type ProductImage struct {
        ID        int       `json:"id" db:"id"`
        ProductID int       `json:"product_id" db:"product_id"`
        ImageURL  string    `json:"image_url" db:"image_url"`
        AltText   string    `json:"alt_text" db:"alt_text"`
        SortOrder int       `json:"sort_order" db:"sort_order"`
        IsPrimary bool      `json:"is_primary" db:"is_primary"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ProductVariant represents product variants (size, color, etc.)
type ProductVariant struct {
        ID        int     `json:"id" db:"id"`
        ProductID int     `json:"product_id" db:"product_id"`
        Name      string  `json:"name" db:"name"`
        Value     string  `json:"value" db:"value"`
        Price     float64 `json:"price" db:"price"`
        Stock     int     `json:"stock" db:"stock"`
        SKU       string  `json:"sku" db:"sku"`
        IsActive  bool    `json:"is_active" db:"is_active"`
}

// ProductAttribute represents product attributes
type ProductAttribute struct {
        ID        int    `json:"id" db:"id"`
        ProductID int    `json:"product_id" db:"product_id"`
        Name      string `json:"name" db:"name"`
        Value     string `json:"value" db:"value"`
}

// ProductReview represents product reviews
type ProductReview struct {
        ID         int       `json:"id" db:"id"`
        ProductID  int       `json:"product_id" db:"product_id"`
        UserID     int       `json:"user_id" db:"user_id"`
        OrderID    int       `json:"order_id" db:"order_id"`
        Rating     int       `json:"rating" db:"rating"`
        Title      string    `json:"title" db:"title"`
        Comment    string    `json:"comment" db:"comment"`
        Images     string    `json:"images" db:"images"`
        IsVerified bool      `json:"is_verified" db:"is_verified"`
        Status     string    `json:"status" db:"status"` // pending, approved, rejected
        CreatedAt  time.Time `json:"created_at" db:"created_at"`
        UpdatedAt  time.Time `json:"updated_at" db:"updated_at"`
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "errors"
        "regexp"
        "strings"
        "time"
)

// User represents a user in the system
type User struct {
        ID        int64     `json:"id" db:"id"`
        Name      string    `json:"name" db:"name"`
        Email     string    `json:"email" db:"email"`
        Password  string    `json:"-" db:"password"` // Password is not exposed in JSON
        Phone     string    `json:"phone" db:"phone"`
        IsActive  bool      `json:"is_active" db:"is_active"`
        IsAdmin   bool      `json:"is_admin" db:"is_admin"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// Validate checks if the user data is valid
func (u *User) Validate() error <span class="cov8" title="1">{
        if strings.TrimSpace(u.Name) == "" </span><span class="cov8" title="1">{
                return errors.New("name cannot be empty")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(u.Email) == "" </span><span class="cov8" title="1">{
                return errors.New("email cannot be empty")
        }</span>

        // Basic email validation
        <span class="cov8" title="1">emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(u.Email) </span><span class="cov8" title="1">{
                return errors.New("invalid email format")
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(u.Password) == "" </span><span class="cov8" title="1">{
                return errors.New("password cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "database/sql"
        "reflect"
        "time"

        "kolajAi/internal/database"
)

// BaseRepository provides common database operations
type BaseRepository struct {
        db *database.MySQLRepository
}

// NewBaseRepository creates a new base repository
func NewBaseRepository(db *database.MySQLRepository) *BaseRepository <span class="cov0" title="0">{
        return &amp;BaseRepository{db: db}
}</span>

// Create inserts a new record
func (r *BaseRepository) Create(table string, data interface{}) (int64, error) <span class="cov0" title="0">{
        fields, values := getFieldsAndValues(data)
        return r.db.Create(table, fields, values)
}</span>

// Update updates a record
func (r *BaseRepository) Update(table string, id interface{}, data interface{}) error <span class="cov0" title="0">{
        return r.db.Update(table, id, data)
}</span>

// Delete removes a record
func (r *BaseRepository) Delete(table string, id interface{}) error <span class="cov0" title="0">{
        return r.db.Delete(table, id)
}</span>

// FindByID retrieves a record by its ID
func (r *BaseRepository) FindByID(table string, id interface{}, result interface{}) error <span class="cov0" title="0">{
        return r.db.FindByID(table, id, result)
}</span>

// FindAll retrieves multiple records
func (r *BaseRepository) FindAll(table string, result interface{}, conditions map[string]interface{}, orderBy string, limit, offset int) error <span class="cov0" title="0">{
        return r.db.FindAll(table, orderBy, limit, offset, result)
}</span>

// FindOne retrieves a single record
func (r *BaseRepository) FindOne(table string, result interface{}, conditions map[string]interface{}) error <span class="cov0" title="0">{
        return r.db.FindOne(table, conditions, result)
}</span>

// Count returns the number of records
func (r *BaseRepository) Count(table string, conditions map[string]interface{}) (int64, error) <span class="cov0" title="0">{
        return r.db.Count(table, conditions)
}</span>

// Search searches records
func (r *BaseRepository) Search(table string, fields []string, term string, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        return r.db.Search(table, fields, term, limit, offset, result)
}</span>

// FindByDateRange finds records within a date range
func (r *BaseRepository) FindByDateRange(table, dateField string, start, end time.Time, limit, offset int, result interface{}) error <span class="cov0" title="0">{
        return r.db.FindByDateRange(table, dateField, start, end, limit, offset, result)
}</span>

// Transaction executes a function within a transaction
func (r *BaseRepository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        return r.db.Transaction(fn)
}</span>

// Exists checks if a record exists
func (r *BaseRepository) Exists(table string, conditions map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        return r.db.Exists(table, conditions)
}</span>

// Helper functions

// getFieldsAndValues extracts fields and values from a struct or map
func getFieldsAndValues(data interface{}) ([]string, []interface{}) <span class="cov0" title="0">{
        fields := make([]string, 0)
        values := make([]interface{}, 0)

        v := reflect.ValueOf(data)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        // Map tipini kontrol et
        <span class="cov0" title="0">if v.Kind() == reflect.Map </span><span class="cov0" title="0">{
                iter := v.MapRange()
                for iter.Next() </span><span class="cov0" title="0">{
                        key := iter.Key().String()
                        value := iter.Value().Interface()

                        // Byte array'i string'e dönüştür
                        if byteArray, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                                value = string(byteArray)
                        }</span>

                        <span class="cov0" title="0">fields = append(fields, key)
                        values = append(values, value)</span>
                }
                <span class="cov0" title="0">return fields, values</span>
        }

        // Struct tipini işle
        <span class="cov0" title="0">if v.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                t := v.Type()
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                        field := t.Field(i)
                        value := v.Field(i).Interface()

                        // Skip zero values and unexported fields
                        if !reflect.DeepEqual(value, reflect.Zero(field.Type).Interface()) &amp;&amp; field.IsExported() </span><span class="cov0" title="0">{
                                // Byte array'i string'e dönüştür
                                if byteArray, ok := value.([]byte); ok </span><span class="cov0" title="0">{
                                        value = string(byteArray)
                                }</span>

                                // Önce db tag'ini kontrol et, yoksa field adını kullan
                                <span class="cov0" title="0">dbTag := field.Tag.Get("db")
                                if dbTag != "" </span><span class="cov0" title="0">{
                                        fields = append(fields, dbTag)
                                }</span> else<span class="cov0" title="0"> {
                                        fields = append(fields, field.Name)
                                }</span>
                                <span class="cov0" title="0">values = append(values, value)</span>
                        }
                }
        }

        <span class="cov0" title="0">return fields, values</span>
}

// CreateStruct creates a record from a struct
func (r *BaseRepository) CreateStruct(table string, data interface{}) (int64, error) <span class="cov0" title="0">{
        fields, values := getFieldsAndValues(data)
        return r.db.Create(table, fields, values)
}</span>

// SetConnectionPool sets database connection pool parameters
func (r *BaseRepository) SetConnectionPool(maxOpen, maxIdle int, maxLifetime time.Duration) <span class="cov0" title="0">{
        r.db.SetConnectionPool(maxOpen, maxIdle, maxLifetime)
}</span>

// SoftDelete performs a soft delete by setting a deleted_at timestamp
func (r *BaseRepository) SoftDelete(table string, id interface{}) error <span class="cov0" title="0">{
        return r.db.SoftDelete(table, id)
}</span>

// BulkCreate creates multiple records at once
func (r *BaseRepository) BulkCreate(table string, data []interface{}) ([]int64, error) <span class="cov0" title="0">{
        return r.db.BulkCreate(table, data)
}</span>

// BulkUpdate updates multiple records at once
func (r *BaseRepository) BulkUpdate(table string, ids []interface{}, data interface{}) error <span class="cov0" title="0">{
        return r.db.BulkUpdate(table, ids, data)
}</span>

// BulkDelete deletes multiple records at once
func (r *BaseRepository) BulkDelete(table string, ids []interface{}) error <span class="cov0" title="0">{
        return r.db.BulkDelete(table, ids)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "database/sql"
        "log"
        "strings"
        "time"

        "kolajAi/internal/core"
        "kolajAi/internal/database"
        "kolajAi/internal/models"

        "golang.org/x/crypto/bcrypt"
)

// UserRepository handles user-related database operations
type UserRepository struct {
        db       *database.MySQLRepository
        baseRepo *BaseRepository
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *database.MySQLRepository) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db:       db,
                baseRepo: NewBaseRepository(db),
        }
}</span>

// RegisterUser registers a new user
func (r *UserRepository) RegisterUser(name, email, password, phone string) (int64, error) <span class="cov0" title="0">{
        // Şifre kontrolü - eğer şifre zaten hash'lenmişse tekrar hash'leme
        if strings.HasPrefix(password, "$2a$") || strings.HasPrefix(password, "$2b$") || strings.HasPrefix(password, "$2y$") </span><span class="cov0" title="0">{
                log.Printf("INFO - RegisterUser: Şifre zaten hash'lenmiş, doğrudan kaydediliyor")
                hashedPasswordStr := password

                // Kullanıcı verilerini hazırla
                userData := map[string]interface{}{
                        "name":       name,
                        "email":      email,
                        "password":   hashedPasswordStr, // String olarak kaydet
                        "phone":      phone,
                        "is_active":  true,
                        "created_at": time.Now(),
                        "updated_at": time.Now(),
                }

                // Kullanıcıyı veritabanına kaydet
                userID, err := r.baseRepo.Create("users", userData)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR - RegisterUser: Kullanıcı kayıt hatası: %v", err)
                        return 0, core.NewDatabaseError("error creating user", err)
                }</span>

                <span class="cov0" title="0">return userID, nil</span>
        }

        // Şifreyi hash'le
        <span class="cov0" title="0">log.Printf("INFO - RegisterUser: Şifre hash'leme başlıyor. Şifre uzunluğu: %d", len(password))
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - RegisterUser: Şifre hash'leme hatası: %v", err)
                return 0, core.NewDatabaseError("error hashing password", err)
        }</span>

        // Hash'lenmiş şifreyi string'e dönüştür
        <span class="cov0" title="0">hashedPasswordStr := string(hashedPassword)
        log.Printf("DEBUG - RegisterUser: Hash'lenmiş şifre: %s", hashedPasswordStr)
        log.Printf("DEBUG - RegisterUser: Hash'lenmiş şifre bcrypt formatında mı: %v",
                strings.HasPrefix(hashedPasswordStr, "$2a$") ||
                        strings.HasPrefix(hashedPasswordStr, "$2b$") ||
                        strings.HasPrefix(hashedPasswordStr, "$2y$"))

        // Kullanıcı verilerini hazırla
        userData := map[string]interface{}{
                "name":       name,
                "email":      email,
                "password":   hashedPasswordStr, // String olarak kaydet
                "phone":      phone,
                "is_active":  true,
                "created_at": time.Now(),
                "updated_at": time.Now(),
        }

        // Kullanıcıyı veritabanına kaydet
        userID, err := r.baseRepo.Create("users", userData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - RegisterUser: Kullanıcı kayıt hatası: %v", err)
                return 0, core.NewDatabaseError("error creating user", err)
        }</span>

        // Oluşturulan kullanıcıyı kontrol et
        <span class="cov0" title="0">createdUser, err := r.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN - RegisterUser: Oluşturulan kullanıcı kontrol edilemedi: %v", err)
                return userID, nil // Yine de başarılı kabul et
        }</span>

        // Şifrenin doğru kaydedilip kaydedilmediğini kontrol et
        <span class="cov0" title="0">log.Printf("DEBUG - RegisterUser: Veritabanına kaydedilen şifre: %s", createdUser.Password)
        log.Printf("DEBUG - RegisterUser: Kaydedilen şifre bcrypt formatında mı: %v",
                strings.HasPrefix(createdUser.Password, "$2a$") ||
                        strings.HasPrefix(createdUser.Password, "$2b$") ||
                        strings.HasPrefix(createdUser.Password, "$2y$"))

        return userID, nil</span>
}

// VerifyTempPassword verifies the temporary password for a user
// Bu fonksiyon kullanıcının geçici şifresini doğrular
// Parametreler:
//   - email: Kullanıcının e-posta adresi
//   - tempPassword: Kullanıcının girdiği geçici şifre
//
// Dönüş değerleri:
//   - bool: Doğrulama başarılı mı?
//   - error: Hata durumu
func (r *UserRepository) VerifyTempPassword(email, tempPassword string) (bool, error) <span class="cov0" title="0">{
        // Kullanıcıyı önce e-posta ile bulalım
        user, err := r.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - VerifyTempPassword: E-posta ile kullanıcı bulunamadı: %v", err)
                return false, core.NewDatabaseError("error finding user by email", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - VerifyTempPassword: Kullanıcı bulunamadı: %s", email)
                return false, nil
        }</span>

        // Şifre karşılaştırma detaylı debug
        <span class="cov0" title="0">log.Printf("DEBUG - VerifyTempPassword: Şifre karşılaştırma başlıyor")
        log.Printf("DEBUG - VerifyTempPassword: Girilen şifre: %s", tempPassword)
        log.Printf("DEBUG - VerifyTempPassword: Veritabanındaki hash: %s", user.Password)

        // Veritabanındaki şifre hash'i boş veya geçersiz mi kontrol et
        if user.Password == "" </span><span class="cov0" title="0">{
                log.Printf("ERROR - VerifyTempPassword: Veritabanındaki şifre hash'i boş")

                // BaseRepo üzerinden tekrar kullanıcıyı sorgula
                var freshUser models.User
                conditions := map[string]interface{}{
                        "email":     email,
                        "is_active": true,
                }

                err = r.baseRepo.FindOne("users", &amp;freshUser, conditions)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR - VerifyTempPassword: Tekrar sorgulama hatası: %v", err)
                        return false, nil
                }</span>

                <span class="cov0" title="0">log.Printf("DEBUG - VerifyTempPassword: Tekrar sorgulanan kullanıcının şifresi: %s", freshUser.Password)

                // Şifre hala boş mu kontrol et
                if freshUser.Password == "" </span><span class="cov0" title="0">{
                        log.Printf("ERROR - VerifyTempPassword: Tekrar sorgulanan kullanıcının şifresi de boş")
                        return false, nil
                }</span> else<span class="cov0" title="0"> {
                        // Şifre hash'ini güncelle ve tekrar dene
                        user.Password = freshUser.Password
                }</span>
        }

        // Hash formatı kontrolü
        <span class="cov0" title="0">if !strings.HasPrefix(user.Password, "$2a$") &amp;&amp;
                !strings.HasPrefix(user.Password, "$2b$") &amp;&amp;
                !strings.HasPrefix(user.Password, "$2y$") </span><span class="cov0" title="0">{
                log.Printf("ERROR - VerifyTempPassword: Veritabanındaki şifre geçerli bir bcrypt hash'i değil")
                return false, nil
        }</span>

        // Panic durumlarını yakalamak için defer kullanımı
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("WARN - VerifyTempPassword: Şifre karşılaştırma hatası (panic): %v", r)
                }</span>
        }()

        // Bcrypt ile şifre karşılaştırma
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(tempPassword))
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("SUCCESS - VerifyTempPassword: Şifre doğrulandı (bcrypt)")
                return true, nil
        }</span>

        <span class="cov0" title="0">log.Printf("ERROR - VerifyTempPassword: Şifre eşleşmedi: %v", err)
        return false, nil</span>
}

// ResetUserPassword resets a user's password
func (r *UserRepository) ResetUserPassword(email, newPassword string) error <span class="cov0" title="0">{
        // Kullanıcıyı önce e-posta ile bulalım
        log.Printf("DEBUG - ResetUserPassword: Şifre değiştirme işlemi başlatılıyor. Email: %s", email)
        user, err := r.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ResetUserPassword: Kullanıcı bulunamadı: %v", err)
                return core.NewDatabaseError("error finding user for reset password", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ResetUserPassword: %s e-posta adresi ile kullanıcı bulunamadı", email)
                return core.NewDatabaseError("user not found", nil)
        }</span>

        <span class="cov0" title="0">log.Printf("INFO - ResetUserPassword: Kullanıcı bulundu: %s (ID: %d, Aktif: %v)", email, user.ID, user.IsActive)

        // Şifre kontrolü - eğer şifre zaten hash'lenmişse tekrar hash'leme
        var hashedPasswordStr string
        if strings.HasPrefix(newPassword, "$2a$") || strings.HasPrefix(newPassword, "$2b$") || strings.HasPrefix(newPassword, "$2y$") </span><span class="cov0" title="0">{
                log.Printf("INFO - ResetUserPassword: Şifre zaten hash'lenmiş, doğrudan kaydediliyor")
                hashedPasswordStr = newPassword
        }</span> else<span class="cov0" title="0"> {
                // Yeni şifreyi hashle
                log.Printf("INFO - ResetUserPassword: Şifre hash'leme başlıyor. Şifre uzunluğu: %d", len(newPassword))
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR - ResetUserPassword: Şifre hash'leme hatası: %v", err)
                        return core.NewDatabaseError("error hashing password", err)
                }</span>

                // Hash'lenmiş şifreyi string'e dönüştür
                <span class="cov0" title="0">hashedPasswordStr = string(hashedPassword)
                log.Printf("DEBUG - ResetUserPassword: Hash'lenmiş şifre: %s", hashedPasswordStr)
                log.Printf("DEBUG - ResetUserPassword: Hash'lenmiş şifre bcrypt formatında mı: %v",
                        strings.HasPrefix(hashedPasswordStr, "$2a$") ||
                                strings.HasPrefix(hashedPasswordStr, "$2b$") ||
                                strings.HasPrefix(hashedPasswordStr, "$2y$"))</span>
        }

        // Doğrudan SQL sorgusu ile şifre güncelleme ve hesabı aktifleştirme
        <span class="cov0" title="0">log.Printf("INFO - ResetUserPassword: Şifre ve hesap durumu güncelleniyor. Kullanıcı ID: %d", user.ID)
        updateQuery := "UPDATE users SET password = ?, is_active = true, updated_at = ? WHERE id = ?"
        stmt, err := database.DB.Prepare(updateQuery)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ResetUserPassword: SQL hazırlama hatası: %v", err)
                return core.NewDatabaseError("error preparing SQL statement", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        now := time.Now()
        result, err := stmt.Exec(hashedPasswordStr, now, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ResetUserPassword: SQL çalıştırma hatası: %v", err)
                return core.NewDatabaseError("error executing SQL statement", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ResetUserPassword: Etkilenen satır sayısı alınamadı: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("INFO - ResetUserPassword: Etkilenen satır sayısı: %d", rowsAffected)
        }</span>

        // Başarılı olup olmadığını kontrol et
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                log.Printf("WARN - ResetUserPassword: Hiçbir satır etkilenmedi, kullanıcı bulunamadı veya zaten güncel: %d", user.ID)
                return core.NewDatabaseError("no rows affected", nil)
        }</span>

        // Güncellenen kullanıcıyı kontrol et
        <span class="cov0" title="0">updatedUser, err := r.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN - ResetUserPassword: Güncellenen kullanıcı kontrol edilemedi: %v", err)
                return nil // Yine de başarılı kabul et
        }</span>

        // Şifrenin doğru kaydedilip kaydedilmediğini kontrol et
        <span class="cov0" title="0">log.Printf("DEBUG - ResetUserPassword: Veritabanına kaydedilen şifre: %s", updatedUser.Password)
        log.Printf("DEBUG - ResetUserPassword: Kaydedilen şifre bcrypt formatında mı: %v",
                strings.HasPrefix(updatedUser.Password, "$2a$") ||
                        strings.HasPrefix(updatedUser.Password, "$2b$") ||
                        strings.HasPrefix(updatedUser.Password, "$2y$"))
        log.Printf("DEBUG - ResetUserPassword: Kullanıcı aktif mi: %v", updatedUser.IsActive)

        // Şifreleri karşılaştır
        if updatedUser.Password != hashedPasswordStr </span><span class="cov0" title="0">{
                log.Printf("WARN - ResetUserPassword: Kaydedilen şifre beklenen şifre ile eşleşmiyor")
                log.Printf("DEBUG - ResetUserPassword: Beklenen şifre: %s", hashedPasswordStr)
                log.Printf("DEBUG - ResetUserPassword: Kaydedilen şifre: %s", updatedUser.Password)
        }</span>

        // Şifre doğrulama testi yap
        <span class="cov0" title="0">if !strings.HasPrefix(newPassword, "$2a$") &amp;&amp; !strings.HasPrefix(newPassword, "$2b$") &amp;&amp; !strings.HasPrefix(newPassword, "$2y$") </span><span class="cov0" title="0">{
                err = bcrypt.CompareHashAndPassword([]byte(updatedUser.Password), []byte(newPassword))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR - ResetUserPassword: Şifre doğrulama testi başarısız: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("SUCCESS - ResetUserPassword: Şifre doğrulama testi başarılı")
                }</span>
        }

        <span class="cov0" title="0">log.Printf("SUCCESS - ResetUserPassword: Şifre başarıyla değiştirildi ve hesap aktifleştirildi: %s", email)
        return nil</span>
}

// GetUserByEmail gets a user by email
func (r *UserRepository) GetUserByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        conditions := map[string]interface{}{
                "email": email,
        }

        err := r.baseRepo.FindOne("users", &amp;user, conditions)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, core.NewDatabaseError("error getting user", err)</span>
        }

        // Şifre boş mu kontrol et ve log çıktısı ver
        <span class="cov0" title="0">log.Printf("DEBUG - GetUserByEmail: Kullanıcı bulundu: %s, Şifre uzunluğu: %d", email, len(user.Password))
        if user.Password == "" </span><span class="cov0" title="0">{
                log.Printf("WARN - GetUserByEmail: Kullanıcının şifresi boş: %s", email)

                // Şifre boş ise doğrudan SQL sorgusu ile tekrar deneyelim
                var password string
                err := database.DB.QueryRow("SELECT password FROM users WHERE email = ?", email).Scan(&amp;password)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                log.Printf("ERROR - GetUserByEmail: Doğrudan sorgu ile de kullanıcı bulunamadı: %s", email)
                                return &amp;user, nil
                        }</span>
                        <span class="cov0" title="0">log.Printf("ERROR - GetUserByEmail: Doğrudan şifre sorgusu hatası: %v", err)
                        return &amp;user, nil</span>
                }

                <span class="cov0" title="0">if password != "" </span><span class="cov0" title="0">{
                        log.Printf("INFO - GetUserByEmail: Doğrudan sorgu ile şifre alındı, uzunluk: %d", len(password))
                        user.Password = password
                }</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateResetToken fonksiyonu kaldırıldı - token sistemi artık kullanılmıyor

// Create inserts a new user
func (r *UserRepository) Create(user *models.User) (int64, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":       user.Name,
                "email":      user.Email,
                "password":   user.Password,
                "phone":      user.Phone,
                "is_active":  user.IsActive,
                "is_admin":   user.IsAdmin,
                "created_at": user.CreatedAt,
                "updated_at": user.UpdatedAt,
        }

        id, err := r.baseRepo.Create("users", data)
        if err != nil </span><span class="cov0" title="0">{
                return 0, core.NewDatabaseError("error creating user", err)
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// Update modifies an existing user
func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "name":       user.Name,
                "email":      user.Email,
                "password":   user.Password,
                "phone":      user.Phone,
                "is_active":  user.IsActive,
                "is_admin":   user.IsAdmin,
                "updated_at": time.Now(),
        }

        err := r.baseRepo.Update("users", user.ID, data)
        if err != nil </span><span class="cov0" title="0">{
                return core.NewDatabaseError("error updating user", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete removes a user
func (r *UserRepository) Delete(id int64) error <span class="cov0" title="0">{
        err := r.baseRepo.Delete("users", id)
        if err != nil </span><span class="cov0" title="0">{
                return core.NewDatabaseError("error deleting user", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindByID retrieves a user by ID
func (r *UserRepository) FindByID(id int64) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := r.baseRepo.FindByID("users", id, &amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.NewDatabaseError("error finding user by ID", err)
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// FindByEmail finds a user by email
func (r *UserRepository) FindByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User

        // Doğrudan SQL sorgusu ile kullanıcıyı bul
        query := `SELECT id, name, email, password, phone, is_active, is_admin, created_at, updated_at 
                          FROM users WHERE email = ?`

        err := database.DB.QueryRow(query, email).Scan(
                &amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.Password, &amp;user.Phone,
                &amp;user.IsActive, &amp;user.IsAdmin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Printf("DEBUG - FindByEmail: Kullanıcı bulunamadı: %s", email)
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.Printf("ERROR - FindByEmail: Veritabanı hatası: %v", err)
                return nil, core.NewDatabaseError("error finding user by email", err)</span>
        }

        <span class="cov0" title="0">log.Printf("DEBUG - FindByEmail: Kullanıcı bulundu: %s, Şifre uzunluğu: %d", email, len(user.Password))

        // Şifre boş mu kontrol et
        if user.Password == "" </span><span class="cov0" title="0">{
                log.Printf("WARN - FindByEmail: Kullanıcının şifresi boş: %s", email)

                // Şifre boş ise doğrudan SQL sorgusu ile tekrar deneyelim
                var password string
                err := database.DB.QueryRow("SELECT password FROM users WHERE email = ?", email).Scan(&amp;password)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                log.Printf("ERROR - FindByEmail: Doğrudan sorgu ile de kullanıcı bulunamadı: %s", email)
                                return &amp;user, nil
                        }</span>
                        <span class="cov0" title="0">log.Printf("ERROR - FindByEmail: Doğrudan şifre sorgusu hatası: %v", err)
                        return &amp;user, nil</span>
                }

                <span class="cov0" title="0">if password != "" </span><span class="cov0" title="0">{
                        log.Printf("INFO - FindByEmail: Doğrudan sorgu ile şifre alındı, uzunluk: %d", len(password))
                        user.Password = password
                }</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// FindByUsername finds a user by username
func (r *UserRepository) FindByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        conditions := map[string]interface{}{
                "username": username,
        }

        err := r.baseRepo.FindOne("users", &amp;user, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.NewDatabaseError("error finding user by username", err)
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// FindAll retrieves all users with pagination
func (r *UserRepository) FindAll(page, perPage int) ([]*models.User, error) <span class="cov0" title="0">{
        var users []*models.User
        err := r.baseRepo.FindAll("users", &amp;users, nil, "created_at", perPage, (page-1)*perPage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.NewDatabaseError("error finding all users", err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// FindByRole retrieves users by role with pagination
func (r *UserRepository) FindByRole(role string, page, perPage int) ([]*models.User, error) <span class="cov0" title="0">{
        var users []*models.User
        conditions := map[string]interface{}{
                "role": role,
        }

        err := r.baseRepo.FindAll("users", &amp;users, conditions, "created_at", perPage, (page-1)*perPage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.NewDatabaseError("error finding users by role", err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// Search searches users
func (r *UserRepository) Search(term string, page, perPage int) ([]*models.User, error) <span class="cov0" title="0">{
        var users []*models.User
        err := r.baseRepo.Search("users", []string{"username", "email", "name"}, term, perPage, (page-1)*perPage, &amp;users)
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.NewDatabaseError("error searching users", err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// Count returns the total number of users
func (r *UserRepository) Count() (int64, error) <span class="cov0" title="0">{
        count, err := r.baseRepo.Count("users", nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, core.NewDatabaseError("error counting users", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// CountByRole returns the number of users with a specific role
func (r *UserRepository) CountByRole(role string) (int64, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{
                "role": role,
        }

        count, err := r.baseRepo.Count("users", conditions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, core.NewDatabaseError("error counting users by role", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// Transaction executes a function within a transaction
func (r *UserRepository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        err := r.baseRepo.Transaction(fn)
        if err != nil </span><span class="cov0" title="0">{
                return core.NewDatabaseError("error in transaction", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindByVerificationToken fonksiyonu kaldırıldı - token sistemi artık kullanılmıyor

// ActivateAccount activates a user account
func (r *UserRepository) ActivateAccount(userID int64) error <span class="cov0" title="0">{
        // Doğrudan SQL sorgusu ile hesabı aktifleştir
        updateQuery := "UPDATE users SET is_active = true, updated_at = ? WHERE id = ?"
        stmt, err := database.DB.Prepare(updateQuery)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ActivateAccount: SQL hazırlama hatası: %v", err)
                return core.NewDatabaseError("error preparing SQL statement", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        now := time.Now()
        result, err := stmt.Exec(now, userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ActivateAccount: SQL çalıştırma hatası: %v", err)
                return core.NewDatabaseError("error executing SQL statement", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR - ActivateAccount: Etkilenen satır sayısı alınamadı: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("INFO - ActivateAccount: Etkilenen satır sayısı: %d", rowsAffected)
        }</span>

        // Başarılı olup olmadığını kontrol et
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                log.Printf("WARN - ActivateAccount: Hiçbir satır etkilenmedi, kullanıcı zaten aktif olabilir: %d", userID)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("SUCCESS - ActivateAccount: Kullanıcı hesabı başarıyla aktifleştirildi: %d", userID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdatePassword updates a user's password
func (r *UserRepository) UpdatePassword(userID int64, hashedPassword string) error <span class="cov0" title="0">{
        updateData := map[string]interface{}{
                "password":   hashedPassword,
                "updated_at": time.Now(),
        }

        err := r.baseRepo.Update("users", userID, updateData)
        if err != nil </span><span class="cov0" title="0">{
                return core.NewDatabaseError("error updating password", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// EmailExists checks if an email exists
func (r *UserRepository) EmailExists(email string) (bool, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{
                "email": email,
        }

        exists, err := r.baseRepo.Exists("users", conditions)
        if err != nil </span><span class="cov0" title="0">{
                return false, core.NewDatabaseError("error checking if email exists", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

// SaveResetToken fonksiyonu kaldırıldı - token sistemi artık kullanılmıyor
</pre>
		
		<pre class="file" id="file38" style="display: none">package router

import (
        "log"
        "net/http"
        "os"

        "kolajAi/internal/handlers"
        "kolajAi/internal/middleware"
)

var (
        RouterLogger *log.Logger
)

func init() <span class="cov0" title="0">{
        // Router için log dosyası oluştur
        logFile, err := os.OpenFile("router_debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Router log dosyası oluşturulamadı:", err)
                RouterLogger = log.New(os.Stdout, "[ROUTER-DEBUG] ", log.LstdFlags)
        }</span> else<span class="cov0" title="0"> {
                RouterLogger = log.New(logFile, "[ROUTER-DEBUG] ", log.LstdFlags|log.Lshortfile)
        }</span>
}

// NewRouter creates a new router instance
func NewRouter(h *handlers.Handler, static interface{}) http.Handler <span class="cov0" title="0">{
        // Middleware zinciri oluştur
        middlewareChain := middleware.Chain(
                middleware.RequestLogger, // İstek logları
                middleware.Secure,        // Güvenlik başlıkları
        )

        // Ana handler, tüm istekleri önce logla
        mux := http.NewServeMux()

        // Statik dosyalar için handler
        staticDir := "./web/static"
        mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir(staticDir))))

        // Giriş sayfası
        mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("Login route: %s %s", r.Method, r.URL.Path)
                h.Login(w, r)
        }</span>)

        // Kayıt sayfası
        <span class="cov0" title="0">mux.HandleFunc("/register", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("Register route: %s %s", r.Method, r.URL.Path)
                h.Register(w, r)
        }</span>)

        // Şifremi unuttum sayfası
        <span class="cov0" title="0">mux.HandleFunc("/forgot-password", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("ForgotPassword route: %s %s", r.Method, r.URL.Path)
                h.ForgotPassword(w, r)
        }</span>)

        // Şifre sıfırlama sayfası
        <span class="cov0" title="0">mux.HandleFunc("/reset-password", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("ResetPassword route: %s %s", r.Method, r.URL.Path)
                h.ResetPassword(w, r)
        }</span>)

        // Auth gerektiren rotalar için middleware ekle
        <span class="cov0" title="0">authMux := http.NewServeMux()

        // Dashboard sayfası
        authMux.HandleFunc("/dashboard", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("Dashboard route: %s %s", r.Method, r.URL.Path)
                h.Dashboard(w, r)
        }</span>)

        // Çıkış yapma
        <span class="cov0" title="0">authMux.HandleFunc("/logout", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("Logout route: %s %s", r.Method, r.URL.Path)
                h.Logout(w, r)
        }</span>)

        // Auth middleware ile korunan rotaları ana mux'e ekle
        <span class="cov0" title="0">mux.Handle("/dashboard", middleware.Auth(authMux))
        mux.Handle("/logout", middleware.Auth(authMux))

        // Ana sayfa - yönlendirme yap
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                RouterLogger.Printf("Root route: %s %s -&gt; redirecting to /login", r.Method, r.URL.Path)
                http.Redirect(w, r, "/login", http.StatusSeeOther)
        }</span>)

        // Favicon
        <span class="cov0" title="0">mux.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, "web/static/assets/images/favicon-32x32.png")
        }</span>)

        // Log middleware ile sarılmış mux'i döndür
        <span class="cov0" title="0">return middlewareChain(mux)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "math"
        "sort"
        "strings"
)

// AIAnalyticsService provides advanced AI analytics and insights
type AIAnalyticsService struct {
        repo           database.SimpleRepository
        productService *ProductService
        orderService   *OrderService
}

// NewAIAnalyticsService creates a new AI analytics service
func NewAIAnalyticsService(repo database.SimpleRepository, productService *ProductService, orderService *OrderService) *AIAnalyticsService <span class="cov0" title="0">{
        return &amp;AIAnalyticsService{
                repo:           repo,
                productService: productService,
                orderService:   orderService,
        }
}</span>

// MarketTrend represents market trend analysis
type MarketTrend struct {
        CategoryID     int     `json:"category_id"`
        CategoryName   string  `json:"category_name"`
        TrendScore     float64 `json:"trend_score"` // -1 to 1 (declining to growing)
        GrowthRate     float64 `json:"growth_rate"` // Percentage growth
        PopularityRank int     `json:"popularity_rank"`
        AveragePrice   float64 `json:"average_price"`
        TotalProducts  int     `json:"total_products"`
        TotalSales     int     `json:"total_sales"`
        Prediction     string  `json:"prediction"`
}

// ProductInsight represents AI-powered product insights
type ProductInsight struct {
        ProductID        int      `json:"product_id"`
        ProductName      string   `json:"product_name"`
        PerformanceScore float64  `json:"performance_score"` // 0 to 1
        SentimentScore   float64  `json:"sentiment_score"`   // -1 to 1
        MarketPosition   string   `json:"market_position"`   // "leader", "challenger", "follower", "niche"
        Recommendations  []string `json:"recommendations"`
        RiskFactors      []string `json:"risk_factors"`
        Opportunities    []string `json:"opportunities"`
}

// CustomerSegment represents customer behavior analysis
type CustomerSegment struct {
        SegmentID           string   `json:"segment_id"`
        SegmentName         string   `json:"segment_name"`
        CustomerCount       int      `json:"customer_count"`
        AverageSpend        float64  `json:"average_spend"`
        PreferredCategories []string `json:"preferred_categories"`
        BehaviorProfile     string   `json:"behavior_profile"`
        GrowthPotential     float64  `json:"growth_potential"` // 0 to 1
        Characteristics     []string `json:"characteristics"`
}

// PricingStrategy represents AI-powered pricing recommendations
type PricingStrategy struct {
        ProductID         int     `json:"product_id"`
        CurrentPrice      float64 `json:"current_price"`
        OptimalPriceRange struct {
                Min float64 `json:"min"`
                Max float64 `json:"max"`
        } `json:"optimal_price_range"`
        RecommendedPrice float64 `json:"recommended_price"`
        ExpectedImpact   struct {
                SalesChange   float64 `json:"sales_change"`   // Percentage
                RevenueChange float64 `json:"revenue_change"` // Percentage
                MarketShare   float64 `json:"market_share"`   // Percentage
        } `json:"expected_impact"`
        Strategy      string   `json:"strategy"` // "penetration", "skimming", "competitive", "value"
        Justification []string `json:"justification"`
}

// AnalyzeMarketTrends analyzes market trends across categories
func (s *AIAnalyticsService) AnalyzeMarketTrends() ([]*MarketTrend, error) <span class="cov0" title="0">{
        categories, err := s.productService.GetAllCategories()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>

        <span class="cov0" title="0">trends := make([]*MarketTrend, 0)

        for _, category := range categories </span><span class="cov0" title="0">{
                trend, err := s.analyzeCategoryTrend(category)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip categories with insufficient data
                }
                <span class="cov0" title="0">trends = append(trends, trend)</span>
        }

        // Sort by trend score (highest first)
        <span class="cov0" title="0">sort.Slice(trends, func(i, j int) bool </span><span class="cov0" title="0">{
                return trends[i].TrendScore &gt; trends[j].TrendScore
        }</span>)

        // Assign popularity ranks
        <span class="cov0" title="0">for i, trend := range trends </span><span class="cov0" title="0">{
                trend.PopularityRank = i + 1
        }</span>

        <span class="cov0" title="0">return trends, nil</span>
}

// analyzeCategoryTrend analyzes trend for a specific category
func (s *AIAnalyticsService) analyzeCategoryTrend(category models.Category) (*MarketTrend, error) <span class="cov0" title="0">{
        // Get products in this category
        allProducts, err := s.productService.GetAllProducts(1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categoryProducts := make([]models.Product, 0)
        for _, product := range allProducts </span><span class="cov0" title="0">{
                if product.CategoryID == category.ID </span><span class="cov0" title="0">{
                        categoryProducts = append(categoryProducts, product)
                }</span>
        }

        <span class="cov0" title="0">if len(categoryProducts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no products in category")
        }</span>

        // Calculate metrics
        <span class="cov0" title="0">totalProducts := len(categoryProducts)
        totalViews := 0
        totalSales := 0
        totalPrice := 0.0
        recentViews := 0 // Views in last 30 days (simulated)

        for _, product := range categoryProducts </span><span class="cov0" title="0">{
                totalViews += product.ViewCount
                totalSales += product.SalesCount
                totalPrice += product.Price

                // Simulate recent activity (in real implementation, you'd check actual dates)
                if product.ViewCount &gt; 50 </span><span class="cov0" title="0">{
                        recentViews += product.ViewCount / 2 // Assume half are recent
                }</span>
        }

        <span class="cov0" title="0">averagePrice := totalPrice / float64(totalProducts)

        // Calculate trend score (-1 to 1)
        // This is a simplified calculation - in reality you'd use time series analysis
        trendScore := 0.0
        if totalViews &gt; 0 </span><span class="cov0" title="0">{
                recentActivityRatio := float64(recentViews) / float64(totalViews)
                trendScore = (recentActivityRatio - 0.3) * 2 // Normalize to -1 to 1 range
                if trendScore &gt; 1 </span><span class="cov0" title="0">{
                        trendScore = 1
                }</span> else<span class="cov0" title="0"> if trendScore &lt; -1 </span><span class="cov0" title="0">{
                        trendScore = -1
                }</span>
        }

        // Calculate growth rate (simplified)
        <span class="cov0" title="0">growthRate := trendScore * 100 // Convert to percentage

        // Generate prediction
        prediction := s.generateTrendPrediction(trendScore, totalSales, totalViews)

        return &amp;MarketTrend{
                CategoryID:    category.ID,
                CategoryName:  category.Name,
                TrendScore:    trendScore,
                GrowthRate:    growthRate,
                AveragePrice:  averagePrice,
                TotalProducts: totalProducts,
                TotalSales:    totalSales,
                Prediction:    prediction,
        }, nil</span>
}

// generateTrendPrediction generates a human-readable trend prediction
func (s *AIAnalyticsService) generateTrendPrediction(trendScore float64, sales, views int) string <span class="cov0" title="0">{
        if trendScore &gt; 0.5 </span><span class="cov0" title="0">{
                return "Güçlü büyüme trendi - Yatırım fırsatı"
        }</span> else<span class="cov0" title="0"> if trendScore &gt; 0.2 </span><span class="cov0" title="0">{
                return "Pozitif trend - Büyüme potansiyeli var"
        }</span> else<span class="cov0" title="0"> if trendScore &gt; -0.2 </span><span class="cov0" title="0">{
                return "Stabil pazar - Mevcut konumu koruma"
        }</span> else<span class="cov0" title="0"> if trendScore &gt; -0.5 </span><span class="cov0" title="0">{
                return "Düşüş trendi - Dikkatli izleme gerekli"
        }</span> else<span class="cov0" title="0"> {
                return "Güçlü düşüş trendi - Strateji değişikliği öneriliyor"
        }</span>
}

// AnalyzeProductInsights provides comprehensive product analysis
func (s *AIAnalyticsService) AnalyzeProductInsights(productID int) (*ProductInsight, error) <span class="cov0" title="0">{
        product, err := s.productService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>

        // Calculate performance score
        <span class="cov0" title="0">performanceScore := s.calculateProductPerformance(product)

        // Analyze sentiment (simplified - in reality you'd analyze reviews/comments)
        sentimentScore := s.analyzeSentiment(product)

        // Determine market position
        marketPosition := s.determineMarketPosition(product, performanceScore)

        // Generate recommendations
        recommendations := s.generateProductRecommendations(product, performanceScore, sentimentScore)

        // Identify risk factors
        riskFactors := s.identifyRiskFactors(product, performanceScore, sentimentScore)

        // Find opportunities
        opportunities := s.findOpportunities(product, performanceScore, sentimentScore)

        return &amp;ProductInsight{
                ProductID:        productID,
                ProductName:      product.Name,
                PerformanceScore: performanceScore,
                SentimentScore:   sentimentScore,
                MarketPosition:   marketPosition,
                Recommendations:  recommendations,
                RiskFactors:      riskFactors,
                Opportunities:    opportunities,
        }, nil</span>
}

// calculateProductPerformance calculates a performance score for a product
func (s *AIAnalyticsService) calculateProductPerformance(product *models.Product) float64 <span class="cov0" title="0">{
        score := 0.0

        // Sales performance (40% of score)
        if product.SalesCount &gt; 0 </span><span class="cov0" title="0">{
                salesScore := math.Min(float64(product.SalesCount)/100.0, 1.0) // Normalize to 0-1
                score += salesScore * 0.4
        }</span>

        // View performance (30% of score)
        <span class="cov0" title="0">if product.ViewCount &gt; 0 </span><span class="cov0" title="0">{
                viewScore := math.Min(float64(product.ViewCount)/1000.0, 1.0) // Normalize to 0-1
                score += viewScore * 0.3
        }</span>

        // Stock management (20% of score)
        <span class="cov0" title="0">if product.Stock &gt; 0 </span><span class="cov0" title="0">{
                stockScore := 1.0
                if product.Stock &lt; product.MinStock </span><span class="cov0" title="0">{
                        stockScore = 0.5 // Penalty for low stock
                }</span>
                <span class="cov0" title="0">score += stockScore * 0.2</span>
        }

        // Rating performance (10% of score)
        <span class="cov0" title="0">if product.Rating &gt; 0 </span><span class="cov0" title="0">{
                ratingScore := product.Rating / 5.0 // Normalize to 0-1
                score += ratingScore * 0.1
        }</span>

        <span class="cov0" title="0">return math.Min(score, 1.0)</span>
}

// analyzeSentiment analyzes product sentiment (simplified implementation)
func (s *AIAnalyticsService) analyzeSentiment(product *models.Product) float64 <span class="cov0" title="0">{
        // This is a simplified sentiment analysis
        // In a real implementation, you'd analyze actual reviews and comments

        sentiment := 0.0

        // Base sentiment from rating
        if product.Rating &gt; 0 </span><span class="cov0" title="0">{
                sentiment = (product.Rating - 3.0) / 2.0 // Convert 1-5 rating to -1 to 1 scale
        }</span>

        // Adjust based on sales vs views ratio
        <span class="cov0" title="0">if product.ViewCount &gt; 0 </span><span class="cov0" title="0">{
                conversionRate := float64(product.SalesCount) / float64(product.ViewCount)
                if conversionRate &gt; 0.1 </span><span class="cov0" title="0">{ // Good conversion rate
                        sentiment += 0.2
                }</span> else<span class="cov0" title="0"> if conversionRate &lt; 0.02 </span><span class="cov0" title="0">{ // Poor conversion rate
                        sentiment -= 0.2
                }</span>
        }

        // Adjust based on stock levels
        <span class="cov0" title="0">if product.Stock == 0 </span><span class="cov0" title="0">{
                sentiment -= 0.1 // Out of stock is negative
        }</span>

        // Clamp to -1 to 1 range
        <span class="cov0" title="0">if sentiment &gt; 1 </span><span class="cov0" title="0">{
                sentiment = 1
        }</span> else<span class="cov0" title="0"> if sentiment &lt; -1 </span><span class="cov0" title="0">{
                sentiment = -1
        }</span>

        <span class="cov0" title="0">return sentiment</span>
}

// determineMarketPosition determines the market position of a product
func (s *AIAnalyticsService) determineMarketPosition(product *models.Product, performanceScore float64) string <span class="cov0" title="0">{
        if performanceScore &gt; 0.8 </span><span class="cov0" title="0">{
                return "leader"
        }</span> else<span class="cov0" title="0"> if performanceScore &gt; 0.6 </span><span class="cov0" title="0">{
                return "challenger"
        }</span> else<span class="cov0" title="0"> if performanceScore &gt; 0.3 </span><span class="cov0" title="0">{
                return "follower"
        }</span> else<span class="cov0" title="0"> {
                return "niche"
        }</span>
}

// generateProductRecommendations generates actionable recommendations
func (s *AIAnalyticsService) generateProductRecommendations(product *models.Product, performance, sentiment float64) []string <span class="cov0" title="0">{
        recommendations := make([]string, 0)

        if performance &lt; 0.5 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Ürün tanıtımını artırın ve pazarlama stratejisini gözden geçirin")
        }</span>

        <span class="cov0" title="0">if sentiment &lt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Müşteri geri bildirimlerini analiz edin ve ürün kalitesini iyileştirin")
        }</span>

        <span class="cov0" title="0">if product.Stock &lt; product.MinStock </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Stok seviyesini artırın - talep var ancak stok yetersiz")
        }</span>

        <span class="cov0" title="0">if product.ViewCount &gt; product.SalesCount*20 </span><span class="cov0" title="0">{ // High views, low sales
                recommendations = append(recommendations, "Fiyatlandırma stratejisini gözden geçirin - çok görüntüleniyor ama satılmıyor")
        }</span>

        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Mevcut performans iyi - stratejinizi sürdürün")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

// identifyRiskFactors identifies potential risks
func (s *AIAnalyticsService) identifyRiskFactors(product *models.Product, performance, sentiment float64) []string <span class="cov0" title="0">{
        risks := make([]string, 0)

        if sentiment &lt; -0.3 </span><span class="cov0" title="0">{
                risks = append(risks, "Düşük müşteri memnuniyeti - marka imajına zarar verebilir")
        }</span>

        <span class="cov0" title="0">if product.Stock == 0 </span><span class="cov0" title="0">{
                risks = append(risks, "Stok tükendi - müşteri kaybı riski")
        }</span>

        <span class="cov0" title="0">if performance &lt; 0.3 </span><span class="cov0" title="0">{
                risks = append(risks, "Düşük performans - karlılık riski")
        }</span>

        <span class="cov0" title="0">if product.ViewCount &lt; 10 </span><span class="cov0" title="0">{ // Very low visibility
                risks = append(risks, "Düşük görünürlük - pazar payı kaybı riski")
        }</span>

        <span class="cov0" title="0">return risks</span>
}

// findOpportunities identifies growth opportunities
func (s *AIAnalyticsService) findOpportunities(product *models.Product, performance, sentiment float64) []string <span class="cov0" title="0">{
        opportunities := make([]string, 0)

        if sentiment &gt; 0.3 &amp;&amp; performance &lt; 0.7 </span><span class="cov0" title="0">{
                opportunities = append(opportunities, "Yüksek müşteri memnuniyeti - pazarlama yatırımı ile büyüme fırsatı")
        }</span>

        <span class="cov0" title="0">if product.ViewCount &gt; 100 &amp;&amp; product.SalesCount &lt; 10 </span><span class="cov0" title="0">{
                opportunities = append(opportunities, "Yüksek ilgi - fiyat optimizasyonu ile satış artırma fırsatı")
        }</span>

        <span class="cov0" title="0">if performance &gt; 0.7 </span><span class="cov0" title="0">{
                opportunities = append(opportunities, "Güçlü performans - premium fiyatlandırma fırsatı")
        }</span>

        <span class="cov0" title="0">if strings.Contains(strings.ToLower(product.Tags), "trend") </span><span class="cov0" title="0">{
                opportunities = append(opportunities, "Trend ürün - hızlı büyüme potansiyeli")
        }</span>

        <span class="cov0" title="0">return opportunities</span>
}

// AnalyzeCustomerSegments analyzes customer behavior and segments
func (s *AIAnalyticsService) AnalyzeCustomerSegments() ([]*CustomerSegment, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real system, you'd analyze actual customer data

        segments := []*CustomerSegment{
                {
                        SegmentID:           "high_value",
                        SegmentName:         "Yüksek Değerli Müşteriler",
                        CustomerCount:       150,
                        AverageSpend:        500.0,
                        PreferredCategories: []string{"Elektronik", "Moda", "Ev &amp; Yaşam"},
                        BehaviorProfile:     "Sık alışveriş yapan, kaliteye önem veren müşteriler",
                        GrowthPotential:     0.8,
                        Characteristics:     []string{"Yüksek gelir", "Marka sadakati", "Kalite odaklı"},
                },
                {
                        SegmentID:           "price_sensitive",
                        SegmentName:         "Fiyat Hassas Müşteriler",
                        CustomerCount:       300,
                        AverageSpend:        150.0,
                        PreferredCategories: []string{"Gıda", "Temizlik", "Temel İhtiyaçlar"},
                        BehaviorProfile:     "İndirim ve kampanyaları takip eden, fiyat karşılaştırması yapan müşteriler",
                        GrowthPotential:     0.6,
                        Characteristics:     []string{"Fiyat odaklı", "Kampanya takipçisi", "Pratik çözüm arayan"},
                },
                {
                        SegmentID:           "tech_enthusiasts",
                        SegmentName:         "Teknoloji Meraklıları",
                        CustomerCount:       200,
                        AverageSpend:        350.0,
                        PreferredCategories: []string{"Elektronik", "Bilgisayar", "Akıllı Cihazlar"},
                        BehaviorProfile:     "Yeni teknolojileri erken benimseyen, araştırma yapan müşteriler",
                        GrowthPotential:     0.9,
                        Characteristics:     []string{"İnovasyon odaklı", "Araştırmacı", "Sosyal medya aktif"},
                },
        }

        return segments, nil
}</span>

// GeneratePricingStrategy generates AI-powered pricing recommendations
func (s *AIAnalyticsService) GeneratePricingStrategy(productID int) (*PricingStrategy, error) <span class="cov0" title="0">{
        product, err := s.productService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>

        // Get similar products for market analysis
        <span class="cov0" title="0">similarProducts, err := s.getSimilarProductsForPricing(product, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get similar products: %w", err)
        }</span>

        // Calculate optimal price range
        <span class="cov0" title="0">minPrice, maxPrice := s.calculateOptimalPriceRange(product, similarProducts)

        // Determine recommended price
        recommendedPrice := s.calculateRecommendedPrice(product, similarProducts, minPrice, maxPrice)

        // Calculate expected impact
        salesChange, revenueChange, marketShare := s.calculatePriceImpact(product, recommendedPrice)

        // Determine strategy
        strategy := s.determinePricingStrategy(product, recommendedPrice, similarProducts)

        // Generate justification
        justification := s.generatePricingJustification(product, recommendedPrice, strategy)

        return &amp;PricingStrategy{
                ProductID:    productID,
                CurrentPrice: product.Price,
                OptimalPriceRange: struct {
                        Min float64 `json:"min"`
                        Max float64 `json:"max"`
                }{
                        Min: minPrice,
                        Max: maxPrice,
                },
                RecommendedPrice: recommendedPrice,
                ExpectedImpact: struct {
                        SalesChange   float64 `json:"sales_change"`
                        RevenueChange float64 `json:"revenue_change"`
                        MarketShare   float64 `json:"market_share"`
                }{
                        SalesChange:   salesChange,
                        RevenueChange: revenueChange,
                        MarketShare:   marketShare,
                },
                Strategy:      strategy,
                Justification: justification,
        }, nil</span>
}

// Helper methods for pricing strategy
func (s *AIAnalyticsService) getSimilarProductsForPricing(product *models.Product, limit int) ([]*models.Product, error) <span class="cov0" title="0">{
        // Reuse the similar products logic from the main AI service
        allProducts, err := s.productService.GetAllProducts(500, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">scored := make([]struct {
                product *models.Product
                score   float64
        }, 0)

        for _, p := range allProducts </span><span class="cov0" title="0">{
                if p.ID == product.ID || p.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">score := 0.0
                if p.CategoryID == product.CategoryID </span><span class="cov0" title="0">{
                        score += 0.6
                }</span>

                <span class="cov0" title="0">priceDiff := math.Abs(p.Price - product.Price)
                maxPrice := math.Max(p.Price, product.Price)
                if maxPrice &gt; 0 </span><span class="cov0" title="0">{
                        priceScore := 1.0 - (priceDiff / maxPrice)
                        score += priceScore * 0.4
                }</span>

                <span class="cov0" title="0">if score &gt; 0.3 </span><span class="cov0" title="0">{
                        scored = append(scored, struct {
                                product *models.Product
                                score   float64
                        }{product: &amp;p, score: score})
                }</span>
        }

        <span class="cov0" title="0">sort.Slice(scored, func(i, j int) bool </span><span class="cov0" title="0">{
                return scored[i].score &gt; scored[j].score
        }</span>)

        <span class="cov0" title="0">result := make([]*models.Product, 0, limit)
        for i, ps := range scored </span><span class="cov0" title="0">{
                if i &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">result = append(result, ps.product)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (s *AIAnalyticsService) calculateOptimalPriceRange(product *models.Product, similarProducts []*models.Product) (float64, float64) <span class="cov0" title="0">{
        if len(similarProducts) == 0 </span><span class="cov0" title="0">{
                return product.Price * 0.8, product.Price * 1.2
        }</span>

        <span class="cov0" title="0">prices := make([]float64, len(similarProducts))
        for i, p := range similarProducts </span><span class="cov0" title="0">{
                prices[i] = p.Price
        }</span>

        <span class="cov0" title="0">sort.Float64s(prices)

        minPrice := prices[0] * 0.9
        maxPrice := prices[len(prices)-1] * 1.1

        return minPrice, maxPrice</span>
}

func (s *AIAnalyticsService) calculateRecommendedPrice(product *models.Product, similarProducts []*models.Product, minPrice, maxPrice float64) float64 <span class="cov0" title="0">{
        if len(similarProducts) == 0 </span><span class="cov0" title="0">{
                return product.Price
        }</span>

        <span class="cov0" title="0">totalPrice := 0.0
        for _, p := range similarProducts </span><span class="cov0" title="0">{
                totalPrice += p.Price
        }</span>

        <span class="cov0" title="0">marketAverage := totalPrice / float64(len(similarProducts))

        // Adjust based on product performance
        performanceScore := s.calculateProductPerformance(product)
        adjustment := (performanceScore - 0.5) * 0.2 // ±20% adjustment

        recommendedPrice := marketAverage * (1 + adjustment)

        // Ensure it's within the optimal range
        if recommendedPrice &lt; minPrice </span><span class="cov0" title="0">{
                recommendedPrice = minPrice
        }</span> else<span class="cov0" title="0"> if recommendedPrice &gt; maxPrice </span><span class="cov0" title="0">{
                recommendedPrice = maxPrice
        }</span>

        <span class="cov0" title="0">return math.Round(recommendedPrice*100) / 100</span>
}

func (s *AIAnalyticsService) calculatePriceImpact(product *models.Product, newPrice float64) (float64, float64, float64) <span class="cov0" title="0">{
        priceChange := (newPrice - product.Price) / product.Price

        // Simplified elasticity calculation
        // In reality, you'd use historical data and more sophisticated models
        elasticity := -1.5 // Assume price elasticity of demand

        salesChange := elasticity * priceChange * 100
        revenueChange := (1+priceChange)*(1+salesChange/100) - 1
        revenueChange *= 100

        // Market share impact (simplified)
        marketShare := 5.0 + (priceChange * -10) // Lower price = higher market share
        if marketShare &lt; 0 </span><span class="cov0" title="0">{
                marketShare = 0
        }</span> else<span class="cov0" title="0"> if marketShare &gt; 20 </span><span class="cov0" title="0">{
                marketShare = 20
        }</span>

        <span class="cov0" title="0">return salesChange, revenueChange, marketShare</span>
}

func (s *AIAnalyticsService) determinePricingStrategy(product *models.Product, recommendedPrice float64, similarProducts []*models.Product) string <span class="cov0" title="0">{
        if len(similarProducts) == 0 </span><span class="cov0" title="0">{
                return "value"
        }</span>

        <span class="cov0" title="0">totalPrice := 0.0
        for _, p := range similarProducts </span><span class="cov0" title="0">{
                totalPrice += p.Price
        }</span>
        <span class="cov0" title="0">marketAverage := totalPrice / float64(len(similarProducts))

        if recommendedPrice &lt; marketAverage*0.9 </span><span class="cov0" title="0">{
                return "penetration"
        }</span> else<span class="cov0" title="0"> if recommendedPrice &gt; marketAverage*1.1 </span><span class="cov0" title="0">{
                return "skimming"
        }</span> else<span class="cov0" title="0"> if math.Abs(recommendedPrice-marketAverage) &lt; marketAverage*0.05 </span><span class="cov0" title="0">{
                return "competitive"
        }</span> else<span class="cov0" title="0"> {
                return "value"
        }</span>
}

func (s *AIAnalyticsService) generatePricingJustification(product *models.Product, recommendedPrice float64, strategy string) []string <span class="cov0" title="0">{
        justification := make([]string, 0)

        priceChange := recommendedPrice - product.Price
        changePercent := (priceChange / product.Price) * 100

        switch strategy </span>{
        case "penetration":<span class="cov0" title="0">
                justification = append(justification, "Pazar penetrasyon stratejisi - düşük fiyat ile pazar payı artırma")
                justification = append(justification, fmt.Sprintf("%.1f%% fiyat düşürme ile rekabet avantajı", -changePercent))</span>
        case "skimming":<span class="cov0" title="0">
                justification = append(justification, "Fiyat skimming stratejisi - premium konumlandırma")
                justification = append(justification, fmt.Sprintf("%.1f%% fiyat artışı ile yüksek kar marjı", changePercent))</span>
        case "competitive":<span class="cov0" title="0">
                justification = append(justification, "Rekabetçi fiyatlandırma - pazar ortalamasında konumlandırma")
                justification = append(justification, "Mevcut pazar koşullarına uygun fiyat seviyesi")</span>
        case "value":<span class="cov0" title="0">
                justification = append(justification, "Değer odaklı fiyatlandırma - kalite-fiyat dengesi")
                justification = append(justification, "Ürün değeri ile uyumlu fiyat seviyesi")</span>
        }

        <span class="cov0" title="0">if product.ViewCount &gt; product.SalesCount*10 </span><span class="cov0" title="0">{
                justification = append(justification, "Yüksek ilgi ancak düşük satış - fiyat optimizasyonu gerekli")
        }</span>

        <span class="cov0" title="0">return justification</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "math"
        "sort"
        "strings"
        "time"
)

// AIService provides AI-powered features for the marketplace
type AIService struct {
        repo           database.SimpleRepository
        productService *ProductService
        orderService   *OrderService
}

// NewAIService creates a new AI service
func NewAIService(repo database.SimpleRepository, productService *ProductService, orderService *OrderService) *AIService <span class="cov0" title="0">{
        return &amp;AIService{
                repo:           repo,
                productService: productService,
                orderService:   orderService,
        }
}</span>

// ProductRecommendation represents a product recommendation with score
type ProductRecommendation struct {
        Product *models.Product `json:"product"`
        Score   float64         `json:"score"`
        Reason  string          `json:"reason"`
}

// PriceOptimization represents price optimization suggestions
type PriceOptimization struct {
        ProductID          int     `json:"product_id"`
        CurrentPrice       float64 `json:"current_price"`
        SuggestedPrice     float64 `json:"suggested_price"`
        PriceChange        float64 `json:"price_change"`
        PriceChangePercent float64 `json:"price_change_percent"`
        Confidence         float64 `json:"confidence"`
        Reasoning          string  `json:"reasoning"`
}

// CategoryPrediction represents AI-powered category prediction
type CategoryPrediction struct {
        CategoryID   int     `json:"category_id"`
        CategoryName string  `json:"category_name"`
        Confidence   float64 `json:"confidence"`
}

// SearchResult represents enhanced search results with AI scoring
type SearchResult struct {
        Products      []*models.Product `json:"products"`
        TotalCount    int               `json:"total_count"`
        SearchQuery   string            `json:"search_query"`
        ProcessedTime time.Duration     `json:"processed_time"`
        Suggestions   []string          `json:"suggestions"`
}

// GetPersonalizedRecommendations returns personalized product recommendations for a user
func (s *AIService) GetPersonalizedRecommendations(userID int, limit int) ([]*ProductRecommendation, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Get user's order history
        userOrders, err := s.orderService.GetOrdersByUser(userID, 50, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user orders: %w", err)
        }</span>

        // Get user's purchased product categories and brands
        <span class="cov0" title="0">categoryScores := make(map[string]float64)
        brandScores := make(map[string]float64)
        priceRange := struct{ min, max, avg float64 }{math.MaxFloat64, 0, 0}
        totalSpent := 0.0
        orderCount := 0

        for _, order := range userOrders </span><span class="cov0" title="0">{
                orderCount++
                totalSpent += order.TotalAmount

                // Analyze order items (this would need to be implemented in order service)
                // For now, we'll use a simplified approach
                if order.TotalAmount &lt; priceRange.min </span><span class="cov0" title="0">{
                        priceRange.min = order.TotalAmount
                }</span>
                <span class="cov0" title="0">if order.TotalAmount &gt; priceRange.max </span><span class="cov0" title="0">{
                        priceRange.max = order.TotalAmount
                }</span>
        }

        <span class="cov0" title="0">if orderCount &gt; 0 </span><span class="cov0" title="0">{
                priceRange.avg = totalSpent / float64(orderCount)
        }</span>

        // Get all available products
        <span class="cov0" title="0">allProducts, err := s.productService.GetAllProducts(1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products: %w", err)
        }</span>

        <span class="cov0" title="0">recommendations := make([]*ProductRecommendation, 0)

        // Score products based on user preferences
        for _, product := range allProducts </span><span class="cov0" title="0">{
                if product.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">score := s.calculateRecommendationScore(&amp;product, categoryScores, brandScores, priceRange)
                reason := s.generateRecommendationReason(&amp;product, score)

                if score &gt; 0.3 </span><span class="cov0" title="0">{ // Minimum threshold
                        recommendations = append(recommendations, &amp;ProductRecommendation{
                                Product: &amp;product,
                                Score:   score,
                                Reason:  reason,
                        })
                }</span>
        }

        // Sort by score descending
        <span class="cov0" title="0">sort.Slice(recommendations, func(i, j int) bool </span><span class="cov0" title="0">{
                return recommendations[i].Score &gt; recommendations[j].Score
        }</span>)

        // Limit results
        <span class="cov0" title="0">if len(recommendations) &gt; limit </span><span class="cov0" title="0">{
                recommendations = recommendations[:limit]
        }</span>

        <span class="cov0" title="0">fmt.Printf("AI Recommendations generated in %v for user %d\n", time.Since(startTime), userID)
        return recommendations, nil</span>
}

// calculateRecommendationScore calculates a recommendation score for a product
func (s *AIService) calculateRecommendationScore(product *models.Product, categoryScores, brandScores map[string]float64, priceRange struct{ min, max, avg float64 }) float64 <span class="cov0" title="0">{
        score := 0.0

        // Base score from product popularity (view count, rating, etc.)
        if product.ViewCount &gt; 0 </span><span class="cov0" title="0">{
                score += math.Log10(float64(product.ViewCount)) * 0.1
        }</span>

        // Price compatibility score
        <span class="cov0" title="0">if priceRange.avg &gt; 0 </span><span class="cov0" title="0">{
                priceDiff := math.Abs(product.Price - priceRange.avg)
                priceScore := 1.0 - (priceDiff / (priceRange.max - priceRange.min + 1))
                score += priceScore * 0.3
        }</span>

        // Category preference score (we'll need to get category name by ID)
        // For now, skip this feature until we implement category lookup

        // Brand preference score (not available in current model)
        // For now, skip this feature

        // Stock availability boost
        <span class="cov0" title="0">if product.Stock &gt; 0 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        // Recent products get a small boost
        <span class="cov0" title="0">daysSinceCreated := time.Since(product.CreatedAt).Hours() / 24
        if daysSinceCreated &lt; 30 </span><span class="cov0" title="0">{
                score += (30 - daysSinceCreated) / 300 // Max 0.1 boost for newest products
        }</span>

        <span class="cov0" title="0">return math.Min(score, 1.0)</span> // Cap at 1.0
}

// generateRecommendationReason generates a human-readable reason for the recommendation
func (s *AIService) generateRecommendationReason(product *models.Product, score float64) string <span class="cov0" title="0">{
        reasons := []string{}

        if score &gt; 0.8 </span><span class="cov0" title="0">{
                reasons = append(reasons, "Mükemmel eşleşme")
        }</span> else<span class="cov0" title="0"> if score &gt; 0.6 </span><span class="cov0" title="0">{
                reasons = append(reasons, "Yüksek uyumluluk")
        }</span> else<span class="cov0" title="0"> if score &gt; 0.4 </span><span class="cov0" title="0">{
                reasons = append(reasons, "İlginizi çekebilir")
        }</span>

        <span class="cov0" title="0">if product.ViewCount &gt; 100 </span><span class="cov0" title="0">{
                reasons = append(reasons, "Popüler ürün")
        }</span>

        <span class="cov0" title="0">if product.Stock &gt; 0 </span><span class="cov0" title="0">{
                reasons = append(reasons, "Stokta mevcut")
        }</span>

        <span class="cov0" title="0">if len(reasons) == 0 </span><span class="cov0" title="0">{
                reasons = append(reasons, "Size özel öneri")
        }</span>

        <span class="cov0" title="0">return strings.Join(reasons, ", ")</span>
}

// OptimizeProductPricing provides AI-powered price optimization suggestions
func (s *AIService) OptimizeProductPricing(productID int) (*PriceOptimization, error) <span class="cov0" title="0">{
        product, err := s.productService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>

        // Get similar products for price comparison
        <span class="cov0" title="0">similarProducts, err := s.getSimilarProducts(product, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get similar products: %w", err)
        }</span>

        // Calculate market average price
        <span class="cov0" title="0">totalPrice := 0.0
        validProducts := 0
        for _, similar := range similarProducts </span><span class="cov0" title="0">{
                if similar.Price &gt; 0 </span><span class="cov0" title="0">{
                        totalPrice += similar.Price
                        validProducts++
                }</span>
        }

        <span class="cov0" title="0">if validProducts == 0 </span><span class="cov0" title="0">{
                return &amp;PriceOptimization{
                        ProductID:          productID,
                        CurrentPrice:       product.Price,
                        SuggestedPrice:     product.Price,
                        PriceChange:        0,
                        PriceChangePercent: 0,
                        Confidence:         0.1,
                        Reasoning:          "Yeterli karşılaştırma verisi bulunamadı",
                }, nil
        }</span>

        <span class="cov0" title="0">marketAverage := totalPrice / float64(validProducts)

        // Calculate suggested price based on various factors
        suggestedPrice := s.calculateOptimalPrice(product, marketAverage, similarProducts)

        priceChange := suggestedPrice - product.Price
        priceChangePercent := (priceChange / product.Price) * 100

        confidence := s.calculatePriceConfidence(validProducts, product.ViewCount)
        reasoning := s.generatePriceReasoning(product.Price, suggestedPrice, marketAverage)

        return &amp;PriceOptimization{
                ProductID:          productID,
                CurrentPrice:       product.Price,
                SuggestedPrice:     suggestedPrice,
                PriceChange:        priceChange,
                PriceChangePercent: priceChangePercent,
                Confidence:         confidence,
                Reasoning:          reasoning,
        }, nil</span>
}

// getSimilarProducts finds products similar to the given product
func (s *AIService) getSimilarProducts(product *models.Product, limit int) ([]*models.Product, error) <span class="cov0" title="0">{
        // This is a simplified similarity calculation
        // In a real implementation, you might use more sophisticated ML algorithms

        allProducts, err := s.productService.GetAllProducts(500, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">scored := make([]struct {
                product *models.Product
                score   float64
        }, 0)

        for _, p := range allProducts </span><span class="cov0" title="0">{
                if p.ID == product.ID || p.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">score := 0.0

                // Category match (by ID)
                if p.CategoryID == product.CategoryID </span><span class="cov0" title="0">{
                        score += 0.4
                }</span>

                // Brand match (not available in current model, skip for now)

                // Price similarity
                <span class="cov0" title="0">priceDiff := math.Abs(p.Price - product.Price)
                maxPrice := math.Max(p.Price, product.Price)
                if maxPrice &gt; 0 </span><span class="cov0" title="0">{
                        priceScore := 1.0 - (priceDiff / maxPrice)
                        score += priceScore * 0.3
                }</span>

                <span class="cov0" title="0">if score &gt; 0.2 </span><span class="cov0" title="0">{ // Minimum similarity threshold
                        scored = append(scored, struct {
                                product *models.Product
                                score   float64
                        }{product: &amp;p, score: score})
                }</span>
        }

        // Sort by similarity score
        <span class="cov0" title="0">sort.Slice(scored, func(i, j int) bool </span><span class="cov0" title="0">{
                return scored[i].score &gt; scored[j].score
        }</span>)

        // Extract products
        <span class="cov0" title="0">result := make([]*models.Product, 0, limit)
        for i, ps := range scored </span><span class="cov0" title="0">{
                if i &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">result = append(result, ps.product)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// calculateOptimalPrice calculates the optimal price based on market data
func (s *AIService) calculateOptimalPrice(product *models.Product, marketAverage float64, similarProducts []*models.Product) float64 <span class="cov0" title="0">{
        // Base price on market average
        suggestedPrice := marketAverage

        // Adjust based on product characteristics
        if product.ViewCount &gt; 100 </span><span class="cov0" title="0">{
                // Popular products can command higher prices
                suggestedPrice *= 1.05
        }</span>

        <span class="cov0" title="0">if product.Stock &lt; 10 </span><span class="cov0" title="0">{
                // Low stock can justify higher prices
                suggestedPrice *= 1.03
        }</span>

        // Don't suggest extreme price changes
        <span class="cov0" title="0">maxIncrease := product.Price * 1.2 // Max 20% increase
        maxDecrease := product.Price * 0.8 // Max 20% decrease

        if suggestedPrice &gt; maxIncrease </span><span class="cov0" title="0">{
                suggestedPrice = maxIncrease
        }</span> else<span class="cov0" title="0"> if suggestedPrice &lt; maxDecrease </span><span class="cov0" title="0">{
                suggestedPrice = maxDecrease
        }</span>

        // Round to reasonable precision
        <span class="cov0" title="0">return math.Round(suggestedPrice*100) / 100</span>
}

// calculatePriceConfidence calculates confidence level for price suggestions
func (s *AIService) calculatePriceConfidence(similarProductCount, viewCount int) float64 <span class="cov0" title="0">{
        confidence := 0.0

        // More similar products = higher confidence
        confidence += math.Min(float64(similarProductCount)/10.0, 0.5)

        // More views = higher confidence in demand
        confidence += math.Min(float64(viewCount)/1000.0, 0.3)

        // Base confidence
        confidence += 0.2

        return math.Min(confidence, 1.0)
}</span>

// generatePriceReasoning generates human-readable reasoning for price suggestions
func (s *AIService) generatePriceReasoning(currentPrice, suggestedPrice, marketAverage float64) string <span class="cov0" title="0">{
        if math.Abs(suggestedPrice-currentPrice) &lt; 0.01 </span><span class="cov0" title="0">{
                return "Mevcut fiyat optimal seviyede"
        }</span>

        <span class="cov0" title="0">if suggestedPrice &gt; currentPrice </span><span class="cov0" title="0">{
                if suggestedPrice &gt; marketAverage </span><span class="cov0" title="0">{
                        return "Pazar ortalamasının üzerinde fiyatlandırma öneriliyor - ürün kalitesi ve popülaritesi bunu destekliyor"
                }</span>
                <span class="cov0" title="0">return "Pazar koşullarına göre fiyat artışı öneriliyor"</span>
        } else<span class="cov0" title="0"> {
                if suggestedPrice &lt; marketAverage </span><span class="cov0" title="0">{
                        return "Rekabetçi fiyatlandırma için fiyat düşürülmesi öneriliyor"
                }</span>
                <span class="cov0" title="0">return "Pazar ortalamasına yakın fiyatlandırma öneriliyor"</span>
        }
}

// PredictProductCategory predicts the most suitable category for a product
func (s *AIService) PredictProductCategory(productName, description string) ([]*CategoryPrediction, error) <span class="cov0" title="0">{
        // Get all categories
        categories, err := s.productService.GetAllCategories()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>

        <span class="cov0" title="0">predictions := make([]*CategoryPrediction, 0)
        text := strings.ToLower(productName + " " + description)

        for _, category := range categories </span><span class="cov0" title="0">{
                confidence := s.calculateCategoryConfidence(text, strings.ToLower(category.Name))

                if confidence &gt; 0.1 </span><span class="cov0" title="0">{ // Minimum confidence threshold
                        predictions = append(predictions, &amp;CategoryPrediction{
                                CategoryID:   category.ID,
                                CategoryName: category.Name,
                                Confidence:   confidence,
                        })
                }</span>
        }

        // Sort by confidence descending
        <span class="cov0" title="0">sort.Slice(predictions, func(i, j int) bool </span><span class="cov0" title="0">{
                return predictions[i].Confidence &gt; predictions[j].Confidence
        }</span>)

        // Limit to top 5 predictions
        <span class="cov0" title="0">if len(predictions) &gt; 5 </span><span class="cov0" title="0">{
                predictions = predictions[:5]
        }</span>

        <span class="cov0" title="0">return predictions, nil</span>
}

// calculateCategoryConfidence calculates confidence for category prediction
func (s *AIService) calculateCategoryConfidence(text, categoryName string) float64 <span class="cov0" title="0">{
        // Simple keyword matching approach
        // In a real implementation, you'd use more sophisticated NLP/ML

        keywords := strings.Fields(categoryName)
        matches := 0

        for _, keyword := range keywords </span><span class="cov0" title="0">{
                if strings.Contains(text, keyword) </span><span class="cov0" title="0">{
                        matches++
                }</span>
        }

        <span class="cov0" title="0">if len(keywords) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(matches) / float64(len(keywords))</span>
}

// SmartSearch performs AI-enhanced product search
func (s *AIService) SmartSearch(query string, limit, offset int) (*SearchResult, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Get all products for searching
        allProducts, err := s.productService.GetAllProducts(2000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products: %w", err)
        }</span>

        // Score and filter products based on search query
        <span class="cov0" title="0">scored := make([]struct {
                product *models.Product
                score   float64
        }, 0)
        queryLower := strings.ToLower(query)
        queryWords := strings.Fields(queryLower)

        for _, product := range allProducts </span><span class="cov0" title="0">{
                if product.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">score := s.calculateSearchScore(&amp;product, queryLower, queryWords)

                if score &gt; 0 </span><span class="cov0" title="0">{
                        scored = append(scored, struct {
                                product *models.Product
                                score   float64
                        }{product: &amp;product, score: score})
                }</span>
        }

        // Sort by relevance score
        <span class="cov0" title="0">sort.Slice(scored, func(i, j int) bool </span><span class="cov0" title="0">{
                return scored[i].score &gt; scored[j].score
        }</span>)

        // Apply pagination
        <span class="cov0" title="0">totalCount := len(scored)
        start := offset
        end := offset + limit

        if start &gt; totalCount </span><span class="cov0" title="0">{
                start = totalCount
        }</span>
        <span class="cov0" title="0">if end &gt; totalCount </span><span class="cov0" title="0">{
                end = totalCount
        }</span>

        <span class="cov0" title="0">results := make([]*models.Product, 0, end-start)
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                results = append(results, scored[i].product)
        }</span>

        // Generate search suggestions
        <span class="cov0" title="0">suggestions := s.generateSearchSuggestions(query, scored)

        return &amp;SearchResult{
                Products:      results,
                TotalCount:    totalCount,
                SearchQuery:   query,
                ProcessedTime: time.Since(startTime),
                Suggestions:   suggestions,
        }, nil</span>
}

// calculateSearchScore calculates relevance score for search results
func (s *AIService) calculateSearchScore(product *models.Product, query string, queryWords []string) float64 <span class="cov0" title="0">{
        score := 0.0

        productText := strings.ToLower(product.Name + " " + product.Description + " " + product.Tags)

        // Exact phrase match gets highest score
        if strings.Contains(productText, query) </span><span class="cov0" title="0">{
                score += 1.0
        }</span>

        // Individual word matches
        <span class="cov0" title="0">wordMatches := 0
        for _, word := range queryWords </span><span class="cov0" title="0">{
                if strings.Contains(productText, word) </span><span class="cov0" title="0">{
                        wordMatches++
                }</span>
        }

        <span class="cov0" title="0">if len(queryWords) &gt; 0 </span><span class="cov0" title="0">{
                wordScore := float64(wordMatches) / float64(len(queryWords))
                score += wordScore * 0.8
        }</span>

        // Title match bonus
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(product.Name), query) </span><span class="cov0" title="0">{
                score += 0.5
        }</span>

        // Tags match bonus
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(product.Tags), query) </span><span class="cov0" title="0">{
                score += 0.3
        }</span>

        // Popularity boost
        <span class="cov0" title="0">if product.ViewCount &gt; 0 </span><span class="cov0" title="0">{
                popularityBoost := math.Log10(float64(product.ViewCount)) * 0.1
                score += math.Min(popularityBoost, 0.2)
        }</span>

        // Stock availability
        <span class="cov0" title="0">if product.Stock &gt; 0 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// generateSearchSuggestions generates search suggestions based on results
func (s *AIService) generateSearchSuggestions(query string, results []struct {
        product *models.Product
        score   float64
}) []string <span class="cov0" title="0">{
        suggestions := make([]string, 0)

        // Extract common tags from top results
        tagCount := make(map[string]int)

        maxResults := 20
        if len(results) &lt; maxResults </span><span class="cov0" title="0">{
                maxResults = len(results)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; maxResults; i++ </span><span class="cov0" title="0">{
                product := results[i].product

                // Extract individual tags
                if product.Tags != "" </span><span class="cov0" title="0">{
                        tags := strings.Split(product.Tags, ",")
                        for _, tag := range tags </span><span class="cov0" title="0">{
                                tag = strings.TrimSpace(tag)
                                if tag != "" </span><span class="cov0" title="0">{
                                        tagCount[tag]++
                                }</span>
                        }
                }
        }

        // Add tag suggestions
        <span class="cov0" title="0">for tag, count := range tagCount </span><span class="cov0" title="0">{
                if count &gt;= 2 &amp;&amp; !strings.Contains(strings.ToLower(query), strings.ToLower(tag)) </span><span class="cov0" title="0">{
                        suggestions = append(suggestions, query+" "+tag)
                }</span>
        }

        // Limit suggestions
        <span class="cov0" title="0">if len(suggestions) &gt; 5 </span><span class="cov0" title="0">{
                suggestions = suggestions[:5]
        }</span>

        <span class="cov0" title="0">return suggestions</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "time"
)

type AuctionService struct {
        repo database.SimpleRepository
}

func NewAuctionService(repo database.SimpleRepository) *AuctionService <span class="cov0" title="0">{
        return &amp;AuctionService{repo: repo}
}</span>

// CreateAuction creates a new auction
func (s *AuctionService) CreateAuction(auction *models.Auction) error <span class="cov0" title="0">{
        auction.CreatedAt = time.Now()
        auction.UpdatedAt = time.Now()
        if auction.Status == "" </span><span class="cov0" title="0">{
                auction.Status = "draft"
        }</span>
        <span class="cov0" title="0">auction.CurrentBid = auction.StartingPrice
        auction.TotalBids = 0
        auction.ViewCount = 0
        auction.IsReserveMet = false

        id, err := s.repo.CreateStruct("auctions", auction)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create auction: %w", err)
        }</span>
        <span class="cov0" title="0">auction.ID = int(id)
        return nil</span>
}

// GetAuctionByID retrieves an auction by ID
func (s *AuctionService) GetAuctionByID(id int) (*models.Auction, error) <span class="cov0" title="0">{
        var auction models.Auction
        err := s.repo.FindByID("auctions", id, &amp;auction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auction: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;auction, nil</span>
}

// UpdateAuction updates an auction
func (s *AuctionService) UpdateAuction(id int, auction *models.Auction) error <span class="cov0" title="0">{
        auction.UpdatedAt = time.Now()
        err := s.repo.Update("auctions", id, auction)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update auction: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetActiveAuctions retrieves active auctions
func (s *AuctionService) GetActiveAuctions(limit, offset int) ([]models.Auction, error) <span class="cov0" title="0">{
        var auctions []models.Auction
        conditions := map[string]interface{}{"status": "active"}

        err := s.repo.FindAll("auctions", &amp;auctions, conditions, "end_time ASC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active auctions: %w", err)
        }</span>
        <span class="cov0" title="0">return auctions, nil</span>
}

// GetAuctionsByVendor retrieves auctions by vendor ID
func (s *AuctionService) GetAuctionsByVendor(vendorID int, limit, offset int) ([]models.Auction, error) <span class="cov0" title="0">{
        var auctions []models.Auction
        conditions := map[string]interface{}{"vendor_id": vendorID}

        err := s.repo.FindAll("auctions", &amp;auctions, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auctions by vendor: %w", err)
        }</span>
        <span class="cov0" title="0">return auctions, nil</span>
}

// GetEndingAuctions retrieves auctions ending soon
func (s *AuctionService) GetEndingAuctions(hours int, limit, offset int) ([]models.Auction, error) <span class="cov0" title="0">{
        var auctions []models.Auction
        endTime := time.Now().Add(time.Duration(hours) * time.Hour)

        // This would need a custom query in a real implementation
        conditions := map[string]interface{}{"status": "active"}

        err := s.repo.FindAll("auctions", &amp;auctions, conditions, "end_time ASC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ending auctions: %w", err)
        }</span>

        // Filter by end time (in a real implementation, this would be done in SQL)
        <span class="cov0" title="0">var filtered []models.Auction
        for _, auction := range auctions </span><span class="cov0" title="0">{
                if auction.EndTime.Before(endTime) </span><span class="cov0" title="0">{
                        filtered = append(filtered, auction)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// StartAuction starts an auction
func (s *AuctionService) StartAuction(auctionID int) error <span class="cov0" title="0">{
        auction := &amp;models.Auction{
                Status:    "active",
                UpdatedAt: time.Now(),
        }
        return s.UpdateAuction(auctionID, auction)
}</span>

// EndAuction ends an auction
func (s *AuctionService) EndAuction(auctionID int) error <span class="cov0" title="0">{
        auction, err := s.GetAuctionByID(auctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the winning bid
        <span class="cov0" title="0">winningBid, err := s.GetWinningBid(auctionID)
        if err == nil &amp;&amp; winningBid != nil </span><span class="cov0" title="0">{
                auction.WinnerID = &amp;winningBid.UserID
        }</span>

        <span class="cov0" title="0">auction.Status = "ended"
        auction.UpdatedAt = time.Now()

        return s.UpdateAuction(auctionID, auction)</span>
}

// CancelAuction cancels an auction
func (s *AuctionService) CancelAuction(auctionID int) error <span class="cov0" title="0">{
        auction := &amp;models.Auction{
                Status:    "cancelled",
                UpdatedAt: time.Now(),
        }
        return s.UpdateAuction(auctionID, auction)
}</span>

// PlaceBid places a bid on an auction
func (s *AuctionService) PlaceBid(bid *models.AuctionBid) error <span class="cov0" title="0">{
        // Get auction details
        auction, err := s.GetAuctionByID(bid.AuctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate bid
        <span class="cov0" title="0">if err := s.validateBid(auction, bid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark previous bids as not winning
        <span class="cov0" title="0">err = s.markPreviousBidsAsLosing(bid.AuctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the bid
        <span class="cov0" title="0">bid.CreatedAt = time.Now()
        bid.IsWinning = true

        id, err := s.repo.CreateStruct("auction_bids", bid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to place bid: %w", err)
        }</span>
        <span class="cov0" title="0">bid.ID = int(id)

        // Update auction
        auction.CurrentBid = bid.Amount
        auction.TotalBids++
        if auction.ReservePrice &gt; 0 &amp;&amp; bid.Amount &gt;= auction.ReservePrice </span><span class="cov0" title="0">{
                auction.IsReserveMet = true
        }</span>

        // Auto-extend if needed
        <span class="cov0" title="0">if auction.AutoExtend &amp;&amp; time.Until(auction.EndTime) &lt; time.Duration(auction.ExtendMinutes)*time.Minute </span><span class="cov0" title="0">{
                auction.EndTime = auction.EndTime.Add(time.Duration(auction.ExtendMinutes) * time.Minute)
        }</span>

        <span class="cov0" title="0">return s.UpdateAuction(bid.AuctionID, auction)</span>
}

// validateBid validates a bid
func (s *AuctionService) validateBid(auction *models.Auction, bid *models.AuctionBid) error <span class="cov0" title="0">{
        // Check if auction is active
        if auction.Status != "active" </span><span class="cov0" title="0">{
                return fmt.Errorf("auction is not active")
        }</span>

        // Check if auction has ended
        <span class="cov0" title="0">if time.Now().After(auction.EndTime) </span><span class="cov0" title="0">{
                return fmt.Errorf("auction has ended")
        }</span>

        // Check if bid meets minimum increment
        <span class="cov0" title="0">minBid := auction.CurrentBid + auction.BidIncrement
        if bid.Amount &lt; minBid </span><span class="cov0" title="0">{
                return fmt.Errorf("bid must be at least %.2f", minBid)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// markPreviousBidsAsLosing marks all previous bids as not winning
func (s *AuctionService) markPreviousBidsAsLosing(auctionID int) error <span class="cov0" title="0">{
        // In a real implementation, this would be a single SQL UPDATE query
        bids, err := s.GetAuctionBids(auctionID, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, bid := range bids </span><span class="cov0" title="0">{
                if bid.IsWinning </span><span class="cov0" title="0">{
                        bid.IsWinning = false
                        s.repo.Update("auction_bids", bid.ID, &amp;bid)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetAuctionBids retrieves bids for an auction
func (s *AuctionService) GetAuctionBids(auctionID int, limit, offset int) ([]models.AuctionBid, error) <span class="cov0" title="0">{
        var bids []models.AuctionBid
        conditions := map[string]interface{}{"auction_id": auctionID}

        err := s.repo.FindAll("auction_bids", &amp;bids, conditions, "amount DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auction bids: %w", err)
        }</span>
        <span class="cov0" title="0">return bids, nil</span>
}

// GetWinningBid retrieves the winning bid for an auction
func (s *AuctionService) GetWinningBid(auctionID int) (*models.AuctionBid, error) <span class="cov0" title="0">{
        var bid models.AuctionBid
        conditions := map[string]interface{}{
                "auction_id": auctionID,
                "is_winning": true,
        }
        err := s.repo.FindOne("auction_bids", &amp;bid, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get winning bid: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;bid, nil</span>
}

// GetUserBids retrieves bids by a user
func (s *AuctionService) GetUserBids(userID int, limit, offset int) ([]models.AuctionBid, error) <span class="cov0" title="0">{
        var bids []models.AuctionBid
        conditions := map[string]interface{}{"user_id": userID}

        err := s.repo.FindAll("auction_bids", &amp;bids, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user bids: %w", err)
        }</span>
        <span class="cov0" title="0">return bids, nil</span>
}

// AddWatcher adds a user to auction watchers
func (s *AuctionService) AddWatcher(watcher *models.AuctionWatcher) error <span class="cov0" title="0">{
        watcher.CreatedAt = time.Now()

        id, err := s.repo.CreateStruct("auction_watchers", watcher)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add watcher: %w", err)
        }</span>
        <span class="cov0" title="0">watcher.ID = int(id)
        return nil</span>
}

// RemoveWatcher removes a user from auction watchers
func (s *AuctionService) RemoveWatcher(auctionID, userID int) error <span class="cov0" title="0">{
        conditions := map[string]interface{}{
                "auction_id": auctionID,
                "user_id":    userID,
        }

        var watcher models.AuctionWatcher
        err := s.repo.FindOne("auction_watchers", &amp;watcher, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("watcher not found: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.Delete("auction_watchers", watcher.ID)</span>
}

// GetAuctionWatchers retrieves watchers for an auction
func (s *AuctionService) GetAuctionWatchers(auctionID int) ([]models.AuctionWatcher, error) <span class="cov0" title="0">{
        var watchers []models.AuctionWatcher
        conditions := map[string]interface{}{"auction_id": auctionID}

        err := s.repo.FindAll("auction_watchers", &amp;watchers, conditions, "created_at DESC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auction watchers: %w", err)
        }</span>
        <span class="cov0" title="0">return watchers, nil</span>
}

// IsUserWatching checks if a user is watching an auction
func (s *AuctionService) IsUserWatching(auctionID, userID int) (bool, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{
                "auction_id": auctionID,
                "user_id":    userID,
        }

        exists, err := s.repo.Exists("auction_watchers", conditions)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check if user is watching: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

// AddAuctionImage adds an image to an auction
func (s *AuctionService) AddAuctionImage(image *models.AuctionImage) error <span class="cov0" title="0">{
        image.CreatedAt = time.Now()

        id, err := s.repo.CreateStruct("auction_images", image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add auction image: %w", err)
        }</span>
        <span class="cov0" title="0">image.ID = int(id)
        return nil</span>
}

// GetAuctionImages retrieves images for an auction
func (s *AuctionService) GetAuctionImages(auctionID int) ([]models.AuctionImage, error) <span class="cov0" title="0">{
        var images []models.AuctionImage
        conditions := map[string]interface{}{"auction_id": auctionID}

        err := s.repo.FindAll("auction_images", &amp;images, conditions, "sort_order ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get auction images: %w", err)
        }</span>
        <span class="cov0" title="0">return images, nil</span>
}

// IncrementAuctionViews increments auction view count
func (s *AuctionService) IncrementAuctionViews(auctionID int) error <span class="cov0" title="0">{
        auction, err := s.GetAuctionByID(auctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">auction.ViewCount++
        auction.UpdatedAt = time.Now()

        return s.UpdateAuction(auctionID, auction)</span>
}

// GetAuctionStats returns auction statistics
func (s *AuctionService) GetAuctionStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Total auctions
        totalAuctions, err := s.repo.Count("auctions", nil)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_auctions"] = totalAuctions
        }</span>

        // Active auctions
        <span class="cov0" title="0">activeAuctions, err := s.repo.Count("auctions", map[string]interface{}{"status": "active"})
        if err == nil </span><span class="cov0" title="0">{
                stats["active_auctions"] = activeAuctions
        }</span>

        // Ended auctions
        <span class="cov0" title="0">endedAuctions, err := s.repo.Count("auctions", map[string]interface{}{"status": "ended"})
        if err == nil </span><span class="cov0" title="0">{
                stats["ended_auctions"] = endedAuctions
        }</span>

        // Total bids
        <span class="cov0" title="0">totalBids, err := s.repo.Count("auction_bids", nil)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_bids"] = totalBids
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// ProcessExpiredAuctions processes auctions that have expired
func (s *AuctionService) ProcessExpiredAuctions() error <span class="cov0" title="0">{
        // Get active auctions that have ended
        var auctions []models.Auction
        conditions := map[string]interface{}{"status": "active"}

        err := s.repo.FindAll("auctions", &amp;auctions, conditions, "end_time ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get active auctions: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        for _, auction := range auctions </span><span class="cov0" title="0">{
                if auction.EndTime.Before(now) </span><span class="cov0" title="0">{
                        err := s.EndAuction(auction.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error ending auction %d: %v\n", auction.ID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetActiveAuctionCount returns the number of active auctions
func (s *AuctionService) GetActiveAuctionCount() (int64, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{"status": "active"}
        return s.repo.Count("auctions", conditions)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import (
        "fmt"
        "log"
        "strings"

        "kolajAi/internal/config"
        "kolajAi/internal/core"
        "kolajAi/internal/email"
        "kolajAi/internal/models"
        "kolajAi/internal/repository"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// AuthService handles authentication related business logic
type AuthService struct {
        userRepo *repository.UserRepository
        emailSvc *email.Service
        baseURL  string
}

// NewAuthService creates a new authentication service
func NewAuthService(userRepo *repository.UserRepository, emailSvc *email.Service) *AuthService <span class="cov0" title="0">{
        // Yapılandırmadan baseURL'i al, yoksa varsayılan değeri kullan
        baseURL := "http://localhost:8080" // Varsayılan değer
        appConfig, err := config.GetConfig()
        if err == nil &amp;&amp; appConfig != nil </span><span class="cov0" title="0">{
                // Server baseURL bilgisini kullan
                if appConfig.Server.BaseURL != "" </span><span class="cov0" title="0">{
                        baseURL = appConfig.Server.BaseURL
                }</span> else<span class="cov0" title="0"> {
                        // Server host ve port bilgisini kullan
                        if appConfig.Server.Host != "" </span><span class="cov0" title="0">{
                                scheme := "http"
                                if appConfig.Server.Port == 443 </span><span class="cov0" title="0">{
                                        scheme = "https"
                                }</span>
                                <span class="cov0" title="0">baseURL = fmt.Sprintf("%s://%s", scheme, appConfig.Server.Host)
                                if appConfig.Server.Port != 80 &amp;&amp; appConfig.Server.Port != 443 </span><span class="cov0" title="0">{
                                        baseURL = fmt.Sprintf("%s:%d", baseURL, appConfig.Server.Port)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;AuthService{
                userRepo: userRepo,
                emailSvc: emailSvc,
                baseURL:  baseURL,
        }</span>
}

// RegisterUser registers a new user
func (s *AuthService) RegisterUser(userData map[string]string) (int64, error) <span class="cov0" title="0">{
        // Check if email already exists
        email := userData["email"]
        exists, err := s.userRepo.EmailExists(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error checking email existence: %v", err)
                return 0, core.NewDatabaseError("Email kontrolü yapılırken hata oluştu", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                log.Printf("Email already exists: %s", email)
                return 0, core.NewValidationError("Bu e-posta adresi zaten kullanılmakta", map[string][]string{
                        "email": {"Bu e-posta adresi zaten kullanılmakta"},
                })
        }</span>

        // Generate a random password
        <span class="cov0" title="0">randomPassword := s.GenerateRandomPassword(10)
        log.Printf("Generated random password for user %s: %s", email, randomPassword)

        // Hash the password
        hashedPassword, err := s.CreateUserPassword(randomPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating password hash: %v", err)
                return 0, core.NewAuthError("Şifre oluşturma hatası", err)
        }</span>

        // Create user in database
        <span class="cov0" title="0">userID, err := s.userRepo.RegisterUser(
                userData["name"],
                email,
                hashedPassword,
                userData["phone"],
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error registering user: %v", err)
                return 0, core.NewDatabaseError("Kullanıcı kaydı yapılırken hata oluştu", err)
        }</span>

        // Send welcome email with password
        <span class="cov0" title="0">err = s.SendWelcomeEmail(email, userData["name"], randomPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send welcome email: %v", err)
                // Don't fail the registration, just log the error
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

// SendWelcomeEmail sends a welcome email with password to the user
func (s *AuthService) SendWelcomeEmail(to string, name string, password string) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "Name":         name,
                "Email":        to,
                "Password":     password,
                "AlertTitle":   "Hesabınız Oluşturuldu",
                "AlertContent": "Hesabınıza giriş yapmak için aşağıdaki bilgileri kullanabilirsiniz. Güvenliğiniz için lütfen ilk girişinizde şifrenizi değiştirin.",
                "ButtonLink":   s.baseURL + "/reset-password?email=" + to,
        }

        return s.emailSvc.SendTemplateEmail(to, "Hoş Geldiniz - KolajAI", "welcome", data)
}</span>

// LoginUser logs in a user
func (s *AuthService) LoginUser(email, password string) (*models.User, error) <span class="cov0" title="0">{
        // Kullanıcıyı bul
        user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding user for login: %v", err)
                return nil, core.NewAuthError("Kullanıcı bulunamadı", err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                log.Printf("User not found: %s", email)
                return nil, core.NewAuthError("Kullanıcı bulunamadı", nil)
        }</span>

        // Şifre boş mu kontrol et
        <span class="cov0" title="0">if user.Password == "" </span><span class="cov0" title="0">{
                log.Printf("ERROR - LoginUser: Password is empty for user: %s", email)
                return nil, core.NewAuthError("Şifre bulunamadı", nil)
        }</span>

        // Şifre doğrulama
        <span class="cov0" title="0">log.Printf("DEBUG - LoginUser: Comparing passwords for user: %s", email)
        log.Printf("DEBUG - LoginUser: Password from database length: %d", len(user.Password))

        err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid password for user %s: %v", email, err)
                return nil, core.NewAuthError("Geçersiz e-posta veya şifre", err)
        }</span>

        // Hesap aktif mi kontrol et
        <span class="cov0" title="0">if !user.IsActive </span><span class="cov0" title="0">{
                log.Printf("Account not active: %s", email)
                return nil, core.NewAuthError("Hesabınız aktif değil. Lütfen e-postanızı kontrol edin veya yönetici ile iletişime geçin", nil)
        }</span>

        <span class="cov0" title="0">log.Printf("User logged in successfully: %s", email)
        return user, nil</span>
}

// CreateUserPassword creates a hashed password for a user
func (s *AuthService) CreateUserPassword(password string) (string, error) <span class="cov0" title="0">{
        // Şifreyi hashle
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error hashing password: %v", err)
                return "", core.NewAuthError("Şifre hash'leme hatası", err)
        }</span>

        // Hash'lenmiş şifreyi string'e dönüştür
        <span class="cov0" title="0">hashedPasswordStr := string(hashedPassword)
        log.Printf("DEBUG - CreateUserPassword: Hash'lenmiş şifre: %s", hashedPasswordStr)
        log.Printf("DEBUG - CreateUserPassword: Hash'lenmiş şifre bcrypt formatında mı: %v",
                strings.HasPrefix(hashedPasswordStr, "$2a$") ||
                        strings.HasPrefix(hashedPasswordStr, "$2b$") ||
                        strings.HasPrefix(hashedPasswordStr, "$2y$"))

        return hashedPasswordStr, nil</span>
}

// VerifyPassword verifies a password against a hash
func (s *AuthService) VerifyPassword(hashedPassword, password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        return err == nil
}</span>

// GenerateRandomPassword generates a random password
func (s *AuthService) GenerateRandomPassword(length int) string <span class="cov0" title="0">{
        if length &lt; 8 </span><span class="cov0" title="0">{
                length = 8 // Minimum 8 karakter
        }</span>

        <span class="cov0" title="0">return uuid.New().String()[:length]</span>
}

// ActivateAccount activates a user account
func (s *AuthService) ActivateAccount(userID int64) error <span class="cov0" title="0">{
        // Activate the account
        err := s.userRepo.ActivateAccount(userID)
        if err != nil </span><span class="cov0" title="0">{
                return core.NewDatabaseError("Hesap aktifleştirme sırasında hata oluştu", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ForgotPassword initiates the password reset process
func (s *AuthService) ForgotPassword(email string) error <span class="cov0" title="0">{
        // Check if user exists
        user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                // Don't reveal if email exists or not
                log.Printf("Forgot password request for non-existing email: %s", err)
                return nil
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                log.Printf("User not found for forgot password: %s", email)
                return nil // Kullanıcı bulunamadı hatası verme, güvenlik nedeniyle
        }</span>

        // Generate temporary password
        <span class="cov0" title="0">tempPassword := s.GenerateRandomPassword(10)
        log.Printf("Generated temporary password for user %s: %s", email, tempPassword)

        // Hash the password
        hashedPassword, err := s.CreateUserPassword(tempPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating password hash: %v", err)
                return core.NewAuthError("Şifre oluşturma hatası", err)
        }</span>

        // Update user's password
        <span class="cov0" title="0">err = s.userRepo.ResetUserPassword(email, hashedPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error resetting user password: %v", err)
                return core.NewDatabaseError("Şifre sıfırlama işlemi sırasında hata oluştu", err)
        }</span>

        // Send reset email with temp password
        <span class="cov0" title="0">data := map[string]interface{}{
                "Name":         user.Name,
                "Email":        email,
                "Password":     tempPassword,
                "AlertTitle":   "Geçici Şifre",
                "AlertContent": "Aşağıdaki geçici şifre ile giriş yapabilirsiniz. Güvenliğiniz için lütfen giriş yaptıktan sonra şifrenizi değiştirin.",
                "ButtonLink":   s.baseURL + "/reset-password?email=" + email,
        }

        err = s.emailSvc.SendTemplateEmail(email, "Şifre Sıfırlama - KolajAI", "welcome", data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending password reset email: %v", err)
                return core.NewAuthError("Şifre sıfırlama e-postası gönderilemedi", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Password reset email sent to: %s", email)
        return nil</span>
}

// ResetPassword resets a user's password
func (s *AuthService) ResetPassword(email, newPassword string) error <span class="cov0" title="0">{
        // Find user by email
        user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding user for reset password: %v", err)
                return core.NewAuthError("Kullanıcı bulunamadı", err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                log.Printf("User not found for reset password: %s", email)
                return core.NewAuthError("Kullanıcı bulunamadı", nil)
        }</span>

        // Hash the new password
        <span class="cov0" title="0">hashedPassword, err := s.CreateUserPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating password hash: %v", err)
                return core.NewAuthError("Şifre oluşturma hatası", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.ResetUserPassword(email, hashedPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating user password: %v", err)
                return core.NewDatabaseError("Şifre güncelleme işlemi sırasında hata oluştu", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Password successfully reset for user: %s", email)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "math"
        "sort"
        "time"
)

// InventoryService provides inventory management with AI predictions
type InventoryService struct {
        repo           database.SimpleRepository
        productService *ProductService
        orderService   *OrderService
}

// NewInventoryService creates a new inventory service
func NewInventoryService(repo database.SimpleRepository, productService *ProductService, orderService *OrderService) *InventoryService <span class="cov0" title="0">{
        return &amp;InventoryService{
                repo:           repo,
                productService: productService,
                orderService:   orderService,
        }
}</span>

// StockPrediction represents AI-powered stock level predictions
type StockPrediction struct {
        ProductID          int     `json:"product_id"`
        ProductName        string  `json:"product_name"`
        CurrentStock       int     `json:"current_stock"`
        MinStock           int     `json:"min_stock"`
        PredictedDemand    float64 `json:"predicted_demand"` // Units per day
        DaysUntilStockout  int     `json:"days_until_stockout"`
        RecommendedReorder int     `json:"recommended_reorder"`
        ReorderUrgency     string  `json:"reorder_urgency"`  // "critical", "high", "medium", "low"
        ConfidenceLevel    float64 `json:"confidence_level"` // 0 to 1
        SeasonalFactor     float64 `json:"seasonal_factor"`  // Seasonal adjustment
        TrendFactor        float64 `json:"trend_factor"`     // Growth trend factor
}

// InventoryAlert represents inventory alerts and notifications
type InventoryAlert struct {
        ID          string    `json:"id"`
        ProductID   int       `json:"product_id"`
        ProductName string    `json:"product_name"`
        AlertType   string    `json:"alert_type"` // "low_stock", "out_of_stock", "overstock", "reorder"
        Severity    string    `json:"severity"`   // "critical", "high", "medium", "low"
        Message     string    `json:"message"`
        CreatedAt   time.Time `json:"created_at"`
        IsRead      bool      `json:"is_read"`
}

// InventoryOptimization represents inventory optimization recommendations
type InventoryOptimization struct {
        ProductID             int      `json:"product_id"`
        ProductName           string   `json:"product_name"`
        CurrentStock          int      `json:"current_stock"`
        OptimalStock          int      `json:"optimal_stock"`
        OptimalMinStock       int      `json:"optimal_min_stock"`
        OptimalMaxStock       int      `json:"optimal_max_stock"`
        CarryingCost          float64  `json:"carrying_cost"`          // Cost of holding inventory
        StockoutCost          float64  `json:"stockout_cost"`          // Cost of being out of stock
        OptimizationPotential float64  `json:"optimization_potential"` // Potential cost savings
        Recommendations       []string `json:"recommendations"`
}

// SupplierPerformance represents supplier performance metrics
type SupplierPerformance struct {
        SupplierID      int      `json:"supplier_id"`
        SupplierName    string   `json:"supplier_name"`
        DeliveryScore   float64  `json:"delivery_score"` // 0 to 1
        QualityScore    float64  `json:"quality_score"`  // 0 to 1
        PriceScore      float64  `json:"price_score"`    // 0 to 1
        OverallScore    float64  `json:"overall_score"`  // 0 to 1
        OrderCount      int      `json:"order_count"`
        OnTimeDelivery  float64  `json:"on_time_delivery"`  // Percentage
        AverageLeadTime int      `json:"average_lead_time"` // Days
        Recommendations []string `json:"recommendations"`
}

// PredictStockLevels predicts future stock levels for all products
func (s *InventoryService) PredictStockLevels() ([]*StockPrediction, error) <span class="cov0" title="0">{
        products, err := s.productService.GetAllProducts(1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products: %w", err)
        }</span>

        <span class="cov0" title="0">predictions := make([]*StockPrediction, 0)

        for _, product := range products </span><span class="cov0" title="0">{
                if product.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">prediction, err := s.predictProductStock(&amp;product)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip products with insufficient data
                }

                <span class="cov0" title="0">predictions = append(predictions, prediction)</span>
        }

        // Sort by urgency (critical first)
        <span class="cov0" title="0">sort.Slice(predictions, func(i, j int) bool </span><span class="cov0" title="0">{
                urgencyOrder := map[string]int{
                        "critical": 0,
                        "high":     1,
                        "medium":   2,
                        "low":      3,
                }
                return urgencyOrder[predictions[i].ReorderUrgency] &lt; urgencyOrder[predictions[j].ReorderUrgency]
        }</span>)

        <span class="cov0" title="0">return predictions, nil</span>
}

// predictProductStock predicts stock levels for a specific product
func (s *InventoryService) predictProductStock(product *models.Product) (*StockPrediction, error) <span class="cov0" title="0">{
        // Calculate historical demand
        dailyDemand := s.calculateDailyDemand(product)

        // Apply seasonal and trend factors
        seasonalFactor := s.calculateSeasonalFactor(product)
        trendFactor := s.calculateTrendFactor(product)

        // Adjust demand prediction
        predictedDemand := dailyDemand * seasonalFactor * trendFactor

        // Calculate days until stockout
        daysUntilStockout := 0
        if predictedDemand &gt; 0 </span><span class="cov0" title="0">{
                daysUntilStockout = int(float64(product.Stock) / predictedDemand)
        }</span> else<span class="cov0" title="0"> {
                daysUntilStockout = 999 // Very high number if no demand
        }</span>

        // Calculate recommended reorder quantity
        <span class="cov0" title="0">recommendedReorder := s.calculateReorderQuantity(product, predictedDemand)

        // Determine urgency
        urgency := s.determineReorderUrgency(daysUntilStockout, product.Stock, product.MinStock)

        // Calculate confidence level
        confidence := s.calculatePredictionConfidence(product)

        return &amp;StockPrediction{
                ProductID:          product.ID,
                ProductName:        product.Name,
                CurrentStock:       product.Stock,
                MinStock:           product.MinStock,
                PredictedDemand:    predictedDemand,
                DaysUntilStockout:  daysUntilStockout,
                RecommendedReorder: recommendedReorder,
                ReorderUrgency:     urgency,
                ConfidenceLevel:    confidence,
                SeasonalFactor:     seasonalFactor,
                TrendFactor:        trendFactor,
        }, nil</span>
}

// calculateDailyDemand calculates average daily demand for a product
func (s *InventoryService) calculateDailyDemand(product *models.Product) float64 <span class="cov0" title="0">{
        // This is a simplified calculation
        // In a real implementation, you'd analyze historical sales data

        if product.SalesCount == 0 </span><span class="cov0" title="0">{
                return 0.1 // Very low demand for products with no sales
        }</span>

        // Assume the product has been available for 30 days (simplified)
        // In reality, you'd calculate from the actual creation date
        <span class="cov0" title="0">daysSinceCreation := 30.0

        // Calculate daily demand based on total sales
        dailyDemand := float64(product.SalesCount) / daysSinceCreation

        // Add some randomness based on view count (interest level)
        interestFactor := math.Min(float64(product.ViewCount)/1000.0, 2.0) + 0.5
        dailyDemand *= interestFactor

        return math.Max(dailyDemand, 0.1)</span> // Minimum demand
}

// calculateSeasonalFactor calculates seasonal adjustment factor
func (s *InventoryService) calculateSeasonalFactor(product *models.Product) float64 <span class="cov0" title="0">{
        // This is a simplified seasonal calculation
        // In reality, you'd analyze historical seasonal patterns

        now := time.Now()
        month := now.Month()

        // Simple seasonal factors by month
        seasonalFactors := map[time.Month]float64{
                time.January:   0.8, // Post-holiday slowdown
                time.February:  0.9, // Winter
                time.March:     1.0, // Spring starts
                time.April:     1.1, // Spring
                time.May:       1.2, // Spring peak
                time.June:      1.1, // Early summer
                time.July:      1.0, // Summer
                time.August:    0.9, // Late summer
                time.September: 1.1, // Back to school
                time.October:   1.2, // Fall shopping
                time.November:  1.4, // Pre-holiday
                time.December:  1.5, // Holiday peak
        }

        return seasonalFactors[month]
}</span>

// calculateTrendFactor calculates growth trend factor
func (s *InventoryService) calculateTrendFactor(product *models.Product) float64 <span class="cov0" title="0">{
        // This is a simplified trend calculation
        // In reality, you'd analyze time series data

        // Use view count as a proxy for trend
        if product.ViewCount &gt; 500 </span><span class="cov0" title="0">{
                return 1.3 // Growing trend
        }</span> else<span class="cov0" title="0"> if product.ViewCount &gt; 100 </span><span class="cov0" title="0">{
                return 1.1 // Moderate growth
        }</span> else<span class="cov0" title="0"> if product.ViewCount &gt; 50 </span><span class="cov0" title="0">{
                return 1.0 // Stable
        }</span> else<span class="cov0" title="0"> {
                return 0.8 // Declining
        }</span>
}

// calculateReorderQuantity calculates optimal reorder quantity
func (s *InventoryService) calculateReorderQuantity(product *models.Product, dailyDemand float64) int <span class="cov0" title="0">{
        // Economic Order Quantity (EOQ) simplified calculation
        // EOQ = sqrt(2 * D * S / H)
        // D = annual demand, S = ordering cost, H = holding cost

        annualDemand := dailyDemand * 365
        orderingCost := 50.0               // Simplified ordering cost
        holdingCost := product.Price * 0.2 // 20% of product price per year

        if holdingCost &lt;= 0 </span><span class="cov0" title="0">{
                holdingCost = 1.0 // Minimum holding cost
        }</span>

        <span class="cov0" title="0">eoq := math.Sqrt(2 * annualDemand * orderingCost / holdingCost)

        // Ensure minimum order quantity
        minOrder := int(dailyDemand * 30) // 30 days worth
        if int(eoq) &lt; minOrder </span><span class="cov0" title="0">{
                return minOrder
        }</span>

        <span class="cov0" title="0">return int(eoq)</span>
}

// determineReorderUrgency determines the urgency level for reordering
func (s *InventoryService) determineReorderUrgency(daysUntilStockout, currentStock, minStock int) string <span class="cov0" title="0">{
        if currentStock &lt;= 0 </span><span class="cov0" title="0">{
                return "critical"
        }</span> else<span class="cov0" title="0"> if currentStock &lt;= minStock </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if daysUntilStockout &lt;= 7 </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if daysUntilStockout &lt;= 14 </span><span class="cov0" title="0">{
                return "medium"
        }</span> else<span class="cov0" title="0"> {
                return "low"
        }</span>
}

// calculatePredictionConfidence calculates confidence level for predictions
func (s *InventoryService) calculatePredictionConfidence(product *models.Product) float64 <span class="cov0" title="0">{
        confidence := 0.5 // Base confidence

        // More sales history = higher confidence
        if product.SalesCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if product.SalesCount &gt; 10 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span> else<span class="cov0" title="0"> if product.SalesCount &gt; 0 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        // More views = higher confidence in demand pattern
        <span class="cov0" title="0">if product.ViewCount &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span> else<span class="cov0" title="0"> if product.ViewCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        <span class="cov0" title="0">return math.Min(confidence, 1.0)</span>
}

// GenerateInventoryAlerts generates inventory alerts based on current stock levels
func (s *InventoryService) GenerateInventoryAlerts() ([]*InventoryAlert, error) <span class="cov0" title="0">{
        products, err := s.productService.GetAllProducts(1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products: %w", err)
        }</span>

        <span class="cov0" title="0">alerts := make([]*InventoryAlert, 0)

        for _, product := range products </span><span class="cov0" title="0">{
                if product.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Generate alerts for this product
                <span class="cov0" title="0">productAlerts := s.generateProductAlerts(&amp;product)
                alerts = append(alerts, productAlerts...)</span>
        }

        // Sort by severity
        <span class="cov0" title="0">sort.Slice(alerts, func(i, j int) bool </span><span class="cov0" title="0">{
                severityOrder := map[string]int{
                        "critical": 0,
                        "high":     1,
                        "medium":   2,
                        "low":      3,
                }
                return severityOrder[alerts[i].Severity] &lt; severityOrder[alerts[j].Severity]
        }</span>)

        <span class="cov0" title="0">return alerts, nil</span>
}

// generateProductAlerts generates alerts for a specific product
func (s *InventoryService) generateProductAlerts(product *models.Product) []*InventoryAlert <span class="cov0" title="0">{
        alerts := make([]*InventoryAlert, 0)
        now := time.Now()

        // Out of stock alert
        if product.Stock &lt;= 0 </span><span class="cov0" title="0">{
                alerts = append(alerts, &amp;InventoryAlert{
                        ID:          fmt.Sprintf("out_of_stock_%d_%d", product.ID, now.Unix()),
                        ProductID:   product.ID,
                        ProductName: product.Name,
                        AlertType:   "out_of_stock",
                        Severity:    "critical",
                        Message:     fmt.Sprintf("Ürün '%s' stokta yok!", product.Name),
                        CreatedAt:   now,
                        IsRead:      false,
                })
        }</span>

        // Low stock alert
        <span class="cov0" title="0">if product.Stock &gt; 0 &amp;&amp; product.Stock &lt;= product.MinStock </span><span class="cov0" title="0">{
                alerts = append(alerts, &amp;InventoryAlert{
                        ID:          fmt.Sprintf("low_stock_%d_%d", product.ID, now.Unix()),
                        ProductID:   product.ID,
                        ProductName: product.Name,
                        AlertType:   "low_stock",
                        Severity:    "high",
                        Message:     fmt.Sprintf("Ürün '%s' stoku düşük: %d adet kaldı", product.Name, product.Stock),
                        CreatedAt:   now,
                        IsRead:      false,
                })
        }</span>

        // Predict future stockout
        <span class="cov0" title="0">prediction, err := s.predictProductStock(product)
        if err == nil &amp;&amp; prediction.DaysUntilStockout &lt;= 7 &amp;&amp; prediction.DaysUntilStockout &gt; 0 </span><span class="cov0" title="0">{
                alerts = append(alerts, &amp;InventoryAlert{
                        ID:          fmt.Sprintf("predicted_stockout_%d_%d", product.ID, now.Unix()),
                        ProductID:   product.ID,
                        ProductName: product.Name,
                        AlertType:   "reorder",
                        Severity:    "medium",
                        Message:     fmt.Sprintf("Ürün '%s' tahmini %d gün içinde tükenecek", product.Name, prediction.DaysUntilStockout),
                        CreatedAt:   now,
                        IsRead:      false,
                })
        }</span>

        <span class="cov0" title="0">return alerts</span>
}

// OptimizeInventory provides inventory optimization recommendations
func (s *InventoryService) OptimizeInventory() ([]*InventoryOptimization, error) <span class="cov0" title="0">{
        products, err := s.productService.GetAllProducts(1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products: %w", err)
        }</span>

        <span class="cov0" title="0">optimizations := make([]*InventoryOptimization, 0)

        for _, product := range products </span><span class="cov0" title="0">{
                if product.Status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">optimization := s.optimizeProductInventory(&amp;product)
                if optimization != nil </span><span class="cov0" title="0">{
                        optimizations = append(optimizations, optimization)
                }</span>
        }

        // Sort by optimization potential (highest savings first)
        <span class="cov0" title="0">sort.Slice(optimizations, func(i, j int) bool </span><span class="cov0" title="0">{
                return optimizations[i].OptimizationPotential &gt; optimizations[j].OptimizationPotential
        }</span>)

        <span class="cov0" title="0">return optimizations, nil</span>
}

// optimizeProductInventory optimizes inventory for a specific product
func (s *InventoryService) optimizeProductInventory(product *models.Product) *InventoryOptimization <span class="cov0" title="0">{
        // Calculate daily demand
        dailyDemand := s.calculateDailyDemand(product)

        // Calculate optimal stock levels
        optimalStock := int(dailyDemand * 30)    // 30 days worth
        optimalMinStock := int(dailyDemand * 7)  // 7 days worth
        optimalMaxStock := int(dailyDemand * 60) // 60 days worth

        // Calculate costs
        carryingCost := s.calculateCarryingCost(product, optimalStock)
        stockoutCost := s.calculateStockoutCost(product, dailyDemand)

        // Calculate optimization potential
        currentCost := s.calculateCarryingCost(product, product.Stock)
        optimizationPotential := math.Abs(currentCost - carryingCost)

        // Generate recommendations
        recommendations := s.generateInventoryRecommendations(product, optimalStock, optimalMinStock, optimalMaxStock)

        return &amp;InventoryOptimization{
                ProductID:             product.ID,
                ProductName:           product.Name,
                CurrentStock:          product.Stock,
                OptimalStock:          optimalStock,
                OptimalMinStock:       optimalMinStock,
                OptimalMaxStock:       optimalMaxStock,
                CarryingCost:          carryingCost,
                StockoutCost:          stockoutCost,
                OptimizationPotential: optimizationPotential,
                Recommendations:       recommendations,
        }
}</span>

// calculateCarryingCost calculates the cost of carrying inventory
func (s *InventoryService) calculateCarryingCost(product *models.Product, stockLevel int) float64 <span class="cov0" title="0">{
        // Carrying cost = (Average inventory value) * (Carrying rate)
        averageInventoryValue := float64(stockLevel) * product.Price / 2
        carryingRate := 0.25 // 25% annual carrying cost

        return averageInventoryValue * carryingRate / 365 // Daily carrying cost
}</span>

// calculateStockoutCost calculates the cost of being out of stock
func (s *InventoryService) calculateStockoutCost(product *models.Product, dailyDemand float64) float64 <span class="cov0" title="0">{
        // Stockout cost = Lost sales + Customer dissatisfaction
        // Simplified: Assume we lose the profit margin on lost sales
        profitMargin := product.Price * 0.3 // Assume 30% profit margin

        return dailyDemand * profitMargin
}</span>

// generateInventoryRecommendations generates optimization recommendations
func (s *InventoryService) generateInventoryRecommendations(product *models.Product, optimalStock, optimalMinStock, optimalMaxStock int) []string <span class="cov0" title="0">{
        recommendations := make([]string, 0)

        if product.Stock &gt; optimalMaxStock </span><span class="cov0" title="0">{
                recommendations = append(recommendations, fmt.Sprintf("Stok seviyesi çok yüksek - %d adet azaltın", product.Stock-optimalStock))
        }</span> else<span class="cov0" title="0"> if product.Stock &lt; optimalMinStock </span><span class="cov0" title="0">{
                recommendations = append(recommendations, fmt.Sprintf("Stok seviyesi çok düşük - %d adet ekleyin", optimalStock-product.Stock))
        }</span>

        <span class="cov0" title="0">if product.MinStock != optimalMinStock </span><span class="cov0" title="0">{
                recommendations = append(recommendations, fmt.Sprintf("Minimum stok seviyesini %d olarak güncelleyin", optimalMinStock))
        }</span>

        // Add general recommendations
        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Mevcut stok seviyeleri optimal aralıkta")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

// AnalyzeSupplierPerformance analyzes supplier performance metrics
func (s *InventoryService) AnalyzeSupplierPerformance() ([]*SupplierPerformance, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real system, you'd analyze actual supplier data

        suppliers := []*SupplierPerformance{
                {
                        SupplierID:      1,
                        SupplierName:    "ABC Tedarikçi",
                        DeliveryScore:   0.92,
                        QualityScore:    0.88,
                        PriceScore:      0.85,
                        OverallScore:    0.88,
                        OrderCount:      45,
                        OnTimeDelivery:  92.0,
                        AverageLeadTime: 5,
                        Recommendations: []string{
                                "Kalite kontrolünü artırın",
                                "Fiyat rekabetçiliğini iyileştirin",
                        },
                },
                {
                        SupplierID:      2,
                        SupplierName:    "XYZ Tedarik",
                        DeliveryScore:   0.95,
                        QualityScore:    0.95,
                        PriceScore:      0.78,
                        OverallScore:    0.89,
                        OrderCount:      32,
                        OnTimeDelivery:  95.0,
                        AverageLeadTime: 3,
                        Recommendations: []string{
                                "Mükemmel performans - tercih edilen tedarikçi",
                                "Fiyat müzakereleri yapılabilir",
                        },
                },
                {
                        SupplierID:      3,
                        SupplierName:    "DEF Supply",
                        DeliveryScore:   0.75,
                        QualityScore:    0.82,
                        PriceScore:      0.92,
                        OverallScore:    0.83,
                        OrderCount:      28,
                        OnTimeDelivery:  75.0,
                        AverageLeadTime: 8,
                        Recommendations: []string{
                                "Teslimat performansını iyileştirin",
                                "Lead time'ı kısaltın",
                                "Fiyat avantajını koruyun",
                        },
                },
        }

        // Sort by overall score
        sort.Slice(suppliers, func(i, j int) bool </span><span class="cov0" title="0">{
                return suppliers[i].OverallScore &gt; suppliers[j].OverallScore
        }</span>)

        <span class="cov0" title="0">return suppliers, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "time"
)

type OrderService struct {
        repo database.SimpleRepository
}

func NewOrderService(repo database.SimpleRepository) *OrderService <span class="cov0" title="0">{
        return &amp;OrderService{repo: repo}
}</span>

// CreateOrder creates a new order
func (s *OrderService) CreateOrder(order *models.Order) error <span class="cov0" title="0">{
        order.CreatedAt = time.Now()
        order.UpdatedAt = time.Now()
        if order.Status == "" </span><span class="cov0" title="0">{
                order.Status = "pending"
        }</span>
        <span class="cov0" title="0">if order.PaymentStatus == "" </span><span class="cov0" title="0">{
                order.PaymentStatus = "pending"
        }</span>
        <span class="cov0" title="0">if order.Currency == "" </span><span class="cov0" title="0">{
                order.Currency = "TRY"
        }</span>

        // Generate order number if not provided
        <span class="cov0" title="0">if order.OrderNumber == "" </span><span class="cov0" title="0">{
                order.OrderNumber = s.generateOrderNumber()
        }</span>

        <span class="cov0" title="0">id, err := s.repo.CreateStruct("orders", order)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create order: %w", err)
        }</span>
        <span class="cov0" title="0">order.ID = int(id)
        return nil</span>
}

// GetOrderByID retrieves an order by ID
func (s *OrderService) GetOrderByID(id int) (*models.Order, error) <span class="cov0" title="0">{
        var order models.Order
        err := s.repo.FindByID("orders", id, &amp;order)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;order, nil</span>
}

// GetOrderByNumber retrieves an order by order number
func (s *OrderService) GetOrderByNumber(orderNumber string) (*models.Order, error) <span class="cov0" title="0">{
        var order models.Order
        conditions := map[string]interface{}{"order_number": orderNumber}
        err := s.repo.FindOne("orders", &amp;order, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order by number: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;order, nil</span>
}

// UpdateOrder updates an order
func (s *OrderService) UpdateOrder(id int, order *models.Order) error <span class="cov0" title="0">{
        order.UpdatedAt = time.Now()
        err := s.repo.Update("orders", id, order)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update order: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetOrdersByUser retrieves orders by user ID
func (s *OrderService) GetOrdersByUser(userID int, limit, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        var orders []models.Order
        conditions := map[string]interface{}{"user_id": userID}

        err := s.repo.FindAll("orders", &amp;orders, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get orders by user: %w", err)
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

// GetOrdersByStatus retrieves orders by status
func (s *OrderService) GetOrdersByStatus(status string, limit, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        var orders []models.Order
        conditions := map[string]interface{}{"status": status}

        err := s.repo.FindAll("orders", &amp;orders, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get orders by status: %w", err)
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

// AddOrderItem adds an item to an order
func (s *OrderService) AddOrderItem(item *models.OrderItem) error <span class="cov0" title="0">{
        id, err := s.repo.CreateStruct("order_items", item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add order item: %w", err)
        }</span>
        <span class="cov0" title="0">item.ID = int(id)
        return nil</span>
}

// GetOrderItems retrieves items for an order
func (s *OrderService) GetOrderItems(orderID int) ([]models.OrderItem, error) <span class="cov0" title="0">{
        var items []models.OrderItem
        conditions := map[string]interface{}{"order_id": orderID}

        err := s.repo.FindAll("order_items", &amp;items, conditions, "id ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

// AddOrderAddress adds an address to an order
func (s *OrderService) AddOrderAddress(address *models.OrderAddress) error <span class="cov0" title="0">{
        id, err := s.repo.CreateStruct("order_addresses", address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add order address: %w", err)
        }</span>
        <span class="cov0" title="0">address.ID = int(id)
        return nil</span>
}

// GetOrderAddresses retrieves addresses for an order
func (s *OrderService) GetOrderAddresses(orderID int) ([]models.OrderAddress, error) <span class="cov0" title="0">{
        var addresses []models.OrderAddress
        conditions := map[string]interface{}{"order_id": orderID}

        err := s.repo.FindAll("order_addresses", &amp;addresses, conditions, "type ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order addresses: %w", err)
        }</span>
        <span class="cov0" title="0">return addresses, nil</span>
}

// ConfirmOrder confirms an order
func (s *OrderService) ConfirmOrder(orderID int) error <span class="cov0" title="0">{
        order := &amp;models.Order{
                Status:    "confirmed",
                UpdatedAt: time.Now(),
        }
        return s.UpdateOrder(orderID, order)
}</span>

// ShipOrder marks an order as shipped
func (s *OrderService) ShipOrder(orderID int, trackingNumber string) error <span class="cov0" title="0">{
        now := time.Now()
        order := &amp;models.Order{
                Status:         "shipped",
                TrackingNumber: trackingNumber,
                ShippedAt:      &amp;now,
                UpdatedAt:      now,
        }
        return s.UpdateOrder(orderID, order)
}</span>

// DeliverOrder marks an order as delivered
func (s *OrderService) DeliverOrder(orderID int) error <span class="cov0" title="0">{
        now := time.Now()
        order := &amp;models.Order{
                Status:      "delivered",
                DeliveredAt: &amp;now,
                UpdatedAt:   now,
        }
        return s.UpdateOrder(orderID, order)
}</span>

// CancelOrder cancels an order
func (s *OrderService) CancelOrder(orderID int) error <span class="cov0" title="0">{
        order := &amp;models.Order{
                Status:    "cancelled",
                UpdatedAt: time.Now(),
        }
        return s.UpdateOrder(orderID, order)
}</span>

// UpdatePaymentStatus updates the payment status of an order
func (s *OrderService) UpdatePaymentStatus(orderID int, paymentStatus string) error <span class="cov0" title="0">{
        order := &amp;models.Order{
                PaymentStatus: paymentStatus,
                UpdatedAt:     time.Now(),
        }
        return s.UpdateOrder(orderID, order)
}</span>

// GetOrderStats returns order statistics
func (s *OrderService) GetOrderStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Total orders
        totalOrders, err := s.repo.Count("orders", nil)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_orders"] = totalOrders
        }</span>

        // Pending orders
        <span class="cov0" title="0">pendingOrders, err := s.repo.Count("orders", map[string]interface{}{"status": "pending"})
        if err == nil </span><span class="cov0" title="0">{
                stats["pending_orders"] = pendingOrders
        }</span>

        // Confirmed orders
        <span class="cov0" title="0">confirmedOrders, err := s.repo.Count("orders", map[string]interface{}{"status": "confirmed"})
        if err == nil </span><span class="cov0" title="0">{
                stats["confirmed_orders"] = confirmedOrders
        }</span>

        // Shipped orders
        <span class="cov0" title="0">shippedOrders, err := s.repo.Count("orders", map[string]interface{}{"status": "shipped"})
        if err == nil </span><span class="cov0" title="0">{
                stats["shipped_orders"] = shippedOrders
        }</span>

        // Delivered orders
        <span class="cov0" title="0">deliveredOrders, err := s.repo.Count("orders", map[string]interface{}{"status": "delivered"})
        if err == nil </span><span class="cov0" title="0">{
                stats["delivered_orders"] = deliveredOrders
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// GetVendorOrders retrieves orders for a vendor
func (s *OrderService) GetVendorOrders(vendorID int, limit, offset int) ([]models.OrderItem, error) <span class="cov0" title="0">{
        var items []models.OrderItem
        conditions := map[string]interface{}{"vendor_id": vendorID}

        err := s.repo.FindAll("order_items", &amp;items, conditions, "id DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get vendor orders: %w", err)
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

// generateOrderNumber generates a unique order number
func (s *OrderService) generateOrderNumber() string <span class="cov0" title="0">{
        timestamp := time.Now().Unix()
        return fmt.Sprintf("ORD-%d", timestamp)
}</span>

// Cart Management

// CreateCart creates a new cart
func (s *OrderService) CreateCart(cart *models.Cart) error <span class="cov0" title="0">{
        cart.CreatedAt = time.Now()
        cart.UpdatedAt = time.Now()

        id, err := s.repo.CreateStruct("carts", cart)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cart: %w", err)
        }</span>
        <span class="cov0" title="0">cart.ID = int(id)
        return nil</span>
}

// GetCartByUser retrieves cart by user ID
func (s *OrderService) GetCartByUser(userID int) (*models.Cart, error) <span class="cov0" title="0">{
        var cart models.Cart
        conditions := map[string]interface{}{"user_id": userID}
        err := s.repo.FindOne("carts", &amp;cart, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cart by user: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;cart, nil</span>
}

// GetCartBySession retrieves cart by session ID
func (s *OrderService) GetCartBySession(sessionID string) (*models.Cart, error) <span class="cov0" title="0">{
        var cart models.Cart
        conditions := map[string]interface{}{"session_id": sessionID}
        err := s.repo.FindOne("carts", &amp;cart, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cart by session: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;cart, nil</span>
}

// AddCartItem adds an item to cart
func (s *OrderService) AddCartItem(item *models.CartItem) error <span class="cov0" title="0">{
        item.CreatedAt = time.Now()
        item.UpdatedAt = time.Now()

        // Check if item already exists in cart
        existing, err := s.GetCartItem(item.CartID, item.ProductID, item.VariantID)
        if err == nil </span><span class="cov0" title="0">{
                // Update quantity
                existing.Quantity += item.Quantity
                existing.UpdatedAt = time.Now()
                return s.repo.Update("cart_items", existing.ID, existing)
        }</span>

        <span class="cov0" title="0">id, err := s.repo.CreateStruct("cart_items", item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add cart item: %w", err)
        }</span>
        <span class="cov0" title="0">item.ID = int(id)
        return nil</span>
}

// GetCartItem retrieves a specific cart item
func (s *OrderService) GetCartItem(cartID, productID int, variantID *int) (*models.CartItem, error) <span class="cov0" title="0">{
        var item models.CartItem
        conditions := map[string]interface{}{
                "cart_id":    cartID,
                "product_id": productID,
        }
        if variantID != nil </span><span class="cov0" title="0">{
                conditions["variant_id"] = *variantID
        }</span>

        <span class="cov0" title="0">err := s.repo.FindOne("cart_items", &amp;item, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cart item: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;item, nil</span>
}

// GetCartItems retrieves all items in a cart
func (s *OrderService) GetCartItems(cartID int) ([]models.CartItem, error) <span class="cov0" title="0">{
        var items []models.CartItem
        conditions := map[string]interface{}{"cart_id": cartID}

        err := s.repo.FindAll("cart_items", &amp;items, conditions, "created_at ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cart items: %w", err)
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

// UpdateCartItem updates a cart item
func (s *OrderService) UpdateCartItem(itemID int, item *models.CartItem) error <span class="cov0" title="0">{
        item.UpdatedAt = time.Now()
        err := s.repo.Update("cart_items", itemID, item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update cart item: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RemoveCartItem removes an item from cart
func (s *OrderService) RemoveCartItem(itemID int) error <span class="cov0" title="0">{
        err := s.repo.Delete("cart_items", itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove cart item: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ClearCart removes all items from a cart
func (s *OrderService) ClearCart(cartID int) error <span class="cov0" title="0">{
        items, err := s.GetCartItems(cartID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, item := range items </span><span class="cov0" title="0">{
                if err := s.RemoveCartItem(item.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "strings"
        "time"
)

type ProductService struct {
        repo database.SimpleRepository
}

func NewProductService(repo database.SimpleRepository) *ProductService <span class="cov8" title="1">{
        return &amp;ProductService{repo: repo}
}</span>

// CreateProduct creates a new product
func (s *ProductService) CreateProduct(product *models.Product) error <span class="cov0" title="0">{
        product.CreatedAt = time.Now()
        product.UpdatedAt = time.Now()
        if product.Status == "" </span><span class="cov0" title="0">{
                product.Status = "draft"
        }</span>

        <span class="cov0" title="0">id, err := s.repo.CreateStruct("products", product)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create product: %w", err)
        }</span>
        <span class="cov0" title="0">product.ID = int(id)
        return nil</span>
}

// GetProductByID retrieves a product by ID
func (s *ProductService) GetProductByID(id int) (*models.Product, error) <span class="cov0" title="0">{
        var product models.Product
        err := s.repo.FindByID("products", id, &amp;product)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

// UpdateProduct updates a product
func (s *ProductService) UpdateProduct(id int, product *models.Product) error <span class="cov0" title="0">{
        product.UpdatedAt = time.Now()
        err := s.repo.Update("products", id, product)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update product: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteProduct soft deletes a product
func (s *ProductService) DeleteProduct(id int) error <span class="cov0" title="0">{
        err := s.repo.SoftDelete("products", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete product: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetProductsByVendor retrieves products by vendor ID
func (s *ProductService) GetProductsByVendor(vendorID int, limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        conditions := map[string]interface{}{"vendor_id": vendorID}

        err := s.repo.FindAll("products", &amp;products, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products by vendor: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

// GetProductsByCategory retrieves products by category ID
func (s *ProductService) GetProductsByCategory(categoryID int, limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        conditions := map[string]interface{}{
                "category_id": categoryID,
                "status":      "active",
        }

        err := s.repo.FindAll("products", &amp;products, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get products by category: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

// SearchProducts searches for products
func (s *ProductService) SearchProducts(term string, limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        fields := []string{"name", "description", "tags"}

        err := s.repo.Search("products", fields, term, limit, offset, &amp;products)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search products: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

// GetFeaturedProducts retrieves featured products
func (s *ProductService) GetFeaturedProducts(limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        conditions := map[string]interface{}{
                "is_featured": true,
                "status":      "active",
        }

        err := s.repo.FindAll("products", &amp;products, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get featured products: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

// UpdateProductStock updates product stock
func (s *ProductService) UpdateProductStock(productID int, quantity int) error <span class="cov0" title="0">{
        product, err := s.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">product.Stock = quantity
        product.UpdatedAt = time.Now()

        // Update status based on stock
        if quantity &lt;= 0 </span><span class="cov0" title="0">{
                product.Status = "out_of_stock"
        }</span> else<span class="cov0" title="0"> if product.Status == "out_of_stock" </span><span class="cov0" title="0">{
                product.Status = "active"
        }</span>

        <span class="cov0" title="0">return s.UpdateProduct(productID, product)</span>
}

// IncrementProductViews increments product view count
func (s *ProductService) IncrementProductViews(productID int) error <span class="cov0" title="0">{
        product, err := s.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">product.ViewCount++
        product.UpdatedAt = time.Now()

        return s.UpdateProduct(productID, product)</span>
}

// IncrementProductSales increments product sales count
func (s *ProductService) IncrementProductSales(productID int, quantity int) error <span class="cov0" title="0">{
        product, err := s.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">product.SalesCount += quantity
        product.Stock -= quantity
        product.UpdatedAt = time.Now()

        // Update status if out of stock
        if product.Stock &lt;= 0 </span><span class="cov0" title="0">{
                product.Status = "out_of_stock"
        }</span>

        <span class="cov0" title="0">return s.UpdateProduct(productID, product)</span>
}

// CreateCategory creates a new category
func (s *ProductService) CreateCategory(category *models.Category) error <span class="cov0" title="0">{
        category.CreatedAt = time.Now()
        category.UpdatedAt = time.Now()

        id, err := s.repo.CreateStruct("categories", category)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create category: %w", err)
        }</span>
        <span class="cov0" title="0">category.ID = int(id)
        return nil</span>
}

// GetAllCategories retrieves all categories
func (s *ProductService) GetAllCategories() ([]models.Category, error) <span class="cov0" title="0">{
        var categories []models.Category
        conditions := map[string]interface{}{"is_active": true}

        err := s.repo.FindAll("categories", &amp;categories, conditions, "sort_order ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get categories: %w", err)
        }</span>
        <span class="cov0" title="0">return categories, nil</span>
}

// GetCategoryByID retrieves a category by ID
func (s *ProductService) GetCategoryByID(id int) (*models.Category, error) <span class="cov0" title="0">{
        var category models.Category
        err := s.repo.FindByID("categories", id, &amp;category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;category, nil</span>
}

// AddProductImage adds an image to a product
func (s *ProductService) AddProductImage(image *models.ProductImage) error <span class="cov0" title="0">{
        image.CreatedAt = time.Now()

        id, err := s.repo.CreateStruct("product_images", image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add product image: %w", err)
        }</span>
        <span class="cov0" title="0">image.ID = int(id)
        return nil</span>
}

// GetProductImages retrieves images for a product
func (s *ProductService) GetProductImages(productID int) ([]models.ProductImage, error) <span class="cov0" title="0">{
        var images []models.ProductImage
        conditions := map[string]interface{}{"product_id": productID}

        err := s.repo.FindAll("product_images", &amp;images, conditions, "sort_order ASC", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product images: %w", err)
        }</span>
        <span class="cov0" title="0">return images, nil</span>
}

// AddProductReview adds a review to a product
func (s *ProductService) AddProductReview(review *models.ProductReview) error <span class="cov0" title="0">{
        review.CreatedAt = time.Now()
        review.UpdatedAt = time.Now()
        if review.Status == "" </span><span class="cov0" title="0">{
                review.Status = "pending"
        }</span>

        <span class="cov0" title="0">id, err := s.repo.CreateStruct("product_reviews", review)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add product review: %w", err)
        }</span>
        <span class="cov0" title="0">review.ID = int(id)

        // Update product rating
        go s.updateProductRating(review.ProductID)

        return nil</span>
}

// GetProductReviews retrieves reviews for a product
func (s *ProductService) GetProductReviews(productID int, limit, offset int) ([]models.ProductReview, error) <span class="cov0" title="0">{
        var reviews []models.ProductReview
        conditions := map[string]interface{}{
                "product_id": productID,
                "status":     "approved",
        }

        err := s.repo.FindAll("product_reviews", &amp;reviews, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product reviews: %w", err)
        }</span>
        <span class="cov0" title="0">return reviews, nil</span>
}

// updateProductRating updates the average rating for a product
func (s *ProductService) updateProductRating(productID int) <span class="cov0" title="0">{
        // This would typically be done with a SQL query to calculate average
        // For now, we'll implement a basic version
        reviews, err := s.GetProductReviews(productID, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(reviews) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var totalRating float64
        for _, review := range reviews </span><span class="cov0" title="0">{
                totalRating += float64(review.Rating)
        }</span>

        <span class="cov0" title="0">avgRating := totalRating / float64(len(reviews))

        product, err := s.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">product.Rating = avgRating
        product.ReviewCount = len(reviews)
        product.UpdatedAt = time.Now()

        s.UpdateProduct(productID, product)</span>
}

// GetProductsBySKU retrieves a product by SKU
func (s *ProductService) GetProductBySKU(sku string) (*models.Product, error) <span class="cov0" title="0">{
        var product models.Product
        conditions := map[string]interface{}{"sku": sku}
        err := s.repo.FindOne("products", &amp;product, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product by SKU: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

// GenerateSKU generates a unique SKU for a product
func (s *ProductService) GenerateSKU(productName string, vendorID int) string <span class="cov0" title="0">{
        // Simple SKU generation logic
        prefix := strings.ToUpper(strings.ReplaceAll(productName[:min(3, len(productName))], " ", ""))
        timestamp := time.Now().Unix()
        return fmt.Sprintf("%s-%d-%d", prefix, vendorID, timestamp)
}</span>

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// GetProductCount returns the total number of products
func (s *ProductService) GetProductCount() (int64, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{}
        return s.repo.Count("products", conditions)
}</span>

// GetAllProducts returns all products with pagination
func (s *ProductService) GetAllProducts(limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        conditions := map[string]interface{}{}
        err := s.repo.FindAll("products", &amp;products, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all products: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

// GetRecentProducts returns recently added products
func (s *ProductService) GetRecentProducts(limit int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        conditions := map[string]interface{}{}
        err := s.repo.FindAll("products", &amp;products, conditions, "created_at DESC", limit, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent products: %w", err)
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package services

import (
        "fmt"
        "kolajAi/internal/database"
        "kolajAi/internal/models"
        "time"
)

type VendorService struct {
        repo database.SimpleRepository
}

func NewVendorService(repo database.SimpleRepository) *VendorService <span class="cov0" title="0">{
        return &amp;VendorService{repo: repo}
}</span>

// CreateVendor creates a new vendor
func (s *VendorService) CreateVendor(vendor *models.Vendor) error <span class="cov0" title="0">{
        vendor.CreatedAt = time.Now()
        vendor.UpdatedAt = time.Now()
        vendor.Status = "pending"
        vendor.Rating = 0.0
        vendor.TotalSales = 0.0
        vendor.Commission = 5.0

        id, err := s.repo.CreateStruct("vendors", vendor)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create vendor: %w", err)
        }</span>
        <span class="cov0" title="0">vendor.ID = int(id)
        return nil</span>
}

// GetVendorByID retrieves a vendor by ID
func (s *VendorService) GetVendorByID(id int) (*models.Vendor, error) <span class="cov0" title="0">{
        var vendor models.Vendor
        err := s.repo.FindByID("vendors", id, &amp;vendor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get vendor: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;vendor, nil</span>
}

// GetVendorByUserID retrieves a vendor by user ID
func (s *VendorService) GetVendorByUserID(userID int) (*models.Vendor, error) <span class="cov0" title="0">{
        var vendor models.Vendor
        conditions := map[string]interface{}{"user_id": userID}
        err := s.repo.FindOne("vendors", &amp;vendor, conditions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get vendor by user ID: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;vendor, nil</span>
}

// UpdateVendor updates a vendor
func (s *VendorService) UpdateVendor(id int, vendor *models.Vendor) error <span class="cov0" title="0">{
        vendor.UpdatedAt = time.Now()
        err := s.repo.Update("vendors", id, vendor)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update vendor: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ApproveVendor approves a vendor
func (s *VendorService) ApproveVendor(id int) error <span class="cov0" title="0">{
        vendor := &amp;models.Vendor{
                Status:    "approved",
                UpdatedAt: time.Now(),
        }
        return s.UpdateVendor(id, vendor)
}</span>

// RejectVendor rejects a vendor
func (s *VendorService) RejectVendor(id int) error <span class="cov0" title="0">{
        vendor := &amp;models.Vendor{
                Status:    "rejected",
                UpdatedAt: time.Now(),
        }
        return s.UpdateVendor(id, vendor)
}</span>

// SuspendVendor suspends a vendor
func (s *VendorService) SuspendVendor(id int) error <span class="cov0" title="0">{
        vendor := &amp;models.Vendor{
                Status:    "suspended",
                UpdatedAt: time.Now(),
        }
        return s.UpdateVendor(id, vendor)
}</span>

// GetAllVendors retrieves all vendors with pagination (overloaded for admin)
func (s *VendorService) GetAllVendors(limit, offset int) ([]models.Vendor, error) <span class="cov0" title="0">{
        var vendors []models.Vendor
        conditions := map[string]interface{}{}
        err := s.repo.FindAll("vendors", &amp;vendors, conditions, "created_at DESC", limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all vendors: %w", err)
        }</span>
        <span class="cov0" title="0">return vendors, nil</span>
}

// GetPendingVendors returns vendors waiting for approval
func (s *VendorService) GetPendingVendors() ([]models.Vendor, error) <span class="cov0" title="0">{
        var vendors []models.Vendor
        conditions := map[string]interface{}{"status": "pending"}
        err := s.repo.FindAll("vendors", &amp;vendors, conditions, "created_at ASC", 10, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending vendors: %w", err)
        }</span>
        <span class="cov0" title="0">return vendors, nil</span>
}

// GetVendorStats returns vendor statistics
func (s *VendorService) GetVendorStats(vendorID int) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get total products
        productCount, err := s.repo.Count("products", map[string]interface{}{"vendor_id": vendorID})
        if err == nil </span><span class="cov0" title="0">{
                stats["total_products"] = productCount
        }</span>

        // Get total orders
        <span class="cov0" title="0">orderCount, err := s.repo.Count("order_items", map[string]interface{}{"vendor_id": vendorID})
        if err == nil </span><span class="cov0" title="0">{
                stats["total_orders"] = orderCount
        }</span>

        // Get vendor info
        <span class="cov0" title="0">vendor, err := s.GetVendorByID(vendorID)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_sales"] = vendor.TotalSales
                stats["rating"] = vendor.Rating
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// UpdateVendorRating updates vendor rating
func (s *VendorService) UpdateVendorRating(vendorID int, rating float64) error <span class="cov0" title="0">{
        vendor := &amp;models.Vendor{
                Rating:    rating,
                UpdatedAt: time.Now(),
        }
        return s.UpdateVendor(vendorID, vendor)
}</span>

// AddVendorSale adds to vendor's total sales
func (s *VendorService) AddVendorSale(vendorID int, amount float64) error <span class="cov0" title="0">{
        vendor, err := s.GetVendorByID(vendorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">vendor.TotalSales += amount
        vendor.UpdatedAt = time.Now()

        return s.UpdateVendor(vendorID, vendor)</span>
}

// GetVendorCount returns the total number of vendors
func (s *VendorService) GetVendorCount() (int64, error) <span class="cov0" title="0">{
        conditions := map[string]interface{}{}
        return s.repo.Count("vendors", conditions)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package components

import (
        "bytes"
        "fmt"
        "html/template"
        "strings"
        "time"

        "kolajAi/internal/config"
)

// Notification represents a notification in the system
type Notification struct {
        ID          string                 `json:"id"`
        Type        string                 `json:"type"`
        Title       string                 `json:"title"`
        Message     string                 `json:"message"`
        Dismissible bool                   `json:"dismissible"`
        AutoDismiss bool                   `json:"auto_dismiss"`
        DismissTime time.Duration          `json:"dismiss_time"`
        Icon        string                 `json:"icon"`
        Color       string                 `json:"color"`
        CreatedAt   time.Time              `json:"created_at"`
        Target      string                 `json:"target"`
        Data        map[string]interface{} `json:"data"`
        Template    string                 `json:"template"`
}

// NotificationManager manages all notifications in the system
type NotificationManager struct {
        config      config.NotificationConfig
        templates   *template.Template
        typeConfigs map[string]config.NotificationType
}

// NewNotificationManager creates a new notification manager
func NewNotificationManager(templates *template.Template) (*NotificationManager, error) <span class="cov0" title="0">{
        cfg, ok := config.GetNotificationConfig()
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get notification config")
        }</span>

        <span class="cov0" title="0">return &amp;NotificationManager{
                config:      cfg,
                templates:   templates,
                typeConfigs: cfg.Types,
        }, nil</span>
}

// NewNotification creates a new notification with defaults based on type
func (m *NotificationManager) NewNotification(notificationType, title, message string) *Notification <span class="cov0" title="0">{
        typeConfig, exists := m.typeConfigs[notificationType]

        now := time.Now()
        id := fmt.Sprintf("notify-%d-%s", now.UnixNano(), strings.ToLower(notificationType))

        n := &amp;Notification{
                ID:          id,
                Type:        notificationType,
                Title:       title,
                Message:     message,
                Dismissible: true,
                AutoDismiss: true,
                DismissTime: m.config.DefaultTTL,
                CreatedAt:   now,
                Data:        make(map[string]interface{}),
        }

        // Apply type-specific settings
        if exists </span><span class="cov0" title="0">{
                n.Icon = typeConfig.Icon
                n.Color = typeConfig.Color
                n.Template = typeConfig.Template
        }</span> else<span class="cov0" title="0"> {
                // Default values
                n.Icon = "info-circle"
                n.Color = "primary"
                n.Template = "notifications/default"
        }</span>

        <span class="cov0" title="0">return n</span>
}

// Info creates a new info notification
func (m *NotificationManager) Info(title, message string) *Notification <span class="cov0" title="0">{
        return m.NewNotification("info", title, message)
}</span>

// Success creates a new success notification
func (m *NotificationManager) Success(title, message string) *Notification <span class="cov0" title="0">{
        return m.NewNotification("success", title, message)
}</span>

// Warning creates a new warning notification
func (m *NotificationManager) Warning(title, message string) *Notification <span class="cov0" title="0">{
        return m.NewNotification("warning", title, message)
}</span>

// Error creates a new error notification
func (m *NotificationManager) Error(title, message string) *Notification <span class="cov0" title="0">{
        return m.NewNotification("error", title, message)
}</span>

// WithIcon sets the icon for the notification
func (n *Notification) WithIcon(icon string) *Notification <span class="cov0" title="0">{
        n.Icon = icon
        return n
}</span>

// WithColor sets the color for the notification
func (n *Notification) WithColor(color string) *Notification <span class="cov0" title="0">{
        n.Color = color
        return n
}</span>

// WithDismissible sets whether the notification is dismissible
func (n *Notification) WithDismissible(dismissible bool) *Notification <span class="cov0" title="0">{
        n.Dismissible = dismissible
        return n
}</span>

// WithAutoDismiss sets whether the notification auto dismisses
func (n *Notification) WithAutoDismiss(autoDismiss bool) *Notification <span class="cov0" title="0">{
        n.AutoDismiss = autoDismiss
        return n
}</span>

// WithDismissTime sets the time after which the notification auto dismisses
func (n *Notification) WithDismissTime(dismissTime time.Duration) *Notification <span class="cov0" title="0">{
        n.DismissTime = dismissTime
        return n
}</span>

// WithTarget sets the target element for the notification
func (n *Notification) WithTarget(target string) *Notification <span class="cov0" title="0">{
        n.Target = target
        return n
}</span>

// WithData adds custom data to the notification
func (n *Notification) WithData(key string, value interface{}) *Notification <span class="cov0" title="0">{
        n.Data[key] = value
        return n
}</span>

// WithTemplate sets a custom template for the notification
func (n *Notification) WithTemplate(template string) *Notification <span class="cov0" title="0">{
        n.Template = template
        return n
}</span>

// RenderToHTML renders the notification to HTML
func (n *Notification) RenderToHTML(templates *template.Template) (string, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        // Use specified template or fallback to a default template
        templateName := n.Template
        if templateName == "" </span><span class="cov0" title="0">{
                templateName = "notifications/default"
        }</span>

        // Execute the template
        <span class="cov0" title="0">err := templates.ExecuteTemplate(&amp;buf, templateName, n)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to render notification template %s: %w", templateName, err)
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}

// ToMap converts the notification to a map for JSON serialization
func (n *Notification) ToMap() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "id":           n.ID,
                "type":         n.Type,
                "title":        n.Title,
                "message":      n.Message,
                "dismissible":  n.Dismissible,
                "auto_dismiss": n.AutoDismiss,
                "dismiss_time": n.DismissTime.Milliseconds(),
                "icon":         n.Icon,
                "color":        n.Color,
                "created_at":   n.CreatedAt.Format(time.RFC3339),
                "target":       n.Target,
                "data":         n.Data,
        }
}</span>

// ToScript converts the notification to a JavaScript snippet for client-side rendering
func (n *Notification) ToScript() string <span class="cov0" title="0">{
        // Simple implementation for now
        return fmt.Sprintf(`
        window.addEventListener('DOMContentLoaded', function() {
                var notification = %s;
                if (window.KolajAI &amp;&amp; window.KolajAI.notifications) {
                        window.KolajAI.notifications.show(notification);
                } else {
                        console.warn('KolajAI notifications module not loaded');
                        alert('%s: %s');
                }
        });
        `, toJSON(n.ToMap()), n.Title, n.Message)
}</span>

// toJSON converts a value to a JSON string
func toJSON(v interface{}) string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return "null"
        }</span>

        <span class="cov0" title="0">switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return fmt.Sprintf(`"%s"`, val)</span>
        case int, int32, int64, float32, float64, bool:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        case []interface{}:<span class="cov0" title="0">
                items := make([]string, len(val))
                for i, item := range val </span><span class="cov0" title="0">{
                        items[i] = toJSON(item)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(items, ","))</span>
        case map[string]interface{}:<span class="cov0" title="0">
                items := make([]string, 0, len(val))
                for k, v := range val </span><span class="cov0" title="0">{
                        items = append(items, fmt.Sprintf(`"%s":%s`, k, toJSON(v)))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("{%s}", strings.Join(items, ","))</span>
        }

        <span class="cov0" title="0">return "null"</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package rendering

import (
        "bytes"
        "fmt"
        "html/template"
        "net/http"
        "strings"

        "kolajAi/internal/ui/components"
)

// ComponentData, UI bileşenlerine aktarılacak verilerin genel yapısı
type ComponentData map[string]interface{}

// ComponentRenderer, UI bileşenlerini işleyen yardımcı
type ComponentRenderer struct {
        templates       *template.Template
        notificationMgr *components.NotificationManager
}

// NewComponentRenderer, yeni bir bileşen işleyici oluşturur
func NewComponentRenderer(templates *template.Template) (*ComponentRenderer, error) <span class="cov0" title="0">{
        notifyMgr, err := components.NewNotificationManager(templates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create notification manager: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ComponentRenderer{
                templates:       templates,
                notificationMgr: notifyMgr,
        }, nil</span>
}

// RenderComponent, belirtilen bileşeni verilen verilerle işler
func (r *ComponentRenderer) RenderComponent(name string, data interface{}) (template.HTML, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        err := r.templates.ExecuteTemplate(&amp;buf, name, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to render component %s: %w", name, err)
        }</span>
        <span class="cov0" title="0">return template.HTML(buf.String()), nil</span>
}

// RenderPartial renders a partial template to HTML
func (r *ComponentRenderer) RenderPartial(name string, data interface{}) (template.HTML, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        err := r.templates.ExecuteTemplate(&amp;buf, name, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to render partial %s: %w", name, err)
        }</span>
        <span class="cov0" title="0">return template.HTML(buf.String()), nil</span>
}

// InfoNotification creates and renders an info notification
func (r *ComponentRenderer) InfoNotification(title, message string) (template.HTML, error) <span class="cov0" title="0">{
        notification := r.notificationMgr.Info(title, message)
        html, err := notification.RenderToHTML(r.templates)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return template.HTML(html), nil</span>
}

// SuccessNotification creates and renders a success notification
func (r *ComponentRenderer) SuccessNotification(title, message string) (template.HTML, error) <span class="cov0" title="0">{
        notification := r.notificationMgr.Success(title, message)
        html, err := notification.RenderToHTML(r.templates)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return template.HTML(html), nil</span>
}

// WarningNotification creates and renders a warning notification
func (r *ComponentRenderer) WarningNotification(title, message string) (template.HTML, error) <span class="cov0" title="0">{
        notification := r.notificationMgr.Warning(title, message)
        html, err := notification.RenderToHTML(r.templates)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return template.HTML(html), nil</span>
}

// ErrorNotification creates and renders an error notification
func (r *ComponentRenderer) ErrorNotification(title, message string) (template.HTML, error) <span class="cov0" title="0">{
        notification := r.notificationMgr.Error(title, message)
        html, err := notification.RenderToHTML(r.templates)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return template.HTML(html), nil</span>
}

// CustomNotification creates and renders a custom notification
func (r *ComponentRenderer) CustomNotification(notificationType, title, message string) (template.HTML, error) <span class="cov0" title="0">{
        notification := r.notificationMgr.NewNotification(notificationType, title, message)
        html, err := notification.RenderToHTML(r.templates)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return template.HTML(html), nil</span>
}

// GetNotificationManager returns the notification manager
func (r *ComponentRenderer) GetNotificationManager() *components.NotificationManager <span class="cov0" title="0">{
        return r.notificationMgr
}</span>

// RenderBreadcrumb renders a breadcrumb component
func (r *ComponentRenderer) RenderBreadcrumb(items []map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "items": items,
        }
        return r.RenderComponent("components/breadcrumb", data)
}</span>

// RenderCard renders a card component
func (r *ComponentRenderer) RenderCard(title, content string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "title":   title,
                "content": template.HTML(content),
        }

        // Merge options
        for k, v := range options </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return r.RenderComponent("components/card", data)</span>
}

// RenderTable renders a table component
func (r *ComponentRenderer) RenderTable(headers []string, rows [][]string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "headers": headers,
                "rows":    rows,
        }

        // Merge options
        for k, v := range options </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return r.RenderComponent("components/table", data)</span>
}

// RenderButton renders a button component
func (r *ComponentRenderer) RenderButton(text, url string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "text": text,
                "url":  url,
        }

        // Set defaults
        if _, ok := options["color"]; !ok </span><span class="cov0" title="0">{
                data["color"] = "primary"
        }</span>

        <span class="cov0" title="0">if _, ok := options["size"]; !ok </span><span class="cov0" title="0">{
                data["size"] = "md"
        }</span>

        // Merge options
        <span class="cov0" title="0">for k, v := range options </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return r.RenderComponent("components/button", data)</span>
}

// RenderAlert renders an alert component
func (r *ComponentRenderer) RenderAlert(messageOrAlertType string, options interface{}) (template.HTML, error) <span class="cov0" title="0">{
        // Önce parametrelere göre fonksiyon davranışını belirle
        if options == nil </span><span class="cov0" title="0">{
                // Tek parametre durumu - yalnızca mesaj verildiyse
                return r.RenderComponent("alert-color", ComponentData{
                        "Type":    "info",
                        "Content": messageOrAlertType,
                })
        }</span>

        // Options map[string]interface{} tipinde mi?
        <span class="cov0" title="0">if optionsMap, ok := options.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Eski fonksiyon imzası için: RenderAlert(message string, options map[string]interface{})
                data := map[string]interface{}{
                        "message": template.HTML(messageOrAlertType),
                }

                // Set defaults
                if _, ok := optionsMap["type"]; !ok </span><span class="cov0" title="0">{
                        data["type"] = "info"
                }</span>

                <span class="cov0" title="0">if _, ok := optionsMap["dismissible"]; !ok </span><span class="cov0" title="0">{
                        data["dismissible"] = true
                }</span>

                // Merge options
                <span class="cov0" title="0">for k, v := range optionsMap </span><span class="cov0" title="0">{
                        data[k] = v
                }</span>

                <span class="cov0" title="0">return r.RenderComponent("components/alert", data)</span>
        }

        // Options string tipinde mi?
        <span class="cov0" title="0">if content, ok := options.(string); ok </span><span class="cov0" title="0">{
                // Yeni fonksiyon imzası için: RenderAlert(alertType string, content string)
                return r.RenderComponent("alert-color", ComponentData{
                        "Type":    messageOrAlertType,
                        "Content": content,
                })
        }</span>

        // Desteklenmeyen parametre tipi
        <span class="cov0" title="0">return template.HTML(""), fmt.Errorf("unsupported parameter types in RenderAlert")</span>
}

// RenderModal renders a modal component
func (r *ComponentRenderer) RenderModal(id, title, content string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "id":      id,
                "title":   title,
                "content": template.HTML(content),
        }

        // Set defaults
        if _, ok := options["size"]; !ok </span><span class="cov0" title="0">{
                data["size"] = "medium"
        }</span>

        // Merge options
        <span class="cov0" title="0">for k, v := range options </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return r.RenderComponent("components/modal", data)</span>
}

// RenderPagination renders a pagination component
func (r *ComponentRenderer) RenderPagination(currentPage, totalPages int, baseURL string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "current_page": currentPage,
                "total_pages":  totalPages,
                "base_url":     baseURL,
        }

        // Set defaults
        if _, ok := options["show_first_last"]; !ok </span><span class="cov0" title="0">{
                data["show_first_last"] = true
        }</span>

        <span class="cov0" title="0">if _, ok := options["size"]; !ok </span><span class="cov0" title="0">{
                data["size"] = "md"
        }</span>

        // Merge options
        <span class="cov0" title="0">for k, v := range options </span><span class="cov0" title="0">{
                data[k] = v
        }</span>

        <span class="cov0" title="0">return r.RenderComponent("components/pagination", data)</span>
}

// CreateTemplateFuncs returns a map of template functions for rendering components
func (r *ComponentRenderer) CreateTemplateFuncs() template.FuncMap <span class="cov0" title="0">{
        return template.FuncMap{
                "component": func(name string, data interface{}) (template.HTML, error) </span><span class="cov0" title="0">{
                        return r.RenderComponent(name, data)
                }</span>,
                "partial": func(name string, data interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderPartial(name, data)
                }</span>,
                "notification": func(type_, title, message string) (template.HTML, error) <span class="cov0" title="0">{
                        return r.CustomNotification(type_, title, message)
                }</span>,
                "infoNotification": func(title, message string) (template.HTML, error) <span class="cov0" title="0">{
                        return r.InfoNotification(title, message)
                }</span>,
                "successNotification": func(title, message string) (template.HTML, error) <span class="cov0" title="0">{
                        return r.SuccessNotification(title, message)
                }</span>,
                "warningNotification": func(title, message string) (template.HTML, error) <span class="cov0" title="0">{
                        return r.WarningNotification(title, message)
                }</span>,
                "errorNotification": func(title, message string) (template.HTML, error) <span class="cov0" title="0">{
                        return r.ErrorNotification(title, message)
                }</span>,
                "breadcrumb": func(items []map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderBreadcrumb(items)
                }</span>,
                "card": func(title, content string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderCard(title, content, options)
                }</span>,
                "table": func(headers []string, rows [][]string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderTable(headers, rows, options)
                }</span>,
                "button": func(text, url string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderButton(text, url, options)
                }</span>,
                "alert": func(message string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderAlert(message, options)
                }</span>,
                "modal": func(id, title, content string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderModal(id, title, content, options)
                }</span>,
                "pagination": func(currentPage, totalPages int, baseURL string, options map[string]interface{}) (template.HTML, error) <span class="cov0" title="0">{
                        return r.RenderPagination(currentPage, totalPages, baseURL, options)
                }</span>,
                // Helper functions
                "join": strings.Join,
                "safeHTML": func(s string) template.HTML <span class="cov0" title="0">{
                        return template.HTML(s)
                }</span>,
                "dict": func(values ...interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
                        if len(values)%2 != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid dict call, needs even number of arguments")
                        }</span>
                        <span class="cov0" title="0">dict := make(map[string]interface{}, len(values)/2)
                        for i := 0; i &lt; len(values); i += 2 </span><span class="cov0" title="0">{
                                key, ok := values[i].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("dict keys must be strings")
                                }</span>
                                <span class="cov0" title="0">dict[key] = values[i+1]</span>
                        }
                        <span class="cov0" title="0">return dict, nil</span>
                },
        }
}

// AlertData, uyarı bileşeni için veri yapısı
type AlertData struct {
        Type    string // primary, secondary, success, danger, warning, info, dark
        Icon    string // Material icon name
        Title   string
        Content string
}

// RenderAlertWithIcon, ikonlu alert bileşenini işler
func (r *ComponentRenderer) RenderAlertWithIcon(alertType string, icon string, title string, content string) (template.HTML, error) <span class="cov0" title="0">{
        data := ComponentData{
                "Type":    alertType,
                "Icon":    icon,
                "Title":   title,
                "Content": content,
        }
        return r.RenderComponent("alert-color-with-icon", data)
}</span>

// RenderBorderAlert, kenarlıklı alert bileşenini işler
func (r *ComponentRenderer) RenderBorderAlert(alertType string, content string) (template.HTML, error) <span class="cov0" title="0">{
        data := ComponentData{
                "Type":    alertType,
                "Content": content,
        }
        return r.RenderComponent("alert-border", data)
}</span>

// RenderBorderAlertWithIcon, ikonlu kenarlıklı alert bileşenini işler
func (r *ComponentRenderer) RenderBorderAlertWithIcon(alertType string, icon string, title string, content string) (template.HTML, error) <span class="cov0" title="0">{
        data := ComponentData{
                "Type":    alertType,
                "Icon":    icon,
                "Title":   title,
                "Content": content,
        }
        return r.RenderComponent("alert-border-with-icon", data)
}</span>

// NotificationCardData, bildirim kartı bileşeni için veri yapısı
type NotificationCardData struct {
        Type     string // primary, info, warning, danger, success
        Icon     string // Material icon name
        Title    string
        Function string // JavaScript function to call
}

// RenderNotificationCard, bildirim kartı bileşenini işler
func (r *ComponentRenderer) RenderNotificationCard(notifType string, icon string, title string, function string) (template.HTML, error) <span class="cov0" title="0">{
        data := ComponentData{
                "Type":     notifType,
                "Icon":     icon,
                "Title":    title,
                "Function": function,
        }
        return r.RenderComponent("notification-card", data)
}</span>

// NotificationDropdownItemData, bildirim dropdown öğesi için veri yapısı
type NotificationDropdownItemData struct {
        ImageURL    string
        InitialsBg  string // primary, danger, etc.
        Initials    string // e.g. "RS" for user initials
        Title       string
        Description string
        Time        string
}

// NotificationDropdownOptionData, bildirim dropdown seçeneği için veri yapısı
type NotificationDropdownOptionData struct {
        Icon string
        Text string
}

// NotificationDropdownData, bildirim dropdown bileşeni için veri yapısı
type NotificationDropdownData struct {
        Title   string
        Options []NotificationDropdownOptionData
        Divider bool
        Items   []NotificationDropdownItemData
}

// RenderNotificationDropdown, bildirim dropdown bileşenini işler
func (r *ComponentRenderer) RenderNotificationDropdown(data NotificationDropdownData) (template.HTML, error) <span class="cov0" title="0">{
        componentData := ComponentData{
                "Title":   data.Title,
                "Options": data.Options,
                "Divider": data.Divider,
                "Items":   data.Items,
        }
        return r.RenderComponent("notification-dropdown", componentData)
}</span>

// GetNotificationJS, bildirim JS kodunu döndürür
func (r *ComponentRenderer) GetNotificationJS() (template.HTML, error) <span class="cov0" title="0">{
        return r.RenderComponent("notification-js", nil)
}</span>

// RenderAlertToResponse, uyarı bileşenini doğrudan HTTP yanıtına işler
func (r *ComponentRenderer) RenderAlertToResponse(w http.ResponseWriter, data AlertData, withIcon bool, withBorder bool) error <span class="cov0" title="0">{
        var templateName string
        if withIcon </span><span class="cov0" title="0">{
                if withBorder </span><span class="cov0" title="0">{
                        templateName = "alert-border-with-icon"
                }</span> else<span class="cov0" title="0"> {
                        templateName = "alert-color-with-icon"
                }</span>
        } else<span class="cov0" title="0"> {
                if withBorder </span><span class="cov0" title="0">{
                        templateName = "alert-border"
                }</span> else<span class="cov0" title="0"> {
                        templateName = "alert-color"
                }</span>
        }

        // ComponentData oluştur
        <span class="cov0" title="0">componentData := ComponentData{
                "Type":    data.Type,
                "Icon":    data.Icon,
                "Title":   data.Title,
                "Content": data.Content,
        }

        // Şablonu işle
        html, err := r.RenderComponent(templateName, componentData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // HTML yanıtı gönder
        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html")
        _, err = w.Write([]byte(html))
        return err</span>
}

// RenderNotificationCardToResponse, bildirim kartı bileşenini doğrudan HTTP yanıtına işler
func (r *ComponentRenderer) RenderNotificationCardToResponse(w http.ResponseWriter, data NotificationCardData) error <span class="cov0" title="0">{
        componentData := ComponentData{
                "Type":     data.Type,
                "Icon":     data.Icon,
                "Title":    data.Title,
                "Function": data.Function,
        }

        html, err := r.RenderComponent("notification-card", componentData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html")
        _, err = w.Write([]byte(html))
        return err</span>
}

// RenderNotificationDropdownToResponse, bildirim dropdown bileşenini doğrudan HTTP yanıtına işler
func (r *ComponentRenderer) RenderNotificationDropdownToResponse(w http.ResponseWriter, data NotificationDropdownData) error <span class="cov0" title="0">{
        componentData := ComponentData{
                "Title":   data.Title,
                "Options": data.Options,
                "Divider": data.Divider,
                "Items":   data.Items,
        }

        html, err := r.RenderComponent("notification-dropdown", componentData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html")
        _, err = w.Write([]byte(html))
        return err</span>
}

// GetAlertHTML, bir uyarı bileşeni için HTML döndürür
func (r *ComponentRenderer) GetAlertHTML(data AlertData, withIcon bool, withBorder bool) (template.HTML, error) <span class="cov0" title="0">{
        var templateName string
        if withIcon </span><span class="cov0" title="0">{
                if withBorder </span><span class="cov0" title="0">{
                        templateName = "alert-border-with-icon"
                }</span> else<span class="cov0" title="0"> {
                        templateName = "alert-color-with-icon"
                }</span>
        } else<span class="cov0" title="0"> {
                if withBorder </span><span class="cov0" title="0">{
                        templateName = "alert-border"
                }</span> else<span class="cov0" title="0"> {
                        templateName = "alert-color"
                }</span>
        }

        // ComponentData oluştur
        <span class="cov0" title="0">componentData := ComponentData{
                "Type":    data.Type,
                "Icon":    data.Icon,
                "Title":   data.Title,
                "Content": data.Content,
        }

        return r.RenderComponent(templateName, componentData)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package validation

import (
        "regexp"
        "strconv"
        "strings"
        "time"
)

// RequiredRule checks if a value is not empty
func RequiredRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return false, "Bu alan zorunludur"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// EmailRule validates email format
func EmailRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Geçerli bir e-posta adresi giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// MinLengthRule validates minimum string length
func MinLengthRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">if len(options) == 0 </span><span class="cov0" title="0">{
                return false, "Min uzunluk değeri belirtilmemiş"
        }</span>

        <span class="cov0" title="0">minLength, err := strconv.Atoi(options[0].(string))
        if err != nil </span><span class="cov0" title="0">{
                return false, "Geçersiz min uzunluk değeri"
        }</span>

        <span class="cov0" title="0">if len(value) &lt; minLength </span><span class="cov0" title="0">{
                return false, "En az " + strconv.Itoa(minLength) + " karakter gereklidir"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// MaxLengthRule validates maximum string length
func MaxLengthRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">if len(options) == 0 </span><span class="cov0" title="0">{
                return false, "Max uzunluk değeri belirtilmemiş"
        }</span>

        <span class="cov0" title="0">maxLength, err := strconv.Atoi(options[0].(string))
        if err != nil </span><span class="cov0" title="0">{
                return false, "Geçersiz max uzunluk değeri"
        }</span>

        <span class="cov0" title="0">if len(value) &gt; maxLength </span><span class="cov0" title="0">{
                return false, "En fazla " + strconv.Itoa(maxLength) + " karakter olmalıdır"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// NumericRule validates if a string contains only numbers
func NumericRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">numericRegex := regexp.MustCompile(`^[0-9]+$`)
        if !numericRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Sadece rakam giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// AlphaRule validates if a string contains only letters
func AlphaRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">alphaRegex := regexp.MustCompile(`^[a-zA-ZğüşıöçĞÜŞİÖÇ ]+$`)
        if !alphaRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Sadece harf giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// AlphaNumericRule validates if a string contains only letters and numbers
func AlphaNumericRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">alphaNumericRegex := regexp.MustCompile(`^[a-zA-Z0-9ğüşıöçĞÜŞİÖÇ ]+$`)
        if !alphaNumericRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Sadece harf ve rakam giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// PhoneRule validates Turkish phone number format
func PhoneRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        // Türk telefon numarası formatı: 0 ile başlayan herhangi bir format
        <span class="cov0" title="0">phoneRegex := regexp.MustCompile(`^0[0-9 ]{10,14}$`)
        if !phoneRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Telefon numarası 0 ile başlamalıdır"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// URLRule validates if a string is a valid URL
func URLRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">urlRegex := regexp.MustCompile(`^(http|https):\/\/[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-zA-Z]{2,}(:[0-9]{1,5})?(\/.*)?$`)
        if !urlRegex.MatchString(value) </span><span class="cov0" title="0">{
                return false, "Geçerli bir URL giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// DateRule validates if a string is a valid date
func DateRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return true, "" // Empty is valid, use required rule to make mandatory
        }</span>

        <span class="cov0" title="0">format := "2006-01-02" // Default format
        if len(options) &gt; 0 </span><span class="cov0" title="0">{
                format = options[0].(string)
        }</span>

        <span class="cov0" title="0">_, err := time.Parse(format, value)
        if err != nil </span><span class="cov0" title="0">{
                return false, "Geçerli bir tarih giriniz"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// MatchRule validates if a string matches another field
func MatchRule(value string, options ...interface{}) (bool, string) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return false, "Eşleşme alanı belirtilmemiş"
        }</span>

        // options[0] should be the field name, options[1] should be the value to match
        <span class="cov0" title="0">if len(options) &lt; 2 </span><span class="cov0" title="0">{
                return false, "Eşleşme değeri sağlanmamış"
        }</span>

        <span class="cov0" title="0">fieldName := options[0].(string)
        matchValue := options[1].(string)

        if value != matchValue </span><span class="cov0" title="0">{
                return false, fieldName + " alanı ile eşleşmiyor"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package validation

// FormSchema defines validation rules for a form
type FormSchema struct {
        Fields map[string]FieldRules
}

// FieldRules defines validation rules for a field
type FieldRules struct {
        Required  bool
        MinLength int
        MaxLength int
        Pattern   string
        Message   string
}

// RegisterSchemas creates and returns all form validation schemas
func RegisterSchemas() map[string]FormSchema <span class="cov0" title="0">{
        schemas := make(map[string]FormSchema)

        // Register formu için şema
        schemas["register"] = FormSchema{
                Fields: map[string]FieldRules{
                        "name": {
                                Required:  true,
                                MinLength: 5,
                                Message:   "Ad Soyad en az 5 karakter olmalıdır",
                        },
                        "email": {
                                Required: true,
                                Pattern:  `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`,
                                Message:  "Geçerli bir e-posta adresi giriniz",
                        },
                        "phone": {
                                Required: true,
                                Pattern:  `^0[0-9 ]{10,14}$`,
                                Message:  "Telefon numarası 0 ile başlamalıdır",
                        },
                        "captcha": {
                                Required: true,
                                Message:  "Güvenlik sorusunun cevabını giriniz",
                        },
                        "terms": {
                                Required: true,
                                Message:  "Kullanım koşullarını kabul etmelisiniz",
                        },
                },
        }

        // Login formu için şema
        schemas["login"] = FormSchema{
                Fields: map[string]FieldRules{
                        "email": {
                                Required: true,
                                Pattern:  `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`,
                                Message:  "Geçerli bir e-posta adresi giriniz",
                        },
                        "password": {
                                Required: true,
                                Message:  "Şifre alanı zorunludur",
                        },
                },
        }

        // Şifre sıfırlama formu için şema
        schemas["forgotPassword"] = FormSchema{
                Fields: map[string]FieldRules{
                        "email": {
                                Required: true,
                                Pattern:  `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`,
                                Message:  "Geçerli bir e-posta adresi giriniz",
                        },
                },
        }

        // Şifre değiştirme formu için şema
        schemas["resetPassword"] = FormSchema{
                Fields: map[string]FieldRules{
                        "password": {
                                Required:  true,
                                MinLength: 8,
                                Message:   "Şifre en az 8 karakter olmalıdır",
                        },
                        "password_confirm": {
                                Required: true,
                                Message:  "Şifre tekrarı zorunludur",
                        },
                },
        }

        return schemas
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package validation

import (
        "fmt"
        "strings"
)

// Validator defines the basic validation operations
type Validator interface {
        Validate(field string, value string, rules ...string) (bool, []string)
        ValidateMap(data map[string]string, rules map[string][]string) (bool, map[string][]string)
}

// DefaultValidator is the standard implementation of Validator
type DefaultValidator struct {
        rules   map[string]ValidationRule
        errors  map[string][]string
        options map[string]interface{}
}

// ValidationRule defines a validation function
type ValidationRule func(value string, options ...interface{}) (bool, string)

// New creates a new DefaultValidator with standard rules
func New(options ...map[string]interface{}) *DefaultValidator <span class="cov0" title="0">{
        v := &amp;DefaultValidator{
                rules:   make(map[string]ValidationRule),
                errors:  make(map[string][]string),
                options: make(map[string]interface{}),
        }

        // Add default options if provided
        if len(options) &gt; 0 </span><span class="cov0" title="0">{
                for k, val := range options[0] </span><span class="cov0" title="0">{
                        v.options[k] = val
                }</span>
        }

        // Register default rules
        <span class="cov0" title="0">v.RegisterRule("required", RequiredRule)
        v.RegisterRule("email", EmailRule)
        v.RegisterRule("min", MinLengthRule)
        v.RegisterRule("max", MaxLengthRule)
        v.RegisterRule("numeric", NumericRule)
        v.RegisterRule("alpha", AlphaRule)
        v.RegisterRule("alphanumeric", AlphaNumericRule)
        v.RegisterRule("phone", PhoneRule)
        v.RegisterRule("url", URLRule)
        v.RegisterRule("date", DateRule)
        v.RegisterRule("match", MatchRule)

        return v</span>
}

// RegisterRule adds a new validation rule
func (v *DefaultValidator) RegisterRule(name string, rule ValidationRule) <span class="cov0" title="0">{
        v.rules[name] = rule
}</span>

// Validate checks a single field against the given rules
func (v *DefaultValidator) Validate(field string, value string, rules ...string) (bool, []string) <span class="cov0" title="0">{
        v.errors[field] = []string{}
        valid := true

        for _, ruleStr := range rules </span><span class="cov0" title="0">{
                // Parse rule and options
                ruleParts := strings.Split(ruleStr, ":")
                ruleName := ruleParts[0]

                var ruleOptions []interface{}
                if len(ruleParts) &gt; 1 </span><span class="cov0" title="0">{
                        // Has options
                        for _, opt := range strings.Split(ruleParts[1], ",") </span><span class="cov0" title="0">{
                                ruleOptions = append(ruleOptions, opt)
                        }</span>
                }

                // Get the rule function
                <span class="cov0" title="0">ruleFunc, exists := v.rules[ruleName]
                if !exists </span><span class="cov0" title="0">{
                        v.errors[field] = append(v.errors[field], fmt.Sprintf("Unknown validation rule: %s", ruleName))
                        valid = false
                        continue</span>
                }

                // Apply the rule
                <span class="cov0" title="0">ruleValid, errorMsg := ruleFunc(value, ruleOptions...)
                if !ruleValid </span><span class="cov0" title="0">{
                        v.errors[field] = append(v.errors[field], errorMsg)
                        valid = false
                }</span>
        }

        <span class="cov0" title="0">return valid, v.errors[field]</span>
}

// ValidateMap validates multiple fields at once
func (v *DefaultValidator) ValidateMap(data map[string]string, rules map[string][]string) (bool, map[string][]string) <span class="cov0" title="0">{
        v.errors = make(map[string][]string)
        valid := true

        for field, fieldRules := range rules </span><span class="cov0" title="0">{
                value, exists := data[field]
                if !exists </span><span class="cov0" title="0">{
                        value = "" // Field doesn't exist, treat as empty
                }</span>

                <span class="cov0" title="0">fieldValid, _ := v.Validate(field, value, fieldRules...)
                if !fieldValid </span><span class="cov0" title="0">{
                        valid = false
                }</span>
        }

        <span class="cov0" title="0">return valid, v.errors</span>
}

// GetErrors returns all validation errors
func (v *DefaultValidator) GetErrors() map[string][]string <span class="cov0" title="0">{
        return v.errors
}</span>

// GetFirstError returns the first error for a field, or empty string if none
func (v *DefaultValidator) GetFirstError(field string) string <span class="cov0" title="0">{
        if errors, exists := v.errors[field]; exists &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return errors[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package validation

import (
        "encoding/json"
        "fmt"
        "regexp"
)

// FormValidator is a specialized validator for web forms
type FormValidator struct {
        validator *DefaultValidator
        schemas   map[string]FormSchema
        patterns  map[string]*regexp.Regexp // Cache compiled regex patterns
}

// NewFormValidator creates a new form validator
func NewFormValidator() *FormValidator <span class="cov0" title="0">{
        return &amp;FormValidator{
                validator: New(),
                schemas:   RegisterSchemas(),
                patterns:  make(map[string]*regexp.Regexp),
        }
}</span>

// ValidateForm validates a form against its schema
func (v *FormValidator) ValidateForm(formName string, data map[string]string) (bool, map[string][]string) <span class="cov0" title="0">{
        schema, exists := v.schemas[formName]
        if !exists </span><span class="cov0" title="0">{
                return false, map[string][]string{
                        "_form": {"Form şeması bulunamadı: " + formName},
                }
        }</span>

        // Convert schema to validation rules
        <span class="cov0" title="0">rules := make(map[string][]string)
        for fieldName, fieldRules := range schema.Fields </span><span class="cov0" title="0">{
                fieldValidations := []string{}

                if fieldRules.Required </span><span class="cov0" title="0">{
                        fieldValidations = append(fieldValidations, "required")
                }</span>

                <span class="cov0" title="0">if fieldRules.MinLength &gt; 0 </span><span class="cov0" title="0">{
                        fieldValidations = append(fieldValidations, fmt.Sprintf("min:%d", fieldRules.MinLength))
                }</span>

                <span class="cov0" title="0">if fieldRules.MaxLength &gt; 0 </span><span class="cov0" title="0">{
                        fieldValidations = append(fieldValidations, fmt.Sprintf("max:%d", fieldRules.MaxLength))
                }</span>

                <span class="cov0" title="0">if fieldRules.Pattern != "" </span><span class="cov0" title="0">{
                        // Special handling for known patterns
                        if fieldRules.Pattern == `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$` </span><span class="cov0" title="0">{
                                fieldValidations = append(fieldValidations, "email")
                        }</span> else<span class="cov0" title="0"> if fieldRules.Pattern == `^0[0-9]{3} [0-9]{3} [0-9]{4}$` </span><span class="cov0" title="0">{
                                fieldValidations = append(fieldValidations, "phone")
                        }</span> else<span class="cov0" title="0"> {
                                // Custom pattern validation
                                if err := v.validateCustomPattern(fieldName, data[fieldName], fieldRules.Pattern); err != nil </span><span class="cov0" title="0">{
                                        return false, map[string][]string{
                                                fieldName: {err.Error()},
                                        }
                                }</span>
                        }
                }

                <span class="cov0" title="0">rules[fieldName] = fieldValidations</span>
        }

        <span class="cov0" title="0">return v.validator.ValidateMap(data, rules)</span>
}

// validateCustomPattern validates a field against a custom regex pattern
func (v *FormValidator) validateCustomPattern(fieldName, value, pattern string) error <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil // Empty values are handled by required validation
        }</span>

        // Check if pattern is already compiled and cached
        <span class="cov0" title="0">regex, exists := v.patterns[pattern]
        if !exists </span><span class="cov0" title="0">{
                var err error
                regex, err = regexp.Compile(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("geçersiz regex pattern: %v", err)
                }</span>
                <span class="cov0" title="0">v.patterns[pattern] = regex</span>
        }

        <span class="cov0" title="0">if !regex.MatchString(value) </span><span class="cov0" title="0">{
                return fmt.Errorf("alan geçerli formatta değil")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSchemaJSON returns the JSON representation of a form schema
func (v *FormValidator) GetSchemaJSON(formName string) (string, error) <span class="cov0" title="0">{
        schema, exists := v.schemas[formName]
        if !exists </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Convert to client-side friendly format
        <span class="cov0" title="0">clientSchema := make(map[string]map[string]interface{})

        for fieldName, fieldRules := range schema.Fields </span><span class="cov0" title="0">{
                clientSchema[fieldName] = map[string]interface{}{
                        "required": fieldRules.Required,
                        "message":  fieldRules.Message,
                }

                if fieldRules.MinLength &gt; 0 </span><span class="cov0" title="0">{
                        clientSchema[fieldName]["minLength"] = fieldRules.MinLength
                }</span>

                <span class="cov0" title="0">if fieldRules.MaxLength &gt; 0 </span><span class="cov0" title="0">{
                        clientSchema[fieldName]["maxLength"] = fieldRules.MaxLength
                }</span>

                <span class="cov0" title="0">if fieldRules.Pattern != "" </span><span class="cov0" title="0">{
                        clientSchema[fieldName]["pattern"] = fieldRules.Pattern
                }</span>
        }

        <span class="cov0" title="0">jsonData, err := json.Marshal(clientSchema)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(jsonData), nil</span>
}

// RegisterSchema adds a new form schema
func (v *FormValidator) RegisterSchema(name string, schema FormSchema) <span class="cov0" title="0">{
        v.schemas[name] = schema
}</span>

// AddCustomPattern adds a custom regex pattern for validation
func (v *FormValidator) AddCustomPattern(name, pattern string) error <span class="cov0" title="0">{
        regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("geçersiz regex pattern '%s': %v", pattern, err)
        }</span>
        <span class="cov0" title="0">v.patterns[name] = regex
        return nil</span>
}

// ValidateWithCustomPattern validates a value against a named custom pattern
func (v *FormValidator) ValidateWithCustomPattern(value, patternName string) error <span class="cov0" title="0">{
        regex, exists := v.patterns[patternName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("pattern '%s' bulunamadı", patternName)
        }</span>

        <span class="cov0" title="0">if !regex.MatchString(value) </span><span class="cov0" title="0">{
                return fmt.Errorf("değer '%s' pattern'ine uymuyor", patternName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
